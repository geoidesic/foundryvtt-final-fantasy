var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
const SYSTEM_ID = "foundryvtt-final-fantasy";
const SYSTEM_CODE = "FFXIV";
const LOG_PREFIX = `${SYSTEM_CODE} |`;
const LOG_PREFIX_COLOR = `%c[${SYSTEM_CODE}] |`;
const ASSET_PATH = `systems/${SYSTEM_ID}/assets`;
const LOG_STYLES = {
  p: "color: purple;",
  g: "color: green;",
  r: "color: red;",
  o: "color: orange;",
  b: "color: blue;",
  y: "color: yellow;",
  c: "color: cyan;",
  m: "color: magenta;",
  gr: "color: gray;",
  br: "color: brown;",
  pi: "color: pink;",
  t: "color: teal;"
};
const getDamageDiceRerollOptions = /* @__PURE__ */ __name(() => [
  { value: 1, label: game.i18n.localize("FFXIV.Types.Item.Types.Options.DamageDiceReroll.one") },
  { value: 2, label: game.i18n.localize("FFXIV.Types.Item.Types.Options.DamageDiceReroll.two") },
  { value: 3, label: game.i18n.localize("FFXIV.Types.Item.Types.Options.DamageDiceReroll.three") }
], "getDamageDiceRerollOptions");
const getDurationOptions = /* @__PURE__ */ __name(() => [
  { value: 1, label: game.i18n.localize("FFXIV.one") },
  { value: 2, label: game.i18n.localize("FFXIV.two") },
  { value: 3, label: game.i18n.localize("FFXIV.three") },
  { value: 4, label: game.i18n.localize("FFXIV.four") }
], "getDurationOptions");
function getDurationTypeOptions() {
  return [
    { value: "hasAmount", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.DurationType.hasAmount") },
    { value: "hasQualifier", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.DurationType.hasQualifier") }
  ];
}
__name(getDurationTypeOptions, "getDurationTypeOptions");
const getDurationQualifierOptions = /* @__PURE__ */ __name(() => [
  { value: "endOfThis", label: game.i18n.localize("FFXIV.Types.Item.Duration.Options.endOfThis") },
  { value: "endOfNext", label: game.i18n.localize("FFXIV.Types.Item.Duration.Options.endOfNext") },
  { value: "startOfNext", label: game.i18n.localize("FFXIV.Types.Item.Duration.Options.startOfNext") },
  { value: "untilDamage", label: game.i18n.localize("FFXIV.Types.Item.Duration.Options.untilDamage") },
  { value: "nextAbility", label: game.i18n.localize("FFXIV.Types.Item.Duration.Options.nextAbility") }
], "getDurationQualifierOptions");
const getDurationUnits = /* @__PURE__ */ __name(() => [
  { value: "phase", label: game.i18n.localize("FFXIV.Phase") },
  { value: "turn", label: game.i18n.localize("FFXIV.Turn") },
  { value: "round", label: game.i18n.localize("FFXIV.Round") }
], "getDurationUnits");
const getLimitationOptions = /* @__PURE__ */ __name(() => [
  { value: 1, label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Limitation.once") },
  { value: 2, label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Limitation.twice") },
  { value: 3, label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Limitation.thrice") }
], "getLimitationOptions");
const getLimitationUnits = /* @__PURE__ */ __name(() => [
  { value: "phase", label: game.i18n.localize("FFXIV.Phase") },
  { value: "turn", label: game.i18n.localize("FFXIV.Turn") }
], "getLimitationUnits");
const getTypeOptions = /* @__PURE__ */ __name(() => [
  { value: "primary", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Type.primary") },
  { value: "secondary", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Type.secondary") },
  { value: "reaction", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Type.reaction") },
  { value: "limit", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Type.limit") },
  { value: "combo", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Type.combo") }
], "getTypeOptions");
const getBaseEffectHealingTypeOptions = /* @__PURE__ */ __name(() => [
  { value: "self", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.BaseEffectHealingType.self") },
  { value: "target", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.BaseEffectHealingType.target") }
], "getBaseEffectHealingTypeOptions");
const getSizeOptions = /* @__PURE__ */ __name(() => [
  { value: "small", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Size.small") },
  { value: "medium", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Size.medium") },
  { value: "large", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Size.large") },
  { value: "huge", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Size.huge") },
  { value: "gargantuan", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Size.gargantuan") }
], "getSizeOptions");
const getRangeOptions = /* @__PURE__ */ __name(() => [
  { value: "1sq", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Range.1sq") },
  { value: "5sq", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Range.5sq") },
  { value: "10sq", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Range.10sq") },
  { value: "3x3a", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Range.3x3a") },
  { value: "3x3aa", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Range.3x3aa") },
  { value: "5x5a", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Range.5x5a") },
  { value: "5x5e", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Range.5x5e") },
  { value: "5x5i", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Range.5x5i") }
], "getRangeOptions");
const getCROptions = /* @__PURE__ */ __name(() => [
  { value: "def", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.CR.def") },
  { value: "mag", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.CR.mag") },
  // { value: "vig", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.CR.vig") },
  // { value: "spd", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.CR.spd") },
  { value: "heal", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.CR.heal") },
  { value: "other", label: game.i18n.localize("FFXIV.Other") },
  { value: "none", label: game.i18n.localize("FFXIV.None") }
  // { value: "special", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.CR.special") },
], "getCROptions");
const getTargetOptions = /* @__PURE__ */ __name(() => [
  { value: "self", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Target.self") },
  { value: "single", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Target.single") },
  { value: "enemy", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Target.enemy") },
  { value: "all", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Target.all") },
  { value: "allallies", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Target.allallies") },
  { value: "ally", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Target.ally") }
], "getTargetOptions");
const getAspectedOptions = /* @__PURE__ */ __name(() => [
  { value: "earth", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Aspected.earth") },
  { value: "lightning", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Aspected.lightning") },
  { value: "wind", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Aspected.wind") },
  { value: "ice", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Aspected.ice") },
  { value: "fire", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Aspected.fire") }
], "getAspectedOptions");
const getTriggerOptions = /* @__PURE__ */ __name(() => [
  { value: "any", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Trigger.any") },
  { value: "ability", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Trigger.ability") },
  { value: "beforeresolve", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Trigger.beforeresolve") },
  { value: "nearby", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Trigger.nearby") },
  { value: "move", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Trigger.move") },
  { value: "beforedamage", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Trigger.beforedamage") },
  { value: "endturn", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Trigger.endturn") },
  { value: "startturn", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Trigger.startturn") },
  { value: "invoke", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Trigger.invoke") },
  { value: "adjacentinvoke", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Trigger.adjacentinvoke") }
], "getTriggerOptions");
const getHeavyshotOptions = /* @__PURE__ */ __name(() => [
  { value: "straignt", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Heavyshot.straignt") },
  { value: "spread", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.Heavyshot.spread") }
], "getHeavyshotOptions");
const getDirectHitOptions = /* @__PURE__ */ __name(() => [
  { value: "damage", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.DirectHit.damage") },
  { value: "markers", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.DirectHit.markers") },
  { value: "condition", label: game.i18n.localize("FFXIV.Types.Item.Types.Options.DirectHit.condition") }
], "getDirectHitOptions");
const ACTIVE_EFFECT_MODES = {
  CUSTOM: 0,
  MULTIPLY: 1,
  ADD: 2,
  OVERRIDE: 3,
  DOWNGRADE: 4,
  UPGRADE: 5
};
const activeEffectModes = [
  { value: ACTIVE_EFFECT_MODES.CUSTOM, label: "custom" },
  { value: ACTIVE_EFFECT_MODES.MULTIPLY, label: "multiply" },
  { value: ACTIVE_EFFECT_MODES.ADD, label: "add" },
  { value: ACTIVE_EFFECT_MODES.OVERRIDE, label: "override" },
  { value: ACTIVE_EFFECT_MODES.DOWNGRADE, label: "downgrade" },
  { value: ACTIVE_EFFECT_MODES.UPGRADE, label: "upgrade" }
];
class DefaultChatHandler {
  static {
    __name(this, "DefaultChatHandler");
  }
  /**
   * @param {Actor} actor - The actor this handler is for
   */
  constructor(actor) {
    this.actor = actor;
  }
  /**
   * @param {Item} item - The item to create a chat message for
   */
  handle(item) {
    ChatMessage.create({
      user: game.user.id,
      speaker: game.settings.get(SYSTEM_ID, "chatMessageSenderIsActorOwner") ? ChatMessage.getSpeaker({ actor: this.actor }) : null,
      flags: {
        [SYSTEM_ID]: {
          data: {
            chatTemplate: "RollChat",
            actor: {
              _id: this.actor._id,
              name: this.actor.name,
              img: this.actor.img
            },
            item: {
              _id: item._id,
              uuid: item.uuid,
              name: item.name,
              img: item.img,
              type: item.type,
              system: item.system
            }
          }
        }
      }
    });
  }
}
class EffectManager {
  static {
    __name(this, "EffectManager");
  }
  /**
   * @param {Actor} actor - The actor this handler is for
   */
  constructor(actor) {
    this.actor = actor;
    this.DefaultChatHandler = new DefaultChatHandler(actor);
  }
  /**
   * Apply effects from a list to specified targets
   * @protected
   * @param {Item} sourceItem - The item granting the effects
   * @param {Array} effectList - List of effect references to process
   * @param {Array} targets - Array of targets to apply effects to
   */
  async _applyEffectsFromList(sourceItem, effectList, targets) {
    if (!effectList?.length || !targets?.length) {
      if (!effectList?.length) {
        game.system.log.w("[EFFECT MANAGER] No effects to apply");
      }
      if (!targets?.length) {
        game.system.log.w("[EFFECT MANAGER] No targets to apply effects to");
      }
      return;
    }
    game.system.log.o("[EFFECT MANAGER] Processing effects from:", {
      sourceItem: sourceItem?.name,
      sourceItemUUID: sourceItem?.uuid,
      actor: this.actor?.name,
      effectList,
      targets: targets.map((t) => t.actor?.name)
    });
    for (const target of targets) {
      const targetActor = target.actor;
      if (!targetActor)
        continue;
      try {
        const effectData = await this._prepareEffectData(sourceItem, effectList, targetActor);
        if (effectData.length) {
          await targetActor.createEmbeddedDocuments("ActiveEffect", effectData);
        }
      } catch (error) {
        game.system.log.e("Error applying effects to target", error);
        ui.notifications.error(game.i18n.format("FFXIV.Errors.EffectApplicationFailed", { target: targetActor.name }));
      }
    }
  }
  /**
   * Handle all effects for an action
   * @override
   * @param {Item} item - The item being used
   * @param {Object} result - The result from the action handler
   * @return {Promise<void>} Returns a promise that resolves when all effects are handled
   */
  async handleEffects(item, result) {
  }
  /**
   * Prepare effect data from effect items
   * @protected
   * @param {Item} sourceItem - The item granting the effects
   * @param {Array} effectList - List of effect references to process
   * @param {Actor} targetActor - The actor to check against for existing effects
   * @return {Promise<Array>} Array of prepared effect data
   */
  async _prepareEffectData(sourceItem, effectList, targetActor) {
    const effectPromises = effectList.flatMap(async (grantRef) => {
      const effectItem = await fromUuid(grantRef.uuid);
      if (!effectItem)
        return [];
      return effectItem.effects.map((effect) => {
        const existingEffect = targetActor.effects.find(
          (e) => e.name === effect.name && e.origin === sourceItem.uuid
        );
        if (existingEffect)
          return null;
        if (effect.statuses?.size) {
          return this._handleStatusEffect(effect, targetActor);
        }
        return this._prepareCleanEffectData(effect, effectItem, sourceItem);
      });
    });
    return (await Promise.all(effectPromises)).flat().filter(Boolean);
  }
  /**
   * Handle status effect application
   * @protected
   * @param {ActiveEffect} effect - The effect to process
   * @param {Actor} targetActor - The actor to apply the status to
   * @return {null} Always returns null as statuses are handled directly
   */
  _handleStatusEffect(effect, targetActor) {
    const statuses = Array.from(effect.statuses);
    const statusesToToggle = statuses.filter((status) => !targetActor.statuses.has(status));
    if (statusesToToggle.length) {
      targetActor.toggleStatusEffect(statusesToToggle[0]);
    }
    return null;
  }
  /**
   * Prepare clean effect data for creation
   * @protected
   * @param {ActiveEffect} effect - The effect to clean
   * @param {Item} effectItem - The item containing the effect
   * @param {Item} sourceItem - The item granting the effect
   * @return {Object} Clean effect data
   */
  _prepareCleanEffectData(effect, effectItem, sourceItem) {
    game.system.log.o("[EFFECT MANAGER] Preparing clean effect data:", {
      effectName: effect.name,
      effectItemSystem: effectItem.system,
      sourceItemSystem: sourceItem.system
    });
    const durations = sourceItem.system.durations || effectItem.system.durations || [];
    const duration = durations[0] || { type: "none" };
    const durationData = {
      startTime: game.time.worldTime,
      startRound: game.combat?.round ?? 0,
      startTurn: game.combat?.turn ?? 0,
      combat: game.combat?.id
    };
    if (duration.type === "hasAmount" && duration.amount) {
      durationData.type = duration.units || "rounds";
      durationData[duration.units === "turns" ? "turns" : "rounds"] = duration.amount;
    } else if (duration.type === "hasQualifier" && duration.qualifier) {
      durationData.type = duration.qualifier;
      if (duration.qualifier === "nextAbility") {
        durationData.requiresAbility = true;
      } else if (duration.qualifier === "untilDamage") {
        durationData.requiresDamage = true;
      }
    }
    game.system.log.o("[EFFECT MANAGER] Prepared duration data:", {
      effectName: effect.name,
      durationType: duration.type,
      durationUnits: duration.units,
      durationQualifier: duration.qualifier,
      durationData
    });
    return {
      name: effect.name,
      img: effect.img,
      changes: foundry.utils.deepClone(effect.changes),
      duration: durationData,
      disabled: false,
      flags: foundry.utils.deepClone(effect.flags),
      origin: sourceItem.uuid
    };
  }
  /**
   * Handle enabler effects for an action
   * @protected
   */
  async _handleEnablerEffects(item) {
    if (!item.system.enables?.list?.length)
      return [];
    const enabledEffects = [];
    for (const enableRef of item.system.enables.list) {
      const effects = await this._processEnablerRef(item, enableRef);
      enabledEffects.push(...effects);
    }
    game.system.log.o("[ABILITY:ENABLER] Enabled effects:", enabledEffects);
    return enabledEffects;
  }
  /**
   * Process a single enabler reference
   * @protected
   * @param {Item} sourceItem - The item triggering the enabler
   * @param {Object} enableRef - The reference to the item to enable
   * @return {Promise<Array>} Array of enabled effect UUIDs
   */
  async _processEnablerRef(sourceItem, enableRef) {
  }
  /**
   * Find and validate compendium and actor items for an enabler reference
   * @protected
   * @param {Object} enableRef - The reference to the item to enable
   * @return {Promise<Object>} Object containing compendium and actor items
   */
  async _findEnablerItems(enableRef) {
    const compendiumItem = await fromUuid(enableRef.uuid);
    if (!compendiumItem) {
      game.system.log.w("[ENABLE] Could not find compendium item:", enableRef.uuid);
      return { compendiumItem: null, actorItem: null };
    }
    const actorItem = this.actor.items.find(
      (item) => item.name === compendiumItem.name && item.type === compendiumItem.type
    );
    if (!actorItem) {
      game.system.log.w("[ENABLE] Could not find matching actor item:", compendiumItem.name);
      return { compendiumItem, actorItem: null };
    }
    return { compendiumItem, actorItem };
  }
  /**
   * Check if item should be disabled by tags
   * @protected
   */
  async _shouldDisableByTags(item, origin) {
    const itemTags = item?.system?.tags || [];
    const shouldDisable = origin?.system?.tags?.some((tag) => itemTags.includes(tag)) || false;
    return shouldDisable;
  }
  /**
   * Check if item should be disabled by requirements
   * @protected
   */
  async _shouldDisableByRequirements(item, effect) {
    if (!item.hasRequires)
      return false;
    const requiresList = item.system.requires.list || [];
    const requiredItems = await Promise.all(requiresList.map((req) => fromUuid(req.uuid)));
    const shouldDisable = requiredItems.some((requiredItem) => {
      return requiredItem?.name === effect.name;
    });
    return shouldDisable;
  }
}
class FFXIVActor extends Actor {
  static {
    __name(this, "FFXIVActor");
  }
  /**
   * Creates a new FFXIV actor
   * @param {object} data - The actor data
   * @param {object} context - The initialization context
   */
  constructor(data = {}, context) {
    super(data, context);
  }
  /**
   * Gets the active token for this actor
   * @return {Token|null} The active token or null if none found
   */
  get activeToken() {
    for (const token of canvas.tokens.placeables) {
      if (token.actor === this) {
        return token;
      }
    }
    return null;
  }
  /**
   * Gets all ally tokens for this actor
   * @return {Token[]} Array of ally tokens
   */
  get allyTokens() {
    const tokens = canvas.tokens.placeables;
    if (!tokens?.length)
      return [];
    const combat = game.combat;
    if (!combat)
      return [];
    const combatantActorIds = new Set(combat.combatants.contents.map((c) => c.actor?.id).filter(Boolean));
    return tokens.filter(
      (token) => token.actor && token.document.disposition === 1 && combatantActorIds.has(token.actor.id) && token.actor.id !== this.id
      // Must not be the source actor
    );
  }
  /**
   * Checks for specific duplicates in an array
   * @param {Array} arr - The array to check
   * @param {string} str - The string to look for duplicates
   * @return {boolean} Whether duplicates were found
   */
  hasSpecificDuplicate(arr, str) {
    return arr.filter((item) => item === str).length > 1;
  }
  /**
   * Check if an item has remaining uses
   * @param {Item} item - The item to check for remaining uses
   * @return {boolean} Whether the item has remaining uses
   */
  async actorItemHasRemainingUses(item) {
    game.system.log.p("[USES] Checking remaining uses for:", item);
    game.system.log.p("[USES] Checking remaining uses item name:", item.name);
    game.system.log.p("[USES] hasLimitation:", item.system.hasLimitation);
    game.system.log.p("[USES] currentUses:", item.currentUses);
    game.system.log.p("[USES] usesRemaining:", item.usesRemaining);
    if (!item.system.hasLimitation) {
      return true;
    }
    return item.usesRemaining > 0;
  }
  /**
   * Get the set of actor UUIDs that have applied an effect with this name
   * @param {ActiveEffect} effect - The effect to check for
   * @return {Set<string>} Set of actor UUIDs that have applied this effect
   */
  getEffectSources(effect) {
    return new Set(
      this.effects.filter((e) => e.name === effect.name).map((e) => e.getFlag(SYSTEM_ID, "transferredBy.actor.uuid") || this.uuid)
    );
  }
  /**
   * Remove the first duplicate from an array
   * @param {Array} arr - The array to process
   * @param {string} name - The name to check for duplicates
   * @return {Array} The processed array
   */
  removeFirstDuplicate(arr, name) {
    const index = arr.indexOf(name);
    if (index !== -1 && arr.slice(index + 1).includes(name)) {
      arr.splice(index, 1);
    }
    return arr;
  }
  /**
   * Only applies via the token HUD
   * @param {string} statusId - The ID of the status effect to toggle
   * @param {object} options - Options for toggling the status effect
   * @return {Promise<ActiveEffect|boolean|undefined>} A promise which resolves to one of the following values:
   *                                 - ActiveEffect if a new effect need to be created
   *                                 - true if was already an existing effect
   *                                 - false if an existing effect needed to be removed
   *                                 - undefined if no changes need to be made
   */
  async toggleStatusEffect(statusId, options) {
    if (game.combat?.started && statusId === "focus") {
      if (this.statuses.has("focus") && !this.system.actionState.available.includes("secondary")) {
        ui.notifications.warn("You cannot change Focus while you have no secondary action slots left.");
        return false;
      }
      if (!this.statuses.has("focus") && this.system.hasMoved) {
        ui.notifications.warn("You cannot change Focus while you have moved this turn.");
        return false;
      }
      const movementSacrificingTraits = this.items.filter(
        (item) => item.type === "trait" && item.system.sacrificesMovement
      );
      game.system.log.o("[TOGGLE STATUS] Found movement sacrificing traits:", {
        traits: movementSacrificingTraits.map((t) => ({
          name: t.name,
          type: t.type,
          sacrificesMovement: t.system.sacrificesMovement,
          effects: t.effects.map((e) => ({
            name: e.name,
            disabled: e.disabled,
            changes: e.changes,
            flags: e.flags
          }))
        }))
      });
      this.handlePluginOverrides(movementSacrificingTraits);
    }
    if (["ko", "dead", "comatose", "brink", "surprised", "bind", "stun"].includes(statusId)) {
      options = { ...options, overlay: true };
    }
    return super.toggleStatusEffect(statusId, options);
  }
  /**
   * Handles plugin overrides for status effect toggling
   * @override
   * @param {Array<Trait>} movementSacrificingTraits - The traits that sacrifice movement
   */
  async handlePluginOverrides(movementSacrificingTraits) {
  }
  /** @override */
  prepareData() {
    super.prepareData();
  }
  /** @override */
  prepareBaseData() {
    super.prepareBaseData();
  }
  /**
   * @override
   * Augment the basic actor data with additional dynamic data. Typically,
   * you'll want to handle most of your calculated/derived data in this step.
   * Data calculated in this step should generally not exist in template.json
   * (such as ability modifiers rather than ability scores) and should be
   * available both inside and outside of character sheets (such as if an actor
   * is queried and has a roll executed directly from it).
  */
  prepareDerivedData() {
    super.prepareDerivedData();
  }
  /**
   * Deletes all items of a specific type from the actor
   * @param {string} type - The type of items to delete
   * @return {Promise<void>} Returns a promise that resolves when items are deleted
   */
  async deleteAllItems(type) {
    game.system.log.d(type);
    game.system.log.d(typeof type);
    for (const item of this.items) {
      if (Array.isArray(type) && type.includes(item.type) || !type || type === "all" || item.type === type) {
        await item.delete();
      }
    }
  }
  /**
   * Handles pre-creation setup
   * @return {Promise<void>} Returns a promise that resolves when setup is complete
   */
  async _preCreate() {
    game.system.log.d("preCreate", this);
    if (this.type === "PC") {
      const prototypeToken = { disposition: 1, actorLink: true };
      this.updateSource({ prototypeToken });
    }
  }
  /**
   * Handles dropping content onto the actor
   * @param {DragEvent} event - The drop event
   * @return {Promise<void>} Returns a promise that resolves when the drop is handled
   */
  async _onDrop(event) {
    console.log("_onDrop in the actor.js", event);
  }
}
class FFXIVItem extends Item {
  static {
    __name(this, "FFXIVItem");
  }
  /**
   * Whether the item has a limitation on its usage
   * @return {boolean} True if the item has a limitation
   */
  get hasLimitation() {
    return this.system.hasLimitation;
  }
  /**
   * Whether the item has requirements that must be met
   * @return {boolean} True if the item has requirements
   */
  get hasRequires() {
    return this.system.requires?.value === true;
  }
  /**
   * Get the number of uses remaining for this item
   * @return {number} Number of uses remaining
   */
  get usesRemaining() {
    if (!this.system.hasLimitation)
      return 0;
    return parseInt(this.system.limitation || 0) - this.currentUses;
  }
  /**
   * Get the maximum number of uses for this item
   * @return {number} Maximum number of uses
   */
  get maxUses() {
    return parseInt(this.system.limitation || 0);
  }
  /**
   * Get the current number of times this item has been used
   * @return {number} Current number of uses
   */
  get currentUses() {
    if (this.system.uses === void 0 || this.system.uses === null || this.system.uses === "")
      return 0;
    const parsed = parseInt(this.system.uses);
    if (isNaN(parsed))
      return 0;
    return parsed;
  }
  /**
   * Whether the item has any active effects
   * @return {boolean} True if the item has effects
   */
  get hasEffects() {
    return this.effects?.size > 0;
  }
}
class FFActiveEffect extends ActiveEffect {
  static {
    __name(this, "FFActiveEffect");
  }
  /**
   * Creates a new FFXIV active effect
   * @param {object} data - The effect data
   * @param {object} context - The initialization context
   */
  constructor(data, context) {
    super(data, context);
  }
  /**
   * Gets whether the effect is temporary
   * @return {boolean} Returns true if the effect is temporary
   */
  get isTemporary() {
    if (this.getFlag(SYSTEM_ID, "overlay"))
      return true;
    return super.isTemporary;
  }
  /**
   * Check if the effect is transferred from an item 
   * (i.e. a passive effect from an item owned by that actor, 
   * rather than an active effect transferred as a result of an action 
   * by another actor)
   * @return {boolean} Whether the effect is transferred from an item
   */
  get isTransferred() {
    const origin = fromUuidSync(this.origin);
    if (!origin?.transferredEffects?.length)
      return false;
    return Array.isArray(origin.transferredEffects) && origin.transferredEffects.length > 0;
  }
  /**
   * Updates the combat duration
   * @return {Promise<void>} Returns a promise that resolves when the duration is updated
   */
  async updateCombatDuration() {
    game.system.log.o("[ACTIVE EFFECT] Starting updateCombatDuration for:", {
      name: this.name,
      origin: this.origin,
      duration: this.duration
    });
    const originUuid = this.origin;
    if (!originUuid) {
      game.system.log.w("[ACTIVE EFFECT] No origin UUID found");
      return;
    }
    const originItem = await fromUuid(originUuid);
    if (!originItem) {
      game.system.log.w("[ACTIVE EFFECT] No origin item found for UUID:", originUuid);
      return;
    }
    game.system.log.o("[ACTIVE EFFECT] Found origin item:", {
      name: originItem.name,
      system: originItem.system
    });
    const duration = originItem.system.duration;
    if (!duration) {
      game.system.log.w("[ACTIVE EFFECT] No duration found on origin item");
      return;
    }
    const effectData = {
      duration: {
        startRound: game.combat?.round ?? 0,
        startTurn: game.combat?.turn ?? 0
      }
    };
    if (originItem.system.durationUnits === "rounds") {
      effectData.duration.rounds = originItem.system.duration;
      effectData.duration.turns = 0;
      game.system.log.o("[ACTIVE EFFECT] Setting rounds duration:", effectData.duration);
    } else if (originItem.system.durationUnits === "turns") {
      effectData.duration.turns = originItem.system.duration;
      effectData.duration.rounds = 0;
      game.system.log.o("[ACTIVE EFFECT] Setting turns duration:", effectData.duration);
    }
    game.system.log.o("[ACTIVE EFFECT] Updating effect with duration:", effectData);
    await this.update(effectData);
  }
  async delete(options = {}) {
    game.system.log.o("[ACTIVE EFFECT] Starting effect deletion:", {
      effectName: this.name,
      effectId: this.id,
      effectDuration: this.duration,
      effectFlags: this.flags,
      effectChanges: this.changes,
      effectDisabled: this.disabled,
      options
    });
    try {
      const result = await super.delete(options);
      game.system.log.o("[ACTIVE EFFECT] Effect deletion completed:", {
        effectName: this.name,
        result
      });
      return result;
    } catch (error) {
      game.system.log.e("[ACTIVE EFFECT] Effect deletion failed:", {
        effectName: this.name,
        error
      });
      throw error;
    }
  }
}
const {
  StringField: StringField$8,
  ArrayField: ArrayField$6,
  BooleanField: BooleanField$6
} = foundry.data.fields;
class FFEffectModel extends foundry.abstract.TypeDataModel {
  static {
    __name(this, "FFEffectModel");
  }
  /**
   * Defines the schema for Active Effect data
   * @return {object} The schema definition object
   */
  static defineSchema() {
    return {
      tags: new ArrayField$6(
        new StringField$8({ required: false, initial: "" })
      )
    };
  }
  /** @override */
  prepareBaseData() {
    super.prepareBaseData();
    if (!this.parent.flags["foundryvtt-final-fantasy"]) {
      this.parent.flags["foundryvtt-final-fantasy"] = {};
    }
    if (!this.parent.flags["foundryvtt-final-fantasy"].stackable) {
      this.parent.flags["foundryvtt-final-fantasy"].stackable = "differentSource";
    }
  }
}
class FFToken extends Token {
  static {
    __name(this, "FFToken");
  }
  /**
   * Whether this token represents an ally
   * @return {boolean} True if the token is an ally
   */
  get isAlly() {
    return this.document.disposition === 1;
  }
  /**
   * Whether this token represents an enemy
   * @return {boolean} True if the token is an enemy
   */
  get isEnemy() {
    return this.document.disposition === -1;
  }
}
class FFCombat extends Combat {
  static {
    __name(this, "FFCombat");
  }
  /**
   * Initialize the combat instance
   * @param {object} data - The combat data
   * @param {object} context - The initialization context
   */
  constructor(data, context) {
    super(data, context);
  }
  /**
   * Returns true if the current turn represents the end of the adventurer step
   * (i.e., if the current turn is the last PC and the next turn is an NPC)
   * @type {boolean}
   */
  get isAdventurerStepEnd() {
    if (!this.started || this.turn === null)
      return false;
    const currentCombatant = this.turns[this.turn];
    const nextCombatant = this.turns[this.turn + 1];
    return currentCombatant?.actor?.type === "PC" && nextCombatant?.actor?.type === "NPC";
  }
  /**
   * Returns true if the current turn represents the end of the enemy step
   * (i.e., if the current turn is the last NPC and the next turn is a PC or the round ends)
   * @type {boolean}
   */
  get isEnemyStepEnd() {
    if (!this.started || this.turn === null)
      return false;
    const currentCombatant = this.turns[this.turn];
    const nextCombatant = this.turns[this.turn + 1];
    return currentCombatant?.actor?.type === "NPC" && (!nextCombatant || nextCombatant?.actor?.type === "PC");
  }
  /**
   * Return the Array of combatants sorted into initiative order
   * @return {Combatant[]} Array of sorted combatants
   */
  setupTurns() {
    this.turns ||= [];
    const turns = this.combatants.contents.sort(this._sortCombatants);
    if (this.turn !== null)
      this.turn = Math.clamp(this.turn, 0, turns.length - 1);
    const currentTurn = turns[this.turn];
    this.current = this._getCurrentState(currentTurn);
    if (!this.previous)
      this.previous = this.current;
    return this.turns = turns;
  }
  /**
   * Define how the array of Combatants is sorted in the displayed list
   * @param {Combatant} a - First combatant to compare
   * @param {Combatant} b - Second combatant to compare
   * @return {number} Sort order modifier
   * @protected
   */
  _sortCombatants(a, b) {
    const aIsNPC = a.actor?.type === "NPC";
    const bIsNPC = b.actor?.type === "NPC";
    if (aIsNPC && !bIsNPC) {
      a.css = "npc-group-start";
      b.css = "pc-group-end";
      return 1;
    } else if (!aIsNPC && bIsNPC) {
      a.css = "pc-group-end";
      b.css = "npc-group-start";
      return -1;
    }
    if (a.initiative === null && b.initiative === null)
      return 0;
    if (a.initiative === null)
      return 1;
    if (b.initiative === null)
      return -1;
    return b.initiative - a.initiative;
  }
}
class FFCombatants extends Combatant {
  static {
    __name(this, "FFCombatants");
  }
  /**
   * Initialize the combatant
   * @param {object} object - The combatant data
   * @param {object} [options={}] - Additional options
   */
  constructor(object, options = {}) {
    super(object, options);
  }
}
class ColourContrastCalculator {
  static {
    __name(this, "ColourContrastCalculator");
  }
  /**
   * Creates a new color contrast calculator
   * @param {string|Color} colour - The color to calculate contrast for
   * @param {object} options - Configuration options
   * @param {string} [options.calculationType="contrast"] - Type of calculation to perform
   * @param {string} [options.outputFormat="hex"] - Format for the output color
   */
  constructor(colour, { calculationType = "contrast", outputFormat = "hex" } = {}) {
    this.colour = colour;
    this.calculationType = calculationType;
    this.outputFormat = outputFormat;
  }
  /**
   * Converts a hex color string or Color object to RGB values
   * @param {string|Color} hex - The hex color string or Color object to convert
   * @return {number[]} Array of RGB values [r, g, b]
   */
  hexToRgb(hex) {
    if (hex instanceof Color) {
      return [
        Math.round(hex.r * 255),
        Math.round(hex.g * 255),
        Math.round(hex.b * 255)
      ];
    }
    if (typeof hex === "string") {
      hex = hex.replace(/^#/, "");
      const bigint = parseInt(hex, 16);
      const r = bigint >> 16 & 255;
      const g = bigint >> 8 & 255;
      const b = bigint & 255;
      return [r, g, b];
    }
    console.warn("Invalid color format provided to hexToRgb:", hex);
    return [0, 0, 0];
  }
  /**
   * Converts RGB values to a hex color string
   * @param {number[]} rgb - Array of RGB values
   * @return {string} Hex color string
   */
  rgbToHex(rgb) {
    return `#${rgb.map((val) => (val < 16 ? "0" : "") + val.toString(16)).join("")}`;
  }
  /**
   * Calculates brightness contrast value for RGB color
   * @param {number[]} rgb - Array of RGB values
   * @return {number} Brightness contrast value between 0 and 1
   */
  brightnessContrast(rgb) {
    return (0.299 * rgb[0] + 0.587 * rgb[1] + 0.114 * rgb[2]) / 255;
  }
  /**
   * Calculates color difference between two RGB colors
   * @param {number[]} rgb1 - First RGB color array
   * @param {number[]} rgb2 - Second RGB color array
   * @return {number} Color difference value
   */
  differenceContrast(rgb1, rgb2) {
    return Math.sqrt(
      Math.pow(rgb1[0] - rgb2[0], 2) + Math.pow(rgb1[1] - rgb2[1], 2) + Math.pow(rgb1[2] - rgb2[2], 2)
    );
  }
  /**
   * Calculates the highest contrast color based on calculation type
   * @return {number[]} RGB values of the highest contrast color
   */
  calculateHighestContrastColour() {
    const inputRgb = this.hexToRgb(this.colour);
    let highestContrastRgb;
    if (this.calculationType === "brightness") {
      highestContrastRgb = this.brightnessContrast(inputRgb) >= 0.5 ? [40, 32, 26] : [255, 255, 255];
    } else if (this.calculationType === "difference") {
      highestContrastRgb = this.differenceContrast(inputRgb, [40, 32, 26]) >= this.differenceContrast(inputRgb, [255, 255, 255]) ? [40, 32, 26] : [255, 255, 255];
    } else if (this.calculationType === "contrast") {
      highestContrastRgb = this.brightnessContrast(inputRgb) >= 0.5 ? [40, 32, 26] : [255, 255, 255];
    } else {
      throw new Error("Invalid calculationType");
    }
    return highestContrastRgb;
  }
  /**
   * Calculates the contrast color with optional alpha
   * @param {number} [alpha=1.0] - Alpha value for RGBA output
   * @return {string} Contrast color in specified output format
   */
  calculateContrast(alpha = 1) {
    const highestContrastRgb = this.calculateHighestContrastColour();
    if (this.outputFormat === "hex") {
      return this.rgbToHex(highestContrastRgb);
    } else if (this.outputFormat === "rgb") {
      return `rgb(${highestContrastRgb[0]}, ${highestContrastRgb[1]}, ${highestContrastRgb[2]})`;
    } else if (this.outputFormat === "rgba") {
      return `rgba(${highestContrastRgb[0]}, ${highestContrastRgb[1]}, ${highestContrastRgb[2]}, ${alpha})`;
    } else {
      throw new Error("Invalid outputFormat");
    }
  }
  /**
   * Get CSS variables for a color including contrast and RGB values
   * @return {object} Object containing CSS-ready color values
   */
  getCSSVariables() {
    const rgbValues = this.hexToRgb(this.colour);
    return {
      color: this.colour instanceof Color ? this.colour.toString() : this.colour,
      contrast: this.calculateContrast(),
      rgb: rgbValues.join(", ")
    };
  }
}
function noop() {
}
__name(noop, "noop");
const identity = /* @__PURE__ */ __name((x) => x, "identity");
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return (
    /** @type {T & S} */
    tar
  );
}
__name(assign, "assign");
function run(fn) {
  return fn();
}
__name(run, "run");
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
__name(blank_object, "blank_object");
function run_all(fns) {
  fns.forEach(run);
}
__name(run_all, "run_all");
function is_function(thing) {
  return typeof thing === "function";
}
__name(is_function, "is_function");
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
__name(safe_not_equal, "safe_not_equal");
let src_url_equal_anchor;
function src_url_equal(element_src, url) {
  if (element_src === url)
    return true;
  if (!src_url_equal_anchor) {
    src_url_equal_anchor = document.createElement("a");
  }
  src_url_equal_anchor.href = url;
  return element_src === src_url_equal_anchor.href;
}
__name(src_url_equal, "src_url_equal");
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
__name(is_empty, "is_empty");
function subscribe(store, ...callbacks) {
  if (store == null) {
    for (const callback of callbacks) {
      callback(void 0);
    }
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
__name(subscribe, "subscribe");
function get_store_value(store) {
  let value;
  subscribe(store, (_) => value = _)();
  return value;
}
__name(get_store_value, "get_store_value");
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
__name(component_subscribe, "component_subscribe");
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
__name(create_slot, "create_slot");
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
__name(get_slot_context, "get_slot_context");
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
__name(get_slot_changes, "get_slot_changes");
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
__name(update_slot_base, "update_slot_base");
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
__name(get_all_dirty_from_scope, "get_all_dirty_from_scope");
function exclude_internal_props(props) {
  const result = {};
  for (const k in props)
    if (k[0] !== "$")
      result[k] = props[k];
  return result;
}
__name(exclude_internal_props, "exclude_internal_props");
function compute_rest_props(props, keys) {
  const rest = {};
  keys = new Set(keys);
  for (const k in props)
    if (!keys.has(k) && k[0] !== "$")
      rest[k] = props[k];
  return rest;
}
__name(compute_rest_props, "compute_rest_props");
function null_to_empty(value) {
  return value == null ? "" : value;
}
__name(null_to_empty, "null_to_empty");
function set_store_value(store, ret, value) {
  store.set(value);
  return ret;
}
__name(set_store_value, "set_store_value");
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}
__name(action_destroyer, "action_destroyer");
const is_client = typeof window !== "undefined";
let now = is_client ? () => window.performance.now() : () => Date.now();
let raf = is_client ? (cb) => requestAnimationFrame(cb) : noop;
const tasks = /* @__PURE__ */ new Set();
function run_tasks(now2) {
  tasks.forEach((task) => {
    if (!task.c(now2)) {
      tasks.delete(task);
      task.f();
    }
  });
  if (tasks.size !== 0)
    raf(run_tasks);
}
__name(run_tasks, "run_tasks");
function loop(callback) {
  let task;
  if (tasks.size === 0)
    raf(run_tasks);
  return {
    promise: new Promise((fulfill) => {
      tasks.add(task = { c: callback, f: fulfill });
    }),
    abort() {
      tasks.delete(task);
    }
  };
}
__name(loop, "loop");
var define_global_default = {};
const globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  define_global_default
);
function append(target, node) {
  target.appendChild(node);
}
__name(append, "append");
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && /** @type {ShadowRoot} */
  root.host) {
    return (
      /** @type {ShadowRoot} */
      root
    );
  }
  return node.ownerDocument;
}
__name(get_root_for_style, "get_root_for_style");
function append_empty_stylesheet(node) {
  const style_element = element("style");
  style_element.textContent = "/* empty */";
  append_stylesheet(get_root_for_style(node), style_element);
  return style_element.sheet;
}
__name(append_empty_stylesheet, "append_empty_stylesheet");
function append_stylesheet(node, style) {
  append(
    /** @type {Document} */
    node.head || node,
    style
  );
  return style.sheet;
}
__name(append_stylesheet, "append_stylesheet");
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
__name(insert, "insert");
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
__name(detach, "detach");
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
__name(destroy_each, "destroy_each");
function element(name) {
  return document.createElement(name);
}
__name(element, "element");
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
__name(svg_element, "svg_element");
function text(data) {
  return document.createTextNode(data);
}
__name(text, "text");
function space() {
  return text(" ");
}
__name(space, "space");
function empty() {
  return text("");
}
__name(empty, "empty");
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
__name(listen, "listen");
function prevent_default(fn) {
  return function(event) {
    event.preventDefault();
    return fn.call(this, event);
  };
}
__name(prevent_default, "prevent_default");
function stop_propagation(fn) {
  return function(event) {
    event.stopPropagation();
    return fn.call(this, event);
  };
}
__name(stop_propagation, "stop_propagation");
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
__name(attr, "attr");
const always_set_through_set_attribute = ["width", "height"];
function set_attributes(node, attributes) {
  const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
  for (const key in attributes) {
    if (attributes[key] == null) {
      node.removeAttribute(key);
    } else if (key === "style") {
      node.style.cssText = attributes[key];
    } else if (key === "__value") {
      node.value = node[key] = attributes[key];
    } else if (descriptors[key] && descriptors[key].set && always_set_through_set_attribute.indexOf(key) === -1) {
      node[key] = attributes[key];
    } else {
      attr(node, key, attributes[key]);
    }
  }
}
__name(set_attributes, "set_attributes");
function set_svg_attributes(node, attributes) {
  for (const key in attributes) {
    attr(node, key, attributes[key]);
  }
}
__name(set_svg_attributes, "set_svg_attributes");
function children(element2) {
  return Array.from(element2.childNodes);
}
__name(children, "children");
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data)
    return;
  text2.data = /** @type {string} */
  data;
}
__name(set_data, "set_data");
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
__name(set_input_value, "set_input_value");
function set_style(node, key, value, important) {
  if (value == null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, "");
  }
}
__name(set_style, "set_style");
function select_option(select, value, mounting) {
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];
    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value !== void 0) {
    select.selectedIndex = -1;
  }
}
__name(select_option, "select_option");
function select_options(select, value) {
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];
    option.selected = ~value.indexOf(option.__value);
  }
}
__name(select_options, "select_options");
function select_value(select) {
  const selected_option = select.querySelector(":checked");
  return selected_option && selected_option.__value;
}
__name(select_value, "select_value");
function toggle_class(element2, name, toggle) {
  element2.classList.toggle(name, !!toggle);
}
__name(toggle_class, "toggle_class");
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  return new CustomEvent(type, { detail, bubbles, cancelable });
}
__name(custom_event, "custom_event");
class HtmlTag {
  static {
    __name(this, "HtmlTag");
  }
  /**
   * @private
   * @default false
   */
  is_svg = false;
  /** parent for creating node */
  e = void 0;
  /** html tag nodes */
  n = void 0;
  /** target */
  t = void 0;
  /** anchor */
  a = void 0;
  constructor(is_svg = false) {
    this.is_svg = is_svg;
    this.e = this.n = null;
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  c(html) {
    this.h(html);
  }
  /**
   * @param {string} html
   * @param {HTMLElement | SVGElement} target
   * @param {HTMLElement | SVGElement} anchor
   * @returns {void}
   */
  m(html, target, anchor = null) {
    if (!this.e) {
      if (this.is_svg)
        this.e = svg_element(
          /** @type {keyof SVGElementTagNameMap} */
          target.nodeName
        );
      else
        this.e = element(
          /** @type {keyof HTMLElementTagNameMap} */
          target.nodeType === 11 ? "TEMPLATE" : target.nodeName
        );
      this.t = target.tagName !== "TEMPLATE" ? target : (
        /** @type {HTMLTemplateElement} */
        target.content
      );
      this.c(html);
    }
    this.i(anchor);
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  h(html) {
    this.e.innerHTML = html;
    this.n = Array.from(
      this.e.nodeName === "TEMPLATE" ? this.e.content.childNodes : this.e.childNodes
    );
  }
  /**
   * @returns {void} */
  i(anchor) {
    for (let i = 0; i < this.n.length; i += 1) {
      insert(this.t, this.n[i], anchor);
    }
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  p(html) {
    this.d();
    this.h(html);
    this.i(this.a);
  }
  /**
   * @returns {void} */
  d() {
    this.n.forEach(detach);
  }
}
function construct_svelte_component(component, props) {
  return new component(props);
}
__name(construct_svelte_component, "construct_svelte_component");
const managed_styles = /* @__PURE__ */ new Map();
let active = 0;
function hash(str) {
  let hash2 = 5381;
  let i = str.length;
  while (i--)
    hash2 = (hash2 << 5) - hash2 ^ str.charCodeAt(i);
  return hash2 >>> 0;
}
__name(hash, "hash");
function create_style_information(doc, node) {
  const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
  managed_styles.set(doc, info);
  return info;
}
__name(create_style_information, "create_style_information");
function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
  const step = 16.666 / duration;
  let keyframes = "{\n";
  for (let p = 0; p <= 1; p += step) {
    const t = a + (b - a) * ease(p);
    keyframes += p * 100 + `%{${fn(t, 1 - t)}}
`;
  }
  const rule = keyframes + `100% {${fn(b, 1 - b)}}
}`;
  const name = `__svelte_${hash(rule)}_${uid}`;
  const doc = get_root_for_style(node);
  const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
  if (!rules[name]) {
    rules[name] = true;
    stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
  }
  const animation = node.style.animation || "";
  node.style.animation = `${animation ? `${animation}, ` : ""}${name} ${duration}ms linear ${delay}ms 1 both`;
  active += 1;
  return name;
}
__name(create_rule, "create_rule");
function delete_rule(node, name) {
  const previous = (node.style.animation || "").split(", ");
  const next = previous.filter(
    name ? (anim) => anim.indexOf(name) < 0 : (anim) => anim.indexOf("__svelte") === -1
    // remove all Svelte animations
  );
  const deleted = previous.length - next.length;
  if (deleted) {
    node.style.animation = next.join(", ");
    active -= deleted;
    if (!active)
      clear_rules();
  }
}
__name(delete_rule, "delete_rule");
function clear_rules() {
  raf(() => {
    if (active)
      return;
    managed_styles.forEach((info) => {
      const { ownerNode } = info.stylesheet;
      if (ownerNode)
        detach(ownerNode);
    });
    managed_styles.clear();
  });
}
__name(clear_rules, "clear_rules");
let current_component;
function set_current_component(component) {
  current_component = component;
}
__name(set_current_component, "set_current_component");
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
__name(get_current_component, "get_current_component");
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
__name(onMount, "onMount");
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
__name(onDestroy, "onDestroy");
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(
        /** @type {string} */
        type,
        detail,
        { cancelable }
      );
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}
__name(createEventDispatcher, "createEventDispatcher");
function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
  return context;
}
__name(setContext, "setContext");
function getContext(key) {
  return get_current_component().$$.context.get(key);
}
__name(getContext, "getContext");
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn) => fn.call(this, event));
  }
}
__name(bubble, "bubble");
const dirty_components = [];
const binding_callbacks = [];
let render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = /* @__PURE__ */ Promise.resolve();
let update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
__name(schedule_update, "schedule_update");
function tick() {
  schedule_update();
  return resolved_promise;
}
__name(tick, "tick");
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
__name(add_render_callback, "add_render_callback");
function add_flush_callback(fn) {
  flush_callbacks.push(fn);
}
__name(add_flush_callback, "add_flush_callback");
const seen_callbacks = /* @__PURE__ */ new Set();
let flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
__name(flush, "flush");
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
__name(update, "update");
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}
__name(flush_render_callbacks, "flush_render_callbacks");
let promise;
function wait() {
  if (!promise) {
    promise = Promise.resolve();
    promise.then(() => {
      promise = null;
    });
  }
  return promise;
}
__name(wait, "wait");
function dispatch(node, direction, kind) {
  node.dispatchEvent(custom_event(`${direction ? "intro" : "outro"}${kind}`));
}
__name(dispatch, "dispatch");
const outroing = /* @__PURE__ */ new Set();
let outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
__name(group_outros, "group_outros");
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
__name(check_outros, "check_outros");
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
__name(transition_in, "transition_in");
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
__name(transition_out, "transition_out");
const null_transition = { duration: 0 };
function create_in_transition(node, fn, params) {
  const options = { direction: "in" };
  let config = fn(node, params, options);
  let running = false;
  let animation_name;
  let task;
  let uid = 0;
  function cleanup() {
    if (animation_name)
      delete_rule(node, animation_name);
  }
  __name(cleanup, "cleanup");
  function go() {
    const {
      delay = 0,
      duration = 300,
      easing = identity,
      tick: tick2 = noop,
      css
    } = config || null_transition;
    if (css)
      animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
    tick2(0, 1);
    const start_time = now() + delay;
    const end_time = start_time + duration;
    if (task)
      task.abort();
    running = true;
    add_render_callback(() => dispatch(node, true, "start"));
    task = loop((now2) => {
      if (running) {
        if (now2 >= end_time) {
          tick2(1, 0);
          dispatch(node, true, "end");
          cleanup();
          return running = false;
        }
        if (now2 >= start_time) {
          const t = easing((now2 - start_time) / duration);
          tick2(t, 1 - t);
        }
      }
      return running;
    });
  }
  __name(go, "go");
  let started = false;
  return {
    start() {
      if (started)
        return;
      started = true;
      delete_rule(node);
      if (is_function(config)) {
        config = config(options);
        wait().then(go);
      } else {
        go();
      }
    },
    invalidate() {
      started = false;
    },
    end() {
      if (running) {
        cleanup();
        running = false;
      }
    }
  };
}
__name(create_in_transition, "create_in_transition");
function create_out_transition(node, fn, params) {
  const options = { direction: "out" };
  let config = fn(node, params, options);
  let running = true;
  let animation_name;
  const group = outros;
  group.r += 1;
  let original_inert_value;
  function go() {
    const {
      delay = 0,
      duration = 300,
      easing = identity,
      tick: tick2 = noop,
      css
    } = config || null_transition;
    if (css)
      animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
    const start_time = now() + delay;
    const end_time = start_time + duration;
    add_render_callback(() => dispatch(node, false, "start"));
    if ("inert" in node) {
      original_inert_value = /** @type {HTMLElement} */
      node.inert;
      node.inert = true;
    }
    loop((now2) => {
      if (running) {
        if (now2 >= end_time) {
          tick2(0, 1);
          dispatch(node, false, "end");
          if (!--group.r) {
            run_all(group.c);
          }
          return false;
        }
        if (now2 >= start_time) {
          const t = easing((now2 - start_time) / duration);
          tick2(1 - t, t);
        }
      }
      return running;
    });
  }
  __name(go, "go");
  if (is_function(config)) {
    wait().then(() => {
      config = config(options);
      go();
    });
  } else {
    go();
  }
  return {
    end(reset) {
      if (reset && "inert" in node) {
        node.inert = original_inert_value;
      }
      if (reset && config.tick) {
        config.tick(1, 0);
      }
      if (running) {
        if (animation_name)
          delete_rule(node, animation_name);
        running = false;
      }
    }
  };
}
__name(create_out_transition, "create_out_transition");
function ensure_array_like(array_like_or_iterator) {
  return array_like_or_iterator?.length !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}
__name(ensure_array_like, "ensure_array_like");
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i = levels.length;
  while (i--) {
    const o = levels[i];
    const n = updates[i];
    if (n) {
      for (const key in o) {
        if (!(key in n))
          to_null_out[key] = 1;
      }
      for (const key in n) {
        if (!accounted_for[key]) {
          update2[key] = n[key];
          accounted_for[key] = 1;
        }
      }
      levels[i] = n;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}
__name(get_spread_update, "get_spread_update");
function get_spread_object(spread_props) {
  return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
}
__name(get_spread_object, "get_spread_object");
function bind(component, name, callback) {
  const index = component.$$.props[name];
  if (index !== void 0) {
    component.$$.bound[index] = callback;
    callback(component.$$.ctx[index]);
  }
}
__name(bind, "bind");
function create_component(block) {
  block && block.c();
}
__name(create_component, "create_component");
function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
__name(mount_component, "mount_component");
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
__name(destroy_component, "destroy_component");
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
__name(make_dirty, "make_dirty");
function init$1(component, options, instance2, create_fragment2, not_equal, props, append_styles = null, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles && append_styles($$.root);
  let ready = false;
  $$.ctx = instance2 ? instance2(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment2 ? create_fragment2($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    flush();
  }
  set_current_component(parent_component);
}
__name(init$1, "init$1");
class SvelteComponent {
  static {
    __name(this, "SvelteComponent");
  }
  /**
   * ### PRIVATE API
   *
   * Do not use, may change at any time
   *
   * @type {any}
   */
  $$ = void 0;
  /**
   * ### PRIVATE API
   *
   * Do not use, may change at any time
   *
   * @type {any}
   */
  $$set = void 0;
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
}
const PUBLIC_VERSION = "4";
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);
class Hashing {
  static {
    __name(this, "Hashing");
  }
  static #regexUuidv = /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i;
  /**
   * @hideconstructor
   */
  constructor() {
    throw new Error("Hashing constructor: This is a static class and should not be constructed.");
  }
  /**
   * Provides a solid string hashing algorithm.
   *
   * Sourced from: https://stackoverflow.com/a/52171480
   *
   * @param {string}   str - String to hash.
   *
   * @param {number}   [seed=0] - A seed value altering the hash.
   *
   * @returns {number} Hash code.
   */
  static hashCode(str, seed = 0) {
    if (typeof str !== "string") {
      return 0;
    }
    let h1 = 3735928559 ^ seed, h2 = 1103547991 ^ seed;
    for (let ch, i = 0; i < str.length; i++) {
      ch = str.charCodeAt(i);
      h1 = Math.imul(h1 ^ ch, 2654435761);
      h2 = Math.imul(h2 ^ ch, 1597334677);
    }
    h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507) ^ Math.imul(h2 ^ h2 >>> 13, 3266489909);
    h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507) ^ Math.imul(h1 ^ h1 >>> 13, 3266489909);
    return 4294967296 * (2097151 & h2) + (h1 >>> 0);
  }
  /**
   * Validates that the given string is formatted as a UUIDv4 string.
   *
   * @param {string}   uuid - UUID string to test.
   *
   * @returns {boolean} Is UUIDv4 string.
   */
  static isUuidv4(uuid) {
    return this.#regexUuidv.test(uuid);
  }
  /**
   * Generates a UUID v4 compliant ID. Please use a complete UUID generation package for guaranteed compliance.
   *
   * This code is an evolution of the following Gist.
   * https://gist.github.com/jed/982883
   *
   * There is a public domain / free copy license attached to it that is not a standard OSS license...
   * https://gist.github.com/jed/982883#file-license-txt
   *
   * @returns {string} UUIDv4
   */
  static uuidv4() {
    return ("10000000-1000-4000-8000" + -1e11).replace(/[018]/g, (c) => (c ^ (globalThis.crypto ?? globalThis.msCrypto).getRandomValues(
      new Uint8Array(1)
    )[0] & 15 >> c / 4).toString(16));
  }
}
class Strings {
  static {
    __name(this, "Strings");
  }
  /**
   * @hideconstructor
   */
  constructor() {
    throw new Error("Strings constructor: This is a static class and should not be constructed.");
  }
  /**
   * Escape a given input string prefacing special characters with backslashes for use in a regular expression.
   *
   * @param {string}   string - An un-escaped input string.
   *
   * @returns {string} The escaped string suitable for use in a regular expression.
   */
  static escape(string) {
    return string.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
  }
  /**
   * Normalizes a string.
   *
   * @param {string}   string - A string to normalize for comparisons.
   *
   * @returns {string} Cleaned string.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize
   */
  static normalize(string) {
    return string.trim().normalize("NFD").replace(/[\x00-\x1F]/gm, "");
  }
}
class Timing {
  static {
    __name(this, "Timing");
  }
  /**
   * @hideconstructor
   */
  constructor() {
    throw new Error("Timing constructor: This is a static class and should not be constructed.");
  }
  /**
   * Wraps a callback in a debounced timeout. Delay execution of the callback function until the function has not been
   * called for the given delay in milliseconds.
   *
   * @template Args
   *
   * @param {(...args: Args[]) => void} callback - A function to execute once the debounced threshold has been passed.
   *
   * @param {number}   delay - An amount of time in milliseconds to delay.
   *
   * @returns {(...args: Args[]) => void} A wrapped function that can be called to debounce execution.
   *
   * @example
   * /**
   *  * Debounce the update invocation by 500ms.
   *  *\/
   * const updateDebounced = Timing.debounce(() => doc.update(), 500);
   *
   * // Use the function like:
   * updateDebounced();
   *
   * @example
   * /**
   *  * Debounce the update invocation by 500ms.
   *  *
   *  * \@param {string} value - A value to update.
   *  *\/
   * const updateDebounced = Timing.debounce((value) => doc.update(value), 500);
   *
   * // Use the function like:
   * updateDebounced('new value');
   */
  static debounce(callback, delay) {
    if (typeof callback !== "function") {
      throw new TypeError(`'callback' must be a function.`);
    }
    if (!Number.isInteger(delay) || delay < 0) {
      throw new TypeError(`'delay' must be a positive integer representing milliseconds.`);
    }
    let timeoutId;
    return function(...args) {
      globalThis.clearTimeout(timeoutId);
      timeoutId = globalThis.setTimeout(() => {
        callback.apply(this, args);
      }, delay);
    };
  }
  /**
   * Creates a double click event handler that distinguishes between single and double clicks. Calls the `single`
   * callback on a single click and the `double` callback on a double click. The default double click delay to invoke
   * the `double` callback is 400 milliseconds.
   *
   * @param {object}   opts - Optional parameters.
   *
   * @param {(event: Event) => void} [opts.single] - Single click callback.
   *
   * @param {(event: Event) => void} [opts.double] - Double click callback.
   *
   * @param {number}   [opts.delay=400] - Double click delay.
   *
   * @returns {(event: Event) => void} The gated double-click handler.
   *
   * @example
   * // Given a button element.
   * button.addEventListener('click', Timing.doubleClick({
   *    single: (event) => console.log('Single click: ', event),
   *    double: (event) => console.log('Double click: ', event)
   * });
   */
  static doubleClick({ single, double, delay = 400 }) {
    if (single !== void 0 && typeof single !== "function") {
      throw new TypeError(`'single' must be a function.`);
    }
    if (double !== void 0 && typeof double !== "function") {
      throw new TypeError(`'double' must be a function.`);
    }
    if (!Number.isInteger(delay) || delay < 0) {
      throw new TypeError(`'delay' must be a positive integer representing milliseconds.`);
    }
    let clicks = 0;
    let timeoutId;
    return (event) => {
      globalThis.clearTimeout(timeoutId);
      clicks++;
      if (clicks === 1) {
        timeoutId = globalThis.setTimeout(() => {
          if (typeof single === "function") {
            single(event);
          }
          clicks = 0;
        }, delay);
      } else {
        if (typeof double === "function") {
          double(event);
        }
        clicks = 0;
      }
    };
  }
}
const s_TAG_OBJECT = "[object Object]";
function deepMerge(target = {}, ...sourceObj) {
  if (Object.prototype.toString.call(target) !== s_TAG_OBJECT) {
    throw new TypeError(`deepMerge error: 'target' is not an 'object'.`);
  }
  for (let cntr = 0; cntr < sourceObj.length; cntr++) {
    if (Object.prototype.toString.call(sourceObj[cntr]) !== s_TAG_OBJECT) {
      throw new TypeError(`deepMerge error: 'sourceObj[${cntr}]' is not an 'object'.`);
    }
  }
  return _deepMerge(target, ...sourceObj);
}
__name(deepMerge, "deepMerge");
function hasGetter(object, accessor) {
  if (typeof object !== "object" || object === null || object === void 0) {
    return false;
  }
  const iDescriptor = Object.getOwnPropertyDescriptor(object, accessor);
  if (iDescriptor !== void 0 && iDescriptor.get !== void 0) {
    return true;
  }
  for (let o = Object.getPrototypeOf(object); o; o = Object.getPrototypeOf(o)) {
    const descriptor = Object.getOwnPropertyDescriptor(o, accessor);
    if (descriptor !== void 0 && descriptor.get !== void 0) {
      return true;
    }
  }
  return false;
}
__name(hasGetter, "hasGetter");
function hasPrototype(target, Prototype) {
  if (typeof target !== "function") {
    return false;
  }
  if (target === Prototype) {
    return true;
  }
  for (let proto = Object.getPrototypeOf(target); proto; proto = Object.getPrototypeOf(proto)) {
    if (proto === Prototype) {
      return true;
    }
  }
  return false;
}
__name(hasPrototype, "hasPrototype");
function isIterable(value) {
  if (value === null || value === void 0 || typeof value !== "object") {
    return false;
  }
  return Symbol.iterator in value;
}
__name(isIterable, "isIterable");
function isObject(value) {
  return value !== null && typeof value === "object" && !Array.isArray(value);
}
__name(isObject, "isObject");
function isPlainObject(value) {
  if (Object.prototype.toString.call(value) !== s_TAG_OBJECT) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return prototype === null || prototype === Object.prototype;
}
__name(isPlainObject, "isPlainObject");
function safeAccess(data, accessor, defaultValue) {
  if (typeof data !== "object") {
    return defaultValue;
  }
  if (typeof accessor !== "string") {
    return defaultValue;
  }
  const access = accessor.split(".");
  for (let cntr = 0; cntr < access.length; cntr++) {
    if (typeof data[access[cntr]] === "undefined" || data[access[cntr]] === null) {
      return defaultValue;
    }
    data = data[access[cntr]];
  }
  return data;
}
__name(safeAccess, "safeAccess");
function safeSet(data, accessor, value, operation = "set", createMissing = true) {
  if (typeof data !== "object") {
    throw new TypeError(`safeSet error: 'data' is not an 'object'.`);
  }
  if (typeof accessor !== "string") {
    throw new TypeError(`safeSet error: 'accessor' is not a 'string'.`);
  }
  const access = accessor.split(".");
  for (let cntr = 0; cntr < access.length; cntr++) {
    if (Array.isArray(data)) {
      const number = +access[cntr];
      if (!Number.isInteger(number) || number < 0) {
        return false;
      }
    }
    if (cntr === access.length - 1) {
      switch (operation) {
        case "add":
          data[access[cntr]] += value;
          break;
        case "div":
          data[access[cntr]] /= value;
          break;
        case "mult":
          data[access[cntr]] *= value;
          break;
        case "set":
          data[access[cntr]] = value;
          break;
        case "set-undefined":
          if (typeof data[access[cntr]] === "undefined") {
            data[access[cntr]] = value;
          }
          break;
        case "sub":
          data[access[cntr]] -= value;
          break;
      }
    } else {
      if (createMissing && typeof data[access[cntr]] === "undefined") {
        data[access[cntr]] = {};
      }
      if (data[access[cntr]] === null || typeof data[access[cntr]] !== "object") {
        return false;
      }
      data = data[access[cntr]];
    }
  }
  return true;
}
__name(safeSet, "safeSet");
function _deepMerge(target = {}, ...sourceObj) {
  for (let cntr = 0; cntr < sourceObj.length; cntr++) {
    const obj = sourceObj[cntr];
    for (const prop in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, prop)) {
        if (prop.startsWith("-=")) {
          delete target[prop.slice(2)];
          continue;
        }
        target[prop] = Object.prototype.hasOwnProperty.call(target, prop) && target[prop]?.constructor === Object && obj[prop]?.constructor === Object ? _deepMerge({}, target[prop], obj[prop]) : obj[prop];
      }
    }
  }
  return target;
}
__name(_deepMerge, "_deepMerge");
const subscriber_queue = [];
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
__name(readable, "readable");
function writable(value, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  __name(set, "set");
  function update2(fn) {
    set(fn(value));
  }
  __name(update2, "update");
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set, update2) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  __name(subscribe2, "subscribe");
  return { set, update: update2, subscribe: subscribe2 };
}
__name(writable, "writable");
function derived(stores, fn, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  if (!stores_array.every(Boolean)) {
    throw new Error("derived() expects stores as input, got a falsy value");
  }
  const auto = fn.length < 2;
  return readable(initial_value, (set, update2) => {
    let started = false;
    const values = [];
    let pending = 0;
    let cleanup = noop;
    const sync = /* @__PURE__ */ __name(() => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn(single ? values[0] : values, set, update2);
      if (auto) {
        set(result);
      } else {
        cleanup = is_function(result) ? result : noop;
      }
    }, "sync");
    const unsubscribers = stores_array.map(
      (store, i) => subscribe(
        store,
        (value) => {
          values[i] = value;
          pending &= ~(1 << i);
          if (started) {
            sync();
          }
        },
        () => {
          pending |= 1 << i;
        }
      )
    );
    started = true;
    sync();
    return /* @__PURE__ */ __name(function stop() {
      run_all(unsubscribers);
      cleanup();
      started = false;
    }, "stop");
  });
}
__name(derived, "derived");
function isMinimalWritableStore(store) {
  if (store === null || store === void 0) {
    return false;
  }
  switch (typeof store) {
    case "function":
    case "object":
      return typeof store.subscribe === "function" && typeof store.set === "function";
  }
  return false;
}
__name(isMinimalWritableStore, "isMinimalWritableStore");
function isWritableStore(store) {
  if (store === null || store === void 0) {
    return false;
  }
  switch (typeof store) {
    case "function":
    case "object":
      return typeof store.subscribe === "function" && typeof store.set === "function" && typeof store.update === "function";
  }
  return false;
}
__name(isWritableStore, "isWritableStore");
function subscribeIgnoreFirst(store, update2) {
  let firedFirst = false;
  return store.subscribe((value) => {
    if (!firedFirst) {
      firedFirst = true;
    } else {
      update2(value);
    }
  });
}
__name(subscribeIgnoreFirst, "subscribeIgnoreFirst");
class DynReducerUtils {
  static {
    __name(this, "DynReducerUtils");
  }
  /**
   * Checks for array equality between two arrays of numbers.
   *
   * @param a - Array A
   *
   * @param b - Array B
   *
   * @returns Arrays are equal.
   */
  static arrayEquals(a, b) {
    if (a === b) {
      return true;
    }
    if (a === null || b === null) {
      return false;
    }
    if (a.length !== b.length) {
      return false;
    }
    for (let cntr = a.length; --cntr >= 0; ) {
      if (a[cntr] !== b[cntr]) {
        return false;
      }
    }
    return true;
  }
  /**
   * Provides a solid string hashing algorithm.
   *
   * Sourced from: https://stackoverflow.com/a/52171480
   *
   * @param str - String to hash.
   *
   * @param seed - A seed value altering the hash.
   *
   * @returns Hash code.
   */
  static hashString(str, seed = 0) {
    let h1 = 3735928559 ^ seed, h2 = 1103547991 ^ seed;
    for (let ch, i = 0; i < str.length; i++) {
      ch = str.charCodeAt(i);
      h1 = Math.imul(h1 ^ ch, 2654435761);
      h2 = Math.imul(h2 ^ ch, 1597334677);
    }
    h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507) ^ Math.imul(h2 ^ h2 >>> 13, 3266489909);
    h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507) ^ Math.imul(h1 ^ h1 >>> 13, 3266489909);
    return 4294967296 * (2097151 & h2) + (h1 >>> 0);
  }
  /**
   * Converts an unknown value for hashing purposes in {@link AdapterIndexer.calcHashUpdate}.
   *
   * Currently objects / Map w/ object keys is not supported. Potentially can include `object-hash` to handle this
   * case, but it is not common to use objects as keys in Maps.
   *
   * @param value - An unknown value to convert to a number.
   */
  static hashUnknown(value) {
    if (value === null || value === void 0) {
      return 0;
    }
    let result = 0;
    switch (typeof value) {
      case "boolean":
        result = value ? 1 : 0;
        break;
      case "bigint":
        result = Number(BigInt.asIntN(64, value));
        break;
      case "function":
        result = this.hashString(value.name);
        break;
      case "number":
        result = Number.isFinite(value) ? value : 0;
        break;
      case "object":
        break;
      case "string":
        result = this.hashString(value);
        break;
      case "symbol":
        result = this.hashString(Symbol.keyFor(value));
        break;
    }
    return result;
  }
  /**
   * @param target -
   *
   * @param Prototype -
   *
   * @returns target constructor function has Prototype.
   */
  static hasPrototype(target, Prototype) {
    if (typeof target !== "function") {
      return false;
    }
    if (target === Prototype) {
      return true;
    }
    for (let proto = Object.getPrototypeOf(target); proto; proto = Object.getPrototypeOf(proto)) {
      if (proto === Prototype) {
        return true;
      }
    }
    return false;
  }
  /**
   * Provides a utility method to determine if the given data is iterable / implements iterator protocol.
   *
   * @param data - Data to verify as iterable.
   *
   * @returns Is data iterable.
   */
  static isIterable(data) {
    return data !== null && data !== void 0 && typeof data === "object" && typeof data[Symbol.iterator] === "function";
  }
}
class AdapterDerived {
  static {
    __name(this, "AdapterDerived");
  }
  #hostData;
  #DerivedReducerCtor;
  #parentIndex;
  #derived = /* @__PURE__ */ new Map();
  #destroyed = false;
  /**
   * @param {DynDataHost<D>} hostData - Hosted data structure.
   *
   * @param {IndexerAPI<K, T>}  parentIndex - Any associated parent index API.
   *
   * @param {DynDerivedReducerCtor<T>} DerivedReducerCtor - The default derived reducer constructor function.
   */
  constructor(hostData, parentIndex, DerivedReducerCtor) {
    this.#hostData = hostData;
    this.#parentIndex = parentIndex;
    this.#DerivedReducerCtor = DerivedReducerCtor;
    Object.freeze(this);
  }
  /**
   * Creates a new derived reducer.
   *
   * @param {DynOptionsDerivedCreate<T>} options - Options defining the new derived reducer.
   *
   * @returns {DynDerivedReducer<D, K, T>} Newly created derived reducer.
   */
  create(options) {
    if (this.#destroyed) {
      throw Error(`AdapterDerived.create error: this instance has been destroyed.`);
    }
    let name;
    let rest = {};
    let ctor;
    const DerivedReducerCtor = this.#DerivedReducerCtor;
    if (typeof options === "string") {
      name = options;
      ctor = DerivedReducerCtor;
    } else if (typeof options === "function" && DynReducerUtils.hasPrototype(options, DerivedReducerCtor)) {
      ctor = options;
    } else if (typeof options === "object" && options !== null) {
      ({ name, ctor = DerivedReducerCtor, ...rest } = options);
    } else {
      throw new TypeError(`AdapterDerived.create error: 'options' does not conform to allowed parameters.`);
    }
    if (!DynReducerUtils.hasPrototype(ctor, DerivedReducerCtor)) {
      throw new TypeError(`AdapterDerived.create error: 'ctor' is not a '${DerivedReducerCtor?.name}'.`);
    }
    name = name ?? ctor?.name;
    if (typeof name !== "string") {
      throw new TypeError(`AdapterDerived.create error: 'name' is not a string.`);
    }
    const derivedReducer = new ctor(this.#hostData, this.#parentIndex, rest);
    this.#derived.set(name, derivedReducer);
    return derivedReducer;
  }
  /**
   * Removes all derived reducers and associated subscriptions.
   */
  clear() {
    if (this.#destroyed) {
      return;
    }
    for (const reducer of this.#derived.values()) {
      reducer.destroy();
    }
    this.#derived.clear();
  }
  /**
   * Deletes and destroys a derived reducer by name.
   *
   * @param {string}   name - Name of the derived reducer.
   *
   * @returns {boolean} true if an element in the Map existed and has been removed, or false if the element does not
   *          exist.
   */
  delete(name) {
    if (this.#destroyed) {
      throw Error(`AdapterDerived.delete error: this instance has been destroyed.`);
    }
    const reducer = this.#derived.get(name);
    if (reducer) {
      reducer.destroy();
    }
    return this.#derived.delete(name);
  }
  /**
   * Removes all derived reducers, subscriptions, and cleans up all resources.
   */
  destroy() {
    if (this.#destroyed) {
      return;
    }
    this.clear();
    this.#hostData = [null];
    this.#parentIndex = null;
    this.#destroyed = true;
  }
  /**
   * Returns an existing derived reducer.
   *
   * @param {string}   name - Name of derived reducer.
   *
   * @returns {DynDerivedReducer<D, K, T>} Any associated derived reducer.
   */
  get(name) {
    if (this.#destroyed) {
      throw Error(`AdapterDerived.get error: this instance has been destroyed.`);
    }
    return this.#derived.get(name);
  }
  /**
   * Updates all managed derived reducer indexes.
   *
   * @param {boolean}  [force=false] - Force an update to subscribers.
   */
  update(force = false) {
    if (this.#destroyed) {
      return;
    }
    for (const reducer of this.#derived.values()) {
      reducer.index.update(force);
    }
  }
}
class AdapterFilters {
  static {
    __name(this, "AdapterFilters");
  }
  #filtersData;
  #indexUpdate;
  #mapUnsubscribe = /* @__PURE__ */ new Map();
  constructor(indexUpdate, filtersAdapter) {
    this.#indexUpdate = indexUpdate;
    this.#filtersData = filtersAdapter;
    Object.freeze(this);
  }
  get length() {
    return this.#filtersData.filters.length;
  }
  *[Symbol.iterator]() {
    if (this.#filtersData.filters.length === 0) {
      return;
    }
    for (const entry of this.#filtersData.filters) {
      yield { ...entry };
    }
  }
  add(...filters) {
    let subscribeCount = 0;
    for (const filter of filters) {
      const filterType = typeof filter;
      if (filterType !== "function" && (filterType !== "object" || filter === null)) {
        throw new TypeError(`AdapterFilters error: 'filter' is not a function or object.`);
      }
      let data = void 0;
      let subscribeFn = void 0;
      if (filterType === "function") {
        data = {
          id: void 0,
          filter,
          weight: 1
        };
        subscribeFn = filter.subscribe;
      } else if (filterType === "object") {
        if ("filter" in filter) {
          if (typeof filter.filter !== "function") {
            throw new TypeError(`AdapterFilters error: 'filter' attribute is not a function.`);
          }
          if (filter.weight !== void 0 && typeof filter.weight !== "number" || (filter.weight < 0 || filter.weight > 1)) {
            throw new TypeError(`AdapterFilters error: 'weight' attribute is not a number between '0 - 1' inclusive.`);
          }
          data = {
            id: filter.id !== void 0 ? filter.id : void 0,
            filter: filter.filter,
            weight: filter.weight || 1
          };
          subscribeFn = filter.filter.subscribe ?? filter.subscribe;
        } else {
          throw new TypeError(`AdapterFilters error: 'filter' attribute is not a function.`);
        }
      }
      const index = this.#filtersData.filters.findIndex((value) => {
        return data.weight < value.weight;
      });
      if (index >= 0) {
        this.#filtersData.filters.splice(index, 0, data);
      } else {
        this.#filtersData.filters.push(data);
      }
      if (typeof subscribeFn === "function") {
        const unsubscribe = subscribeFn(this.#indexUpdate);
        if (typeof unsubscribe !== "function") {
          throw new TypeError("AdapterFilters error: Filter has subscribe function, but no unsubscribe function is returned.");
        }
        if (this.#mapUnsubscribe.has(data.filter)) {
          throw new Error("AdapterFilters error: Filter added already has an unsubscribe function registered.");
        }
        this.#mapUnsubscribe.set(data.filter, unsubscribe);
        subscribeCount++;
      }
    }
    if (subscribeCount < filters.length) {
      this.#indexUpdate(true);
    }
  }
  clear() {
    this.#filtersData.filters.length = 0;
    for (const unsubscribe of this.#mapUnsubscribe.values()) {
      unsubscribe();
    }
    this.#mapUnsubscribe.clear();
    this.#indexUpdate();
  }
  remove(...filters) {
    const length = this.#filtersData.filters.length;
    if (length === 0) {
      return;
    }
    for (const data of filters) {
      const actualFilter = typeof data === "function" ? data : data !== null && typeof data === "object" ? data.filter : void 0;
      if (!actualFilter) {
        continue;
      }
      for (let cntr = this.#filtersData.filters.length; --cntr >= 0; ) {
        if (this.#filtersData.filters[cntr].filter === actualFilter) {
          this.#filtersData.filters.splice(cntr, 1);
          let unsubscribe = void 0;
          if (typeof (unsubscribe = this.#mapUnsubscribe.get(actualFilter)) === "function") {
            unsubscribe();
            this.#mapUnsubscribe.delete(actualFilter);
          }
        }
      }
    }
    if (length !== this.#filtersData.filters.length) {
      this.#indexUpdate(true);
    }
  }
  removeBy(callback) {
    const length = this.#filtersData.filters.length;
    if (length === 0) {
      return;
    }
    if (typeof callback !== "function") {
      throw new TypeError(`AdapterFilters error: 'callback' is not a function.`);
    }
    this.#filtersData.filters = this.#filtersData.filters.filter((data) => {
      const remove = callback.call(callback, { ...data });
      if (remove) {
        let unsubscribe;
        if (typeof (unsubscribe = this.#mapUnsubscribe.get(data.filter)) === "function") {
          unsubscribe();
          this.#mapUnsubscribe.delete(data.filter);
        }
      }
      return !remove;
    });
    if (length !== this.#filtersData.filters.length) {
      this.#indexUpdate(true);
    }
  }
  removeById(...ids) {
    const length = this.#filtersData.filters.length;
    if (length === 0) {
      return;
    }
    this.#filtersData.filters = this.#filtersData.filters.filter((data) => {
      let remove = 0;
      for (const id of ids) {
        remove |= data.id === id ? 1 : 0;
      }
      if (!!remove) {
        let unsubscribe;
        if (typeof (unsubscribe = this.#mapUnsubscribe.get(data.filter)) === "function") {
          unsubscribe();
          this.#mapUnsubscribe.delete(data.filter);
        }
      }
      return !remove;
    });
    if (length !== this.#filtersData.filters.length) {
      this.#indexUpdate(true);
    }
  }
}
class AdapterIndexer {
  static {
    __name(this, "AdapterIndexer");
  }
  derivedAdapter;
  filtersData;
  hostData;
  hostUpdate;
  indexData;
  sortData;
  sortFn;
  destroyed = false;
  /**
   * @param {DynDataHost<D>}       hostData - Hosted data structure.
   *
   * @param {Function}             hostUpdate - Host update function invoked on index updates.
   *
   * @param {DynIndexerAPI<K, T>} [parentIndexer] - Any associated parent index API.
   *
   * @returns Indexer adapter instance.
   */
  constructor(hostData, hostUpdate, parentIndexer) {
    this.hostData = hostData;
    this.hostUpdate = hostUpdate;
    this.indexData = { index: null, hash: null, reversed: false, parent: parentIndexer };
  }
  /**
   * @returns Returns whether the index is active.
   */
  get active() {
    return this.filtersData.filters.length > 0 || this.sortData.compareFn !== null || this.indexData.parent?.active === true;
  }
  /**
   * @returns Returns length of reduced index.
   */
  get length() {
    return this.indexData.index ? this.indexData.index.length : 0;
  }
  /* c8 ignore start */
  /**
   * @returns Returns reversed state.
   */
  get reversed() {
    return this.indexData.reversed;
  }
  /* c8 ignore end */
  /**
   * @param reversed - New reversed state.
   */
  set reversed(reversed) {
    this.indexData.reversed = reversed;
  }
  // -------------------------------------------------------------------------------------------------------------------
  /**
   * Calculates a new hash value for the new index array if any. If the new index array is null then the hash value
   * is set to null. Set calculated new hash value to the index adapter hash value.
   *
   * After hash generation compare old and new hash values and perform an update if they are different. If they are
   * equal check for array equality between the old and new index array and perform an update if they are not equal.
   *
   * @param oldIndex - Old index array.
   *
   * @param oldHash - Old index hash value.
   *
   * @param [force=false] - When true forces an update to subscribers.
   */
  calcHashUpdate(oldIndex, oldHash, force = false) {
    const actualForce = typeof force === "boolean" ? force : (
      /* c8 ignore next */
      false
    );
    let newHash = null;
    const newIndex = this.indexData.index;
    if (newIndex) {
      for (let cntr = newIndex.length; --cntr >= 0; ) {
        newHash ^= DynReducerUtils.hashUnknown(newIndex[cntr]) + 2654435769 + (newHash << 6) + (newHash >> 2);
      }
    }
    this.indexData.hash = newHash;
    if (actualForce || (oldHash === newHash ? !DynReducerUtils.arrayEquals(oldIndex, newIndex) : true)) {
      this.hostUpdate();
    }
  }
  /**
   * Destroys all resources.
   */
  destroy() {
    if (this.destroyed) {
      return;
    }
    this.indexData.index = null;
    this.indexData.hash = null;
    this.indexData.reversed = null;
    this.indexData.parent = null;
    this.destroyed = true;
  }
  /**
   * Store associated filter and sort data that are constructed after the indexer.
   *
   * @param filtersData - Associated AdapterFilters instance.
   *
   * @param sortData - Associated AdapterSort instance.
   *
   * @param derivedAdapter - Associated AdapterDerived instance.
   */
  initAdapters(filtersData, sortData, derivedAdapter) {
    this.filtersData = filtersData;
    this.sortData = sortData;
    this.derivedAdapter = derivedAdapter;
    this.sortFn = this.createSortFn();
  }
}
class AdapterSort {
  static {
    __name(this, "AdapterSort");
  }
  #sortData;
  #indexUpdate;
  #unsubscribe;
  constructor(indexUpdate, sortData) {
    this.#indexUpdate = indexUpdate;
    this.#sortData = sortData;
    Object.freeze(this);
  }
  clear() {
    const oldCompareFn = this.#sortData.compareFn;
    this.#sortData.compareFn = null;
    if (typeof this.#unsubscribe === "function") {
      this.#unsubscribe();
      this.#unsubscribe = void 0;
    }
    if (typeof oldCompareFn === "function") {
      this.#indexUpdate(true);
    }
  }
  set(sort) {
    if (typeof this.#unsubscribe === "function") {
      this.#unsubscribe();
      this.#unsubscribe = void 0;
    }
    let compareFn = void 0;
    let subscribeFn = void 0;
    switch (typeof sort) {
      case "function":
        compareFn = sort;
        subscribeFn = sort.subscribe;
        break;
      case "object":
        if (sort === null) {
          break;
        }
        if (typeof sort.compare !== "function") {
          throw new TypeError(`AdapterSort error: 'compare' attribute is not a function.`);
        }
        compareFn = sort.compare;
        subscribeFn = sort.compare.subscribe ?? sort.subscribe;
        break;
    }
    if (typeof compareFn === "function") {
      this.#sortData.compareFn = compareFn;
    } else {
      const oldCompareFn = this.#sortData.compareFn;
      this.#sortData.compareFn = null;
      if (typeof oldCompareFn === "function") {
        this.#indexUpdate();
      }
      return;
    }
    if (typeof subscribeFn === "function") {
      this.#unsubscribe = subscribeFn(this.#indexUpdate);
      if (typeof this.#unsubscribe !== "function") {
        throw new Error(`AdapterSort error: sort has 'subscribe' function, but no 'unsubscribe' function is returned.`);
      }
    } else {
      this.#indexUpdate(true);
    }
  }
}
class IndexerAPI {
  static {
    __name(this, "IndexerAPI");
  }
  #indexData;
  /**
   * Provides a getter to determine if the index is active.
   */
  active;
  /**
   * Provides length of reduced / indexed elements.
   */
  length;
  /**
   * Manually invoke an update of the index.
   *
   * @param force - Force update to any subscribers.
   */
  update;
  constructor(adapterIndexer) {
    this.#indexData = adapterIndexer.indexData;
    this.update = adapterIndexer.update.bind(adapterIndexer);
    Object.defineProperties(this, {
      active: { get: () => adapterIndexer.active },
      length: { get: () => adapterIndexer.length }
    });
    Object.freeze(this);
  }
  get hash() {
    return this.#indexData.hash;
  }
  *[Symbol.iterator]() {
    const indexData = this.#indexData;
    if (!indexData.index) {
      return;
    }
    const reversed = indexData.reversed;
    const length = indexData.index.length;
    if (reversed) {
      for (let cntr = length; --cntr >= 0; ) {
        yield indexData.index[cntr];
      }
    } else {
      for (let cntr = 0; cntr < length; cntr++) {
        yield indexData.index[cntr];
      }
    }
  }
}
class DerivedAPI {
  static {
    __name(this, "DerivedAPI");
  }
  clear;
  create;
  delete;
  destroy;
  get;
  constructor(adapterDerived) {
    this.clear = adapterDerived.clear.bind(adapterDerived);
    this.create = adapterDerived.create.bind(adapterDerived);
    this.delete = adapterDerived.delete.bind(adapterDerived);
    this.destroy = adapterDerived.destroy.bind(adapterDerived);
    this.get = adapterDerived.get.bind(adapterDerived);
    Object.freeze(this);
  }
}
class MapIndexer extends AdapterIndexer {
  static {
    __name(this, "MapIndexer");
  }
  /**
   * @inheritDoc
   */
  createSortFn() {
    return (a, b) => this.sortData.compareFn(this.hostData[0].get(a), this.hostData[0].get(b));
  }
  /**
   * Provides the custom filter / reduce step that is ~25-40% faster than implementing with `Array.reduce`.
   *
   * Note: Other loop unrolling techniques like Duff's Device gave a slight faster lower bound on large data sets,
   * but the maintenance factor is not worth the extra complication.
   *
   * @returns {K[]} New filtered index array.
   */
  reduceImpl() {
    const data = [];
    const map = this.hostData[0];
    if (!map) {
      return data;
    }
    const filters = this.filtersData.filters;
    let include = true;
    const parentIndex = this.indexData.parent;
    if (DynReducerUtils.isIterable(parentIndex) && parentIndex.active) {
      for (const key of parentIndex) {
        const value = map.get(key);
        include = true;
        for (let filCntr = 0, filLength = filters.length; filCntr < filLength; filCntr++) {
          if (!filters[filCntr].filter(value)) {
            include = false;
            break;
          }
        }
        if (include) {
          data.push(key);
        }
      }
    } else {
      for (const key of map.keys()) {
        include = true;
        const value = map.get(key);
        for (let filCntr = 0, filLength = filters.length; filCntr < filLength; filCntr++) {
          if (!filters[filCntr].filter(value)) {
            include = false;
            break;
          }
        }
        if (include) {
          data.push(key);
        }
      }
    }
    return data;
  }
  /**
   * Update the reducer indexes. If there are changes subscribers are notified. If data order is changed externally
   * pass in true to force an update to subscribers.
   *
   * @param {boolean}  [force=false] - When true forces an update to subscribers.
   */
  update(force = false) {
    if (this.destroyed) {
      return;
    }
    const oldIndex = this.indexData.index;
    const oldHash = this.indexData.hash;
    const map = this.hostData[0];
    const parentIndex = this.indexData.parent;
    if (this.filtersData.filters.length === 0 && !this.sortData.compareFn || this.indexData.index && map?.size !== this.indexData.index.length) {
      this.indexData.index = null;
    }
    if (this.filtersData.filters.length > 0) {
      this.indexData.index = this.reduceImpl();
    }
    if (!this.indexData.index && parentIndex?.active) {
      this.indexData.index = [...parentIndex];
    }
    if (this.sortData.compareFn && map instanceof Map) {
      if (!this.indexData.index) {
        this.indexData.index = this.indexData.index = [...map.keys()];
      }
      this.indexData.index.sort(this.sortFn);
    }
    this.calcHashUpdate(oldIndex, oldHash, force);
    this.derivedAdapter?.update(force);
  }
}
class DynMapReducerDerived {
  static {
    __name(this, "DynMapReducerDerived");
  }
  #map;
  #derived;
  #derivedPublicAPI;
  #filters;
  #filtersData = { filters: [] };
  #index;
  #indexPublicAPI;
  #reversed = false;
  #sort;
  #sortData = { compareFn: null };
  #subscriptions = [];
  #destroyed = false;
  /**
   * @param {DynDataHost<Map<K, T>>}  map - Data host Map.
   *
   * @param {DynIndexerAPI<K, T>}    parentIndex - Parent indexer.
   *
   * @param {DynDataOptions<T>}       options - Any filters and sort functions to apply.
   */
  constructor(map, parentIndex, options) {
    this.#map = map;
    this.#index = new MapIndexer(this.#map, this.#updateSubscribers.bind(this), parentIndex);
    this.#indexPublicAPI = new IndexerAPI(this.#index);
    this.#filters = new AdapterFilters(this.#indexPublicAPI.update, this.#filtersData);
    this.#sort = new AdapterSort(this.#indexPublicAPI.update, this.#sortData);
    this.#derived = new AdapterDerived(this.#map, this.#indexPublicAPI, DynMapReducerDerived);
    this.#derivedPublicAPI = new DerivedAPI(this.#derived);
    this.#index.initAdapters(this.#filtersData, this.#sortData, this.#derived);
    const { filters, sort, ...optionsRest } = options;
    if (filters !== void 0) {
      if (!DynReducerUtils.isIterable(filters)) {
        throw new TypeError(`DerivedMapReducer error (DataDerivedOptions): 'filters' attribute is not iterable.`);
      }
      this.filters.add(...filters);
    }
    if (sort !== void 0) {
      if (typeof sort !== "function" && (typeof sort !== "object" || sort === null)) {
        throw new TypeError(`DerivedMapReducer error (DataDerivedOptions): 'sort' attribute is not a function or object.`);
      }
      this.sort.set(sort);
    }
    this.initialize(optionsRest);
  }
  /**
   * Returns the internal data of this instance. Be careful!
   *
   * Note: The returned map is the same map set by the main reducer. If any changes are performed to the data
   * externally do invoke {@link DynIndexerAPI.update} with `true` to recalculate the index and notify all
   * subscribers.
   *
   * @returns The internal data.
   */
  get data() {
    return this.#map[0];
  }
  /**
   * @returns Derived public API.
   */
  get derived() {
    return this.#derivedPublicAPI;
  }
  /**
   * @returns The filters adapter.
   */
  get filters() {
    return this.#filters;
  }
  /**
   * Returns the Indexer public API.
   *
   * @returns Indexer API - is also iterable.
   */
  get index() {
    return this.#indexPublicAPI;
  }
  /**
   * Returns whether this derived reducer is destroyed.
   */
  get destroyed() {
    return this.#destroyed;
  }
  /**
   * @returns Main data / items length or indexed length.
   */
  get length() {
    const map = this.#map[0];
    return this.#index.active ? this.index.length : map ? map.size : 0;
  }
  /**
   * @returns Gets current reversed state.
   */
  get reversed() {
    return this.#reversed;
  }
  /**
   * @returns The sort adapter.
   */
  get sort() {
    return this.#sort;
  }
  /**
   * Sets reversed state and notifies subscribers.
   *
   * @param reversed - New reversed state.
   */
  set reversed(reversed) {
    if (typeof reversed !== "boolean") {
      throw new TypeError(`DerivedMapReducer.reversed error: 'reversed' is not a boolean.`);
    }
    this.#reversed = reversed;
    this.#index.reversed = reversed;
    this.index.update(true);
  }
  /**
   * Removes all derived reducers, subscriptions, and cleans up all resources.
   */
  destroy() {
    this.#destroyed = true;
    this.#map = [null];
    this.#index.update(true);
    this.#subscriptions.length = 0;
    this.#derived.destroy();
    this.#index.destroy();
    this.#filters.clear();
    this.#sort.clear();
  }
  /**
   * Provides a callback for custom derived reducers to initialize any data / custom configuration. This allows
   * child classes to avoid implementing the constructor.
   *
   * @param [optionsRest] - Any additional custom options passed beyond {@link DynDataOptions}.
   *
   * @protected
   */
  initialize(optionsRest) {
  }
  /**
   * Provides an iterator for data stored in DerivedMapReducer.
   *
   * @returns {IterableIterator<T>}
   * @yields {T}
   */
  *[Symbol.iterator]() {
    const map = this.#map[0];
    if (this.#destroyed || map === null || map?.size === 0) {
      return;
    }
    if (this.#index.active) {
      for (const key of this.index) {
        yield map.get(key);
      }
    } else {
      if (this.reversed) {
        const values = [...map.values()];
        for (let cntr = values.length; --cntr >= 0; ) {
          yield values[cntr];
        }
      } else {
        for (const value of map.values()) {
          yield value;
        }
      }
    }
  }
  // -------------------------------------------------------------------------------------------------------------------
  /**
   * Subscribe to this DerivedMapReducer.
   *
   * @param handler - Callback function that is invoked on update / changes. Receives `this` reference.
   *
   * @returns Unsubscribe function.
   */
  subscribe(handler) {
    this.#subscriptions.push(handler);
    handler(this);
    return () => {
      const index = this.#subscriptions.findIndex((sub) => sub === handler);
      if (index >= 0) {
        this.#subscriptions.splice(index, 1);
      }
    };
  }
  /**
   * Updates subscribers on changes.
   */
  #updateSubscribers() {
    for (let cntr = 0; cntr < this.#subscriptions.length; cntr++) {
      this.#subscriptions[cntr](this);
    }
  }
}
class DynMapReducer {
  static {
    __name(this, "DynMapReducer");
  }
  #map = [null];
  #derived;
  #derivedPublicAPI;
  #filters;
  #filtersData = { filters: [] };
  #index;
  #indexPublicAPI;
  #reversed = false;
  #sort;
  #sortData = { compareFn: null };
  #subscriptions = [];
  #destroyed = false;
  /**
   * Initializes DynMapReducer. Any iterable is supported for initial data. Take note that if `data` is an array it
   * will be used as the host array and not copied. All non-array iterables otherwise create a new array / copy.
   *
   * @param {Map<K, T> | DynMapData<K, T>} [data] - Data iterable to store if array or copy otherwise.
   */
  constructor(data) {
    let dataMap = void 0;
    let filters = void 0;
    let sort = void 0;
    if (data === null) {
      throw new TypeError(`DynMapReducer error: 'data' is not an object or Map.`);
    }
    if (data !== void 0 && typeof data !== "object" && !(data instanceof Map)) {
      throw new TypeError(`DynMapReducer error: 'data' is not an object or Map.`);
    }
    if (data !== void 0 && data instanceof Map) {
      dataMap = data;
    } else if (data !== void 0 && ("data" in data || "filters" in data || "sort" in data)) {
      if (data.data !== void 0 && !(data.data instanceof Map)) {
        throw new TypeError(`DynMapReducer error (DataDynMap): 'data' attribute is not a Map.`);
      }
      dataMap = data.data;
      if (data.filters !== void 0) {
        if (DynReducerUtils.isIterable(data.filters)) {
          filters = data.filters;
        } else {
          throw new TypeError(`DynMapReducer error (DataDynMap): 'filters' attribute is not iterable.`);
        }
      }
      if (data.sort !== void 0) {
        if (typeof data.sort === "function") {
          sort = data.sort;
        } else if (typeof data.sort === "object" && data.sort !== null) {
          sort = data.sort;
        } else {
          throw new TypeError(`DynMapReducer error (DataDynMap): 'sort' attribute is not a function or object.`);
        }
      }
    }
    if (dataMap) {
      this.#map[0] = dataMap;
    }
    this.#index = new MapIndexer(this.#map, this.#updateSubscribers.bind(this));
    this.#indexPublicAPI = new IndexerAPI(this.#index);
    this.#filters = new AdapterFilters(this.#indexPublicAPI.update, this.#filtersData);
    this.#sort = new AdapterSort(this.#indexPublicAPI.update, this.#sortData);
    this.#derived = new AdapterDerived(this.#map, this.#indexPublicAPI, DynMapReducerDerived);
    this.#derivedPublicAPI = new DerivedAPI(this.#derived);
    this.#index.initAdapters(this.#filtersData, this.#sortData, this.#derived);
    if (filters) {
      this.filters.add(...filters);
    }
    if (sort) {
      this.sort.set(sort);
    }
    this.initialize();
  }
  /**
   * Returns the internal data of this instance. Be careful!
   *
   * Note: When a map is set as data then that map is used as the internal data. If any changes are performed to the
   * data externally do invoke `update` via {@link DynMapReducer.index} with `true` to recalculate the  index and
   * notify all subscribers.
   *
   * @returns {Map<K, T> | null} The internal data.
   */
  get data() {
    return this.#map[0];
  }
  /**
   * @returns {DynDerivedAPI<Map<K, T>, K, T>} Derived public API.
   */
  get derived() {
    return this.#derivedPublicAPI;
  }
  /**
   * @returns {DynAdapterFilters<T>} The filters adapter.
   */
  get filters() {
    return this.#filters;
  }
  /**
   * @returns {DynIndexerAPI<K, T>} Returns the Indexer public API.
   */
  get index() {
    return this.#indexPublicAPI;
  }
  /**
   * @returns {boolean} Returns whether this instance is destroyed.
   */
  get destroyed() {
    return this.#destroyed;
  }
  /**
   * Gets the main data / items length.
   *
   * @returns {number} Main data / items length.
   */
  get length() {
    const map = this.#map[0];
    return this.#index.active ? this.#indexPublicAPI.length : map ? map.size : 0;
  }
  /**
   * Gets current reversed state.
   *
   * @returns {boolean} Reversed state.
   */
  get reversed() {
    return this.#reversed;
  }
  /**
   * @returns {DynAdapterSort<T>} The sort adapter.
   */
  get sort() {
    return this.#sort;
  }
  /**
   * Sets reversed state and notifies subscribers.
   *
   * @param {boolean} reversed - New reversed state.
   */
  set reversed(reversed) {
    if (typeof reversed !== "boolean") {
      throw new TypeError(`DynMapReducer.reversed error: 'reversed' is not a boolean.`);
    }
    this.#reversed = reversed;
    this.#index.reversed = reversed;
    this.index.update(true);
  }
  /**
   * Removes all derived reducers, subscriptions, and cleans up all resources.
   */
  destroy() {
    if (this.#destroyed) {
      return;
    }
    this.#destroyed = true;
    this.#derived.destroy();
    this.#map = [null];
    this.index.update(true);
    this.#subscriptions.length = 0;
    this.#index.destroy();
    this.#filters.clear();
    this.#sort.clear();
  }
  /**
   * Provides a callback for custom reducers to initialize any data / custom configuration. This allows
   * child classes to avoid implementing the constructor.
   *
   * @protected
   */
  initialize() {
  }
  /**
   * Removes internal data and pushes new data. This does not destroy any initial array set to internal data unless
   * `replace` is set to true.
   *
   * @param {Map<K, T> | null}  data - New data to set to internal data.
   *
   * @param {boolean} [replace=false] - New data to set to internal data.
   */
  setData(data, replace = false) {
    if (data !== null && !(data instanceof Map)) {
      throw new TypeError(`DynMapReducer.setData error: 'data' is not iterable.`);
    }
    if (typeof replace !== "boolean") {
      throw new TypeError(`DynMapReducer.setData error: 'replace' is not a boolean.`);
    }
    const map = this.#map[0];
    if (!(map instanceof Map) || replace) {
      this.#map[0] = data instanceof Map ? data : null;
    } else if (data instanceof Map && map instanceof Map) {
      const removeKeySet = new Set(map.keys());
      for (const key of data.keys()) {
        map.set(key, data.get(key));
        if (removeKeySet.has(key)) {
          removeKeySet.delete(key);
        }
      }
      for (const key of removeKeySet) {
        map.delete(key);
      }
    } else if (data === null) {
      this.#map[0] = null;
    }
    this.index.update(true);
  }
  /**
   * Add a subscriber to this DynMapReducer instance.
   *
   * @param {(value: DynMapReducer<K, T>) => void} handler - Callback function that is invoked on update / changes.
   *        Receives `this` reference.
   *
   * @returns {() => void} Unsubscribe function.
   */
  subscribe(handler) {
    this.#subscriptions.push(handler);
    handler(this);
    return () => {
      const index = this.#subscriptions.findIndex((sub) => sub === handler);
      if (index >= 0) {
        this.#subscriptions.splice(index, 1);
      }
    };
  }
  /**
   * Updates subscribers on changes.
   */
  #updateSubscribers() {
    for (let cntr = 0; cntr < this.#subscriptions.length; cntr++) {
      this.#subscriptions[cntr](this);
    }
  }
  /**
   * Provides an iterator for data stored in DynMapReducer.
   *
   * @returns {IterableIterator<T>}
   * @yields {T}
   */
  *[Symbol.iterator]() {
    const map = this.#map[0];
    if (this.#destroyed || map === null || map?.size === 0) {
      return;
    }
    if (this.#index.active) {
      for (const key of this.index) {
        yield map.get(key);
      }
    } else {
      if (this.reversed) {
        const values = [...map.values()];
        for (let cntr = values.length; --cntr >= 0; ) {
          yield values[cntr];
        }
      } else {
        for (const value of map.values()) {
          yield value;
        }
      }
    }
  }
}
class EmbeddedStoreManager {
  static {
    __name(this, "EmbeddedStoreManager");
  }
  /**
   * RegExp for detecting CRUD updates for renderContext.
   *
   * @type {RegExp}
   */
  static #renderContextRegex = /(?<action>create|delete|update)(?<sep>\.?)(?<name>\w+)/;
  /**
   * @type {Map<string, EmbeddedCollectionData<any>>}
   */
  #name = /* @__PURE__ */ new Map();
  /**
   * @type {foundry.abstract.Document[]}
   */
  #document;
  /**
   * @type {Map<string, string>}
   */
  #collectionToDocName = /* @__PURE__ */ new Map();
  /**
   * @type {Set<string>}
   */
  #embeddedNames = /* @__PURE__ */ new Set();
  /**
   * @param {foundry.abstract.Document[]} document - The associated document holder.
   */
  constructor(document2) {
    this.#document = document2;
    this.handleDocChange();
    Object.seal(this);
  }
  /**
   * @template [T=import('./types').NamedDocumentConstructor]
   *
   * @param {T} FoundryDoc - A Foundry document class / constructor.
   *
   * @param {import('#runtime/svelte/store/reducer').DynOptionsMapCreate<string, T>} options - DynMapReducer
   *        creation options.
   *
   * @returns {import('#runtime/svelte/store/reducer').DynMapReducer<string, T>} DynMapReducer instance.
   */
  create(FoundryDoc, options) {
    const docName = FoundryDoc?.documentName;
    if (typeof docName !== "string") {
      throw new TypeError(
        `EmbeddedStoreManager.create error: 'FoundryDoc' does not have a valid 'documentName' property.`
      );
    }
    const doc = this.#document[0];
    let collection = null;
    if (doc) {
      try {
        collection = doc.getEmbeddedCollection(docName);
      } catch (err) {
        console.warn(`EmbeddedStoreManager.create error: No valid embedded collection for: ${docName}`);
      }
    }
    let embeddedData;
    if (!this.#name.has(docName)) {
      embeddedData = {
        collection,
        stores: /* @__PURE__ */ new Map()
      };
      this.#name.set(docName, embeddedData);
    } else {
      embeddedData = this.#name.get(docName);
    }
    let name;
    let rest = {};
    let ctor;
    if (typeof options === "string") {
      name = options;
      ctor = DynMapReducer;
    } else if (typeof options === "function" && hasPrototype(options, DynMapReducer)) {
      ctor = options;
    } else if (isObject(options)) {
      ({ name, ctor = DynMapReducer, ...rest } = options);
    } else {
      throw new TypeError(`EmbeddedStoreManager.create error: 'options' does not conform to allowed parameters.`);
    }
    if (!hasPrototype(ctor, DynMapReducer)) {
      throw new TypeError(`EmbeddedStoreManager.create error: 'ctor' is not a 'DynMapReducer'.`);
    }
    name = name ?? ctor?.name;
    if (typeof name !== "string") {
      throw new TypeError(`EmbeddedStoreManager.create error: 'name' is not a string.`);
    }
    if (embeddedData.stores.has(name)) {
      return embeddedData.stores.get(name);
    } else {
      const storeOptions = collection ? { data: collection, ...rest } : { ...rest };
      const store = new ctor(storeOptions);
      embeddedData.stores.set(name, store);
      return store;
    }
  }
  /**
   * @template [T=import('./types').NamedDocumentConstructor]
   *
   * Destroys and removes embedded collection stores. Invoking this method with no parameters destroys all stores.
   * Invoking with an embedded name destroys all stores for that particular collection. If you provide an embedded and
   * store name just that particular store is destroyed and removed.
   *
   * @param {T}   [FoundryDoc] - A Foundry document class / constructor.
   *
   * @param {string}   [storeName] - Specific store name.
   *
   * @returns {boolean} One or more stores destroyed?
   */
  destroy(FoundryDoc, storeName) {
    let count = 0;
    if (FoundryDoc === void 0) {
      for (const embeddedData of this.#name.values()) {
        embeddedData.collection = null;
        for (const store of embeddedData.stores.values()) {
          store.destroy();
          count++;
        }
      }
      this.#name.clear();
    } else {
      const docName = FoundryDoc?.documentName;
      if (typeof docName !== "string") {
        throw new TypeError(
          `EmbeddedStoreManager.delete error: 'FoundryDoc' does not have a valid 'documentName' property.`
        );
      }
      if (storeName === void 0) {
        const embeddedData = this.#name.get(docName);
        if (embeddedData) {
          embeddedData.collection = null;
          for (const store of embeddedData.stores.values()) {
            store.destroy();
            count++;
          }
        }
        this.#name.delete(docName);
      } else if (storeName === "string") {
        const embeddedData = this.#name.get(docName);
        if (embeddedData) {
          const store = embeddedData.stores.get(storeName);
          if (store) {
            store.destroy();
            count++;
          }
        }
      }
    }
    return count > 0;
  }
  /**
   * @template [T=import('./types').NamedDocumentConstructor]
   *
   * @param {T} FoundryDoc - A Foundry document class / constructor.
   *
   * @param {string} storeName - Name of the embedded collection to retrieve.
   *
   * @returns {import('#runtime/svelte/store/reducer').DynMapReducer<string, InstanceType<T>>} DynMapReducer
   *          instance.
   */
  get(FoundryDoc, storeName) {
    const docName = FoundryDoc?.documentName;
    if (typeof docName !== "string") {
      throw new TypeError(
        `EmbeddedStoreManager.get error: 'FoundryDoc' does not have a valid 'documentName' property.`
      );
    }
    if (!this.#name.has(docName)) {
      return void 0;
    }
    return this.#name.get(docName).stores.get(storeName);
  }
  /**
   * Updates all existing embedded collection stores with the associated embedded collection
   */
  handleDocChange() {
    const doc = this.#document[0];
    if (doc instanceof globalThis.foundry.abstract.Document) {
      const existingEmbeddedNames = new Set(this.#name.keys());
      const embeddedNames = Object.entries(doc.constructor?.metadata?.embedded ?? []);
      this.#collectionToDocName.clear();
      this.#embeddedNames.clear();
      for (const [docName, collectionName] of embeddedNames) {
        existingEmbeddedNames.delete(docName);
        this.#embeddedNames.add(`create${docName}`);
        this.#embeddedNames.add(`delete${docName}`);
        this.#embeddedNames.add(`update${docName}`);
        this.#embeddedNames.add(`create.${collectionName}`);
        this.#embeddedNames.add(`delete.${collectionName}`);
        this.#embeddedNames.add(`update.${collectionName}`);
        this.#embeddedNames.add(`create${collectionName}`);
        this.#embeddedNames.add(`delete${collectionName}`);
        this.#embeddedNames.add(`update${collectionName}`);
        this.#collectionToDocName.set(docName, docName);
        this.#collectionToDocName.set(collectionName, docName);
        let collection = null;
        try {
          collection = doc.getEmbeddedCollection(docName);
        } catch (err) {
          console.warn(`EmbeddedStoreManager.handleDocUpdate error: No valid embedded collection for: ${docName}`);
        }
        const embeddedData = this.#name.get(docName);
        if (embeddedData) {
          embeddedData.collection = collection;
          for (const store of embeddedData.stores.values()) {
            store.setData(collection, true);
          }
        }
      }
      for (const embeddedName of existingEmbeddedNames) {
        const embeddedData = this.#name.get(embeddedName);
        if (embeddedData) {
          embeddedData.collection = null;
          for (const store of embeddedData.stores.values()) {
            store.setData(null, true);
          }
        }
      }
    } else {
      this.#collectionToDocName.clear();
      this.#embeddedNames.clear();
      for (const embeddedData of this.#name.values()) {
        embeddedData.collection = null;
        for (const store of embeddedData.stores.values()) {
          store.setData(null, true);
        }
      }
    }
  }
  /**
   * Handles updates to embedded stores parsing the render context for valid embedded store types.
   *
   * On create, delete, update parse the type being modified then force index updates for the embedded type.
   *
   * @param {string}   renderContext - render context update from document.
   */
  handleUpdate(renderContext) {
    if (!this.#embeddedNames.has(renderContext)) {
      return;
    }
    const match = EmbeddedStoreManager.#renderContextRegex.exec(renderContext);
    if (match) {
      const docOrCollectionName = match.groups.name;
      const embeddedName = this.#collectionToDocName.get(docOrCollectionName);
      if (!this.#name.has(embeddedName)) {
        return;
      }
      for (const store of this.#name.get(embeddedName).stores.values()) {
        store.index.update(true);
      }
    }
  }
}
class TJSDocument {
  static {
    __name(this, "TJSDocument");
  }
  /**
   * Fake Application API that ClientDocumentMixin uses for document model callbacks.
   *
   * @type {{ close: Function, render: Function }}
   */
  #callbackAPI;
  /**
   * @type {T[]}
   */
  #document = [void 0];
  /**
   * @type {EmbeddedStoreManager}
   */
  #embeddedStoreManager;
  /**
   * @type {import('./types').EmbeddedAPI}
   */
  #embeddedAPI;
  /**
   * @type {string}
   */
  #uuidv4;
  /**
   * @type {{ delete?: Function, preDelete?: Function }}
   */
  #options = { delete: void 0, preDelete: void 0 };
  /**
   * @type {((value: T, updateOptions?: TJSDocumentUpdateOptions) => void)[]}
   */
  #subscriptions = [];
  /**
   * @type {TJSDocumentUpdateOptions}
   */
  #updateOptions;
  /**
   * @param {T | TJSDocumentOptions}  [document] - Document to wrap or TJSDocumentOptions.
   *
   * @param {TJSDocumentOptions}      [options] - TJSDocument options.
   */
  constructor(document2, options = {}) {
    this.#uuidv4 = `tjs-document-${Hashing.uuidv4()}`;
    this.#callbackAPI = {
      close: this.#deleted.bind(this),
      render: this.#updateSubscribers.bind(this)
    };
    if (isPlainObject(document2)) {
      this.setOptions(document2);
    } else {
      this.setOptions(options);
      this.set(document2);
    }
  }
  /**
   * @returns {import('./types').EmbeddedAPI} Embedded store manager.
   */
  get embedded() {
    if (!this.#embeddedAPI) {
      this.#embeddedStoreManager = new EmbeddedStoreManager(this.#document);
      this.#embeddedAPI = {
        create: (doc, options) => this.#embeddedStoreManager.create(doc, options),
        destroy: (doc, storeName) => this.#embeddedStoreManager.destroy(doc, storeName),
        get: (doc, storeName) => this.#embeddedStoreManager.get(doc, storeName)
      };
    }
    return this.#embeddedAPI;
  }
  /**
   * Returns the options passed on last update.
   *
   * @returns {TJSDocumentUpdateOptions} Last update options.
   */
  get updateOptions() {
    return this.#updateOptions ?? {};
  }
  /**
   * Returns the UUID assigned to this store.
   *
   * @returns {string} UUID
   */
  get uuidv4() {
    return this.#uuidv4;
  }
  /**
   * Register the callback API with the underlying Foundry document.
   */
  #callbackRegister() {
    const doc = this.#document[0];
    if (doc instanceof globalThis.foundry.abstract.Document && isObject(doc?.apps) && !doc.apps[this.#uuidv4]) {
      doc.apps[this.#uuidv4] = this.#callbackAPI;
    }
  }
  /**
   * Unregister the callback API with the underlying Foundry document.
   */
  #callbackUnregister() {
    const doc = this.#document[0];
    if (doc instanceof globalThis.foundry.abstract.Document) {
      delete doc?.apps?.[this.#uuidv4];
    }
  }
  /**
   * Handles cleanup when the document is deleted. Invoking any optional delete function set in the constructor.
   *
   * @returns {Promise<void>}
   */
  async #deleted() {
    const doc = this.#document[0];
    if (doc instanceof globalThis.foundry.abstract.Document && !doc?.collection?.has(doc.id)) {
      this.#setDocument(void 0);
      if (typeof this.#options.preDelete === "function") {
        await this.#options.preDelete(doc);
      }
      this.#updateSubscribers(false, { action: "delete", data: void 0 });
      if (typeof this.#options.delete === "function") {
        await this.#options.delete(doc);
      }
      await tick();
      this.#updateOptions = void 0;
    }
  }
  /**
   * Completely removes all internal subscribers, any optional delete callback, and unregisters from the
   * ClientDocumentMixin `apps` tracking object.
   */
  destroy() {
    if (this.#embeddedStoreManager) {
      this.#embeddedStoreManager.destroy();
      this.#embeddedStoreManager = void 0;
      this.#embeddedAPI = void 0;
    }
    this.#setDocument(void 0);
    this.#options.delete = void 0;
    this.#options.preDelete = void 0;
    this.#subscriptions.length = 0;
  }
  /**
   * @returns {T} Current document
   */
  get() {
    return this.#document[0];
  }
  /**
   * Attempts to create a Foundry UUID from standard drop data. This may not work for all systems.
   *
   * @param {object}   data - Drop transfer data.
   *
   * @param {object}   [opts] - Optional parameters.
   *
   * @param {boolean}  [opts.compendium=true] - Accept compendium documents.
   *
   * @param {boolean}  [opts.world=true] - Accept world documents.
   *
   * @param {string[]} [opts.types] - Require the `data.type` to match entry in `types`.
   *
   * @returns {string|undefined} Foundry UUID for drop data.
   */
  static getUUIDFromDataTransfer(data, { compendium = true, world = true, types = void 0 } = {}) {
    if (!isObject(data)) {
      return void 0;
    }
    if (Array.isArray(types) && !types.includes(data.type)) {
      return void 0;
    }
    let uuid = void 0;
    if (typeof data.uuid === "string") {
      const isCompendium = data.uuid.startsWith("Compendium");
      if (isCompendium && compendium) {
        uuid = data.uuid;
      } else if (world) {
        uuid = data.uuid;
      }
    }
    return uuid;
  }
  /**
   * @param {T | undefined}  document - New document to set.
   *
   * @param {TJSDocumentUpdateOptions}   [options] - New document update options to set.
   */
  set(document2, options = {}) {
    if (document2 !== void 0 && !(document2 instanceof globalThis.foundry.abstract.Document)) {
      throw new TypeError(`TJSDocument set error: 'document' is not a valid Document or undefined.`);
    }
    if (!isObject(options)) {
      throw new TypeError(`TJSDocument set error: 'options' is not an object.`);
    }
    if (this.#setDocument(document2)) {
      if (document2 instanceof globalThis.foundry.abstract.Document && this.#subscriptions.length) {
        this.#callbackRegister();
      }
      this.#updateSubscribers(false, { action: `tjs-set-${document2 === void 0 ? "undefined" : "new"}`, ...options });
    }
  }
  /**
   * Internally sets the new document being tracked.
   *
   * @param {T | undefined} doc -
   *
   * @returns {boolean} Whether the document changed.
   */
  #setDocument(doc) {
    const changed = doc !== this.#document[0];
    if (changed) {
      this.#callbackUnregister();
    }
    this.#document[0] = doc;
    if (changed && this.#embeddedStoreManager) {
      this.#embeddedStoreManager.handleDocChange();
    }
    return changed;
  }
  /**
   * Potentially sets new document from data transfer object.
   *
   * @param {object}   data - Document transfer data.
   *
   * @param {{ compendium?: boolean, world?: boolean, types?: string[] }}   [options] - Optional parameters for
   *        {@link TJSDocument.getUUIDFromDataTransfer}.
   *
   * @returns {Promise<boolean>} Returns true if new document set from data transfer blob.
   */
  async setFromDataTransfer(data, options) {
    return this.setFromUUID(TJSDocument.getUUIDFromDataTransfer(data, options));
  }
  /**
   * Sets the document by Foundry UUID performing a lookup and setting the document if found.
   *
   * @param {string}   uuid - A Foundry UUID to lookup.
   *
   * @param {TJSDocumentUpdateOptions}   [options] - New document update options to set.
   *
   * @returns {Promise<boolean>} True if successfully set document from UUID.
   */
  async setFromUUID(uuid, options = {}) {
    if (typeof uuid !== "string" || uuid.length === 0) {
      return false;
    }
    try {
      const doc = await globalThis.fromUuid(uuid);
      if (doc) {
        this.set(doc, options);
        return true;
      }
    } catch (err) {
    }
    return false;
  }
  /**
   * Sets options for this document wrapper / store.
   *
   * @param {TJSDocumentOptions}   options - Options for TJSDocument.
   */
  setOptions(options) {
    if (!isObject(options)) {
      throw new TypeError(`TJSDocument error: 'options' is not a plain object.`);
    }
    if (options.delete !== void 0 && options.delete !== null && typeof options.delete !== "function") {
      throw new TypeError(`TJSDocument error: 'delete' attribute in options is not a function or null.`);
    }
    if (options.preDelete !== void 0 && options.preDelete !== null && typeof options.preDelete !== "function") {
      throw new TypeError(`TJSDocument error: 'preDelete' attribute in options is not a function or null.`);
    }
    if (options.delete !== void 0) {
      this.#options.delete = typeof options.delete === "function" ? options.delete : void 0;
    }
    if (options.preDelete !== void 0) {
      this.#options.preDelete = typeof options.preDelete === "function" ? options.preDelete : void 0;
    }
  }
  /**
   * @param {(value: T, updateOptions?: TJSDocumentUpdateOptions) => void} handler - Callback function that is
   * invoked on update / changes.
   *
   * @returns {import('svelte/store').Unsubscriber} Unsubscribe function.
   */
  subscribe(handler) {
    this.#subscriptions.push(handler);
    if (this.#subscriptions.length === 1) {
      this.#callbackRegister();
    }
    const updateOptions = { action: "subscribe", data: void 0 };
    handler(this.#document[0], updateOptions);
    return () => {
      const index = this.#subscriptions.findIndex((sub) => sub === handler);
      if (index >= 0) {
        this.#subscriptions.splice(index, 1);
      }
      if (this.#subscriptions.length === 0) {
        this.#callbackUnregister();
      }
    };
  }
  /**
   * @param {boolean}  [force] - unused - signature from Foundry render function.
   *
   * @param {TJSDocumentUpdateOptions}   [options] - Options from render call; will have document update context.
   */
  #updateSubscribers(force = false, options = {}) {
    this.#updateOptions = options;
    const doc = this.#document[0];
    for (let cntr = 0; cntr < this.#subscriptions.length; cntr++) {
      this.#subscriptions[cntr](doc, options);
    }
    if (this.#embeddedStoreManager) {
      this.#embeddedStoreManager.handleUpdate(options.renderContext);
    }
  }
}
const log$1 = {
  ASSERT: 1,
  ERROR: 2,
  WARN: 3,
  INFO: 4,
  DEBUG: 5,
  VERBOSE: 6,
  set level(level) {
    this.a = level >= this.ASSERT ? console.assert.bind(window.console, LOG_PREFIX) : () => {
    };
    this.e = level >= this.ERROR ? console.error.bind(window.console, LOG_PREFIX) : () => {
    };
    this.w = level >= this.WARN ? console.warn.bind(window.console, LOG_PREFIX) : () => {
    };
    this.i = level >= this.INFO ? console.info.bind(window.console, LOG_PREFIX) : () => {
    };
    this.d = level >= this.DEBUG ? console.debug.bind(window.console, LOG_PREFIX) : () => {
    };
    this.v = level >= this.VERBOSE ? console.log.bind(window.console, LOG_PREFIX) : () => {
    };
    this.p = level >= this.VERBOSE ? console.log.bind(window.console, LOG_PREFIX_COLOR, LOG_STYLES.p) : () => {
    };
    this.g = level >= this.VERBOSE ? console.log.bind(window.console, LOG_PREFIX_COLOR, LOG_STYLES.g) : () => {
    };
    this.r = level >= this.VERBOSE ? console.log.bind(window.console, LOG_PREFIX_COLOR, LOG_STYLES.r) : () => {
    };
    this.o = level >= this.VERBOSE ? console.log.bind(window.console, LOG_PREFIX_COLOR, LOG_STYLES.o) : () => {
    };
    this.b = level >= this.VERBOSE ? console.log.bind(window.console, LOG_PREFIX_COLOR, LOG_STYLES.b) : () => {
    };
    this.y = level >= this.VERBOSE ? console.log.bind(window.console, LOG_PREFIX_COLOR, LOG_STYLES.y) : () => {
    };
    this.c = level >= this.VERBOSE ? console.log.bind(window.console, LOG_PREFIX_COLOR, LOG_STYLES.c) : () => {
    };
    this.m = level >= this.VERBOSE ? console.log.bind(window.console, LOG_PREFIX_COLOR, LOG_STYLES.m) : () => {
    };
    this.gr = level >= this.VERBOSE ? console.log.bind(window.console, LOG_PREFIX_COLOR, LOG_STYLES.gr) : () => {
    };
    this.br = level >= this.VERBOSE ? console.log.bind(window.console, LOG_PREFIX_COLOR, LOG_STYLES.br) : () => {
    };
    this.pi = level >= this.VERBOSE ? console.log.bind(window.console, LOG_PREFIX_COLOR, LOG_STYLES.pi) : () => {
    };
    this.t = level >= this.VERBOSE ? console.log.bind(window.console, LOG_PREFIX_COLOR, LOG_STYLES.t) : () => {
    };
    this.purple = this.p;
    this.green = this.g;
    this.red = this.r;
    this.orange = this.o;
    this.blue = this.b;
    this.yellow = this.y;
    this.cyan = this.c;
    this.magenta = this.m;
    this.gray = this.gr;
    this.brown = this.br;
    this.pink = this.pi;
    this.teal = this.t;
    this.loggingLevel = level;
  },
  get level() {
    return this.loggingLevel;
  }
};
async function toggleBookmark(item, callback = () => {
}) {
  await item.update({ system: { favourite: !item.system.favourite } });
  callback();
}
__name(toggleBookmark, "toggleBookmark");
function getEffectOrigin(effect, tryFromUuidSync = false) {
  if (!game.actors)
    return null;
  const origin = effect._source.origin;
  if (!origin)
    return null;
  const split = origin.split(".");
  let item = void 0;
  if (split.length == 4) {
    item = effect.parent.items.get(split[3]);
  } else {
    try {
      item = game.actors?.get(origin) || game.items?.get(origin) || game.packs?.get("effects");
      if (!item && tryFromUuidSync) {
        item = fromUuidSync(origin);
      }
    } catch (error) {
      console.warn("getEffectOrigin", effect, origin);
      throw error;
    }
  }
  return item;
}
__name(getEffectOrigin, "getEffectOrigin");
function localize$1(string) {
  if (typeof game === "undefined")
    return string;
  return game.i18n.localize(`${SYSTEM_CODE}.${string}`);
}
__name(localize$1, "localize$1");
function isParentActor(item) {
  return item?.parent?.constructor?.name === "FFXIVActor";
}
__name(isParentActor, "isParentActor");
function ucfirst(str) {
  if (!str)
    return str;
  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
}
__name(ucfirst, "ucfirst");
function generateRandomElementId(length = 8) {
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  let result = "";
  for (let i = 0; i < length; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return result;
}
__name(generateRandomElementId, "generateRandomElementId");
function getActorOwner(actor) {
  const owners = getOwners(actor);
  if (owners.length === 0) {
    return game.user;
  }
  if (owners.length === 1) {
    return owners[0];
  }
  const owner = owners.reduce((owner2, currentOwner) => {
    if (!currentOwner.isGM) {
      return currentOwner;
    }
    return owner2;
  }, null);
  if (!owner) {
    if (game.user.isGM) {
      return game.user;
    }
  }
  if (!owner) {
    return game.users.find((u) => u.isGM);
  }
  return owner;
}
__name(getActorOwner, "getActorOwner");
function getOwners(actor) {
  return game.users.filter((u) => actor.testUserPermission(u, CONST.DOCUMENT_OWNERSHIP_LEVELS.OWNER));
}
__name(getOwners, "getOwners");
const mappedGameTargets = writable(false);
function formatDotpath(path) {
  return path.replace(/\[/g, ".").replace(/]/g, "");
}
__name(formatDotpath, "formatDotpath");
function stepwiseResolveDotpath(obj, path) {
  const pathlets = formatDotpath(path).split(".");
  const result = [
    {
      pathlet: null,
      val: obj
    }
  ];
  for (const pathlet of pathlets) {
    obj = obj?.[pathlet];
    result.push({
      pathlet,
      val: obj
    });
  }
  return result;
}
__name(stepwiseResolveDotpath, "stepwiseResolveDotpath");
function resolveDotpath(obj, path, default_ = void 0, opts = null) {
  const evaluated = stepwiseResolveDotpath(obj, path);
  let item;
  if (opts?.shorten_by) {
    item = evaluated[evaluated.length - 1 - opts.shorten_by];
  } else {
    item = evaluated[evaluated.length - 1];
  }
  return item.val === void 0 ? default_ : item.val;
}
__name(resolveDotpath, "resolveDotpath");
function create_if_block$w(ctx) {
  let div;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<i class="fas fa-xmark"></i>`;
      attr(div, "class", "remove right svelte-1y0mhim");
      attr(div, "aria-label", "Remove tag");
      attr(div, "role", "button");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (!mounted) {
        dispose = listen(
          div,
          "click",
          /*click_handler*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block$w, "create_if_block$w");
function create_fragment$1k(ctx) {
  let div1;
  let div0;
  let t;
  let if_block = (
    /*remover*/
    ctx[1] && create_if_block$w(ctx)
  );
  let div1_levels = [
    { class: "badge center" },
    /*$$restProps*/
    ctx[4]
  ];
  let div_data_1 = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div_data_1 = assign(div_data_1, div1_levels[i]);
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t = text(
        /*tag*/
        ctx[0]
      );
      if (if_block)
        if_block.c();
      attr(div0, "class", "label");
      set_attributes(div1, div_data_1);
      toggle_class(div1, "svelte-1y0mhim", true);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, t);
      if (if_block)
        if_block.m(div1, null);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*tag*/
      1)
        set_data(
          t,
          /*tag*/
          ctx2[0]
        );
      if (
        /*remover*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$w(ctx2);
          if_block.c();
          if_block.m(div1, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [
        { class: "badge center" },
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4]
      ]));
      toggle_class(div1, "svelte-1y0mhim", true);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (if_block)
        if_block.d();
    }
  };
}
__name(create_fragment$1k, "create_fragment$1k");
function instance$1d($$self, $$props, $$invalidate) {
  const omit_props_names = ["tag", "remover", "path"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $doc;
  let { tag = "" } = $$props;
  let { remover = true } = $$props;
  let { path = "system.tags" } = $$props;
  const doc = getContext("#doc");
  component_subscribe($$self, doc, (value) => $$invalidate(7, $doc = value));
  async function removeTag(tag2) {
    if (remover) {
      if (path.startsWith("flags.")) {
        const flagPath = path.slice(6);
        const [moduleId, ...rest] = flagPath.split(".");
        const currentTags = $doc.getFlag(moduleId, rest.join(".")) || [];
        const tags = currentTags.filter((t) => t !== tag2);
        await $doc.setFlag(moduleId, rest.join("."), tags);
      } else if (path.startsWith("system.")) {
        const currentTags = $doc.system.tags || [];
        const tags = currentTags.filter((t) => t !== tag2);
        await $doc.update({ system: { tags } });
      } else {
        const currentTags = resolveDotpath($doc, path);
        game.system.log.g("currentTags", currentTags);
        const type = Array.isArray(currentTags) ? "array" : currentTags instanceof Set ? "set" : "object";
        game.system.log.g("type", type);
        let tags;
        if (type === "array") {
          tags = currentTags.filter((t) => t !== tag2);
          await $doc.update({ [path]: tags });
        } else if (type === "set") {
          tags = new Set([...currentTags].filter((t) => t !== tag2));
          game.system.log.g("tags", tags);
          await $doc.update({ [path]: tags });
        } else {
          game.system.log.g("currentTags NOT IMPLEMENTED", currentTags);
        }
      }
    }
  }
  __name(removeTag, "removeTag");
  const click_handler2 = /* @__PURE__ */ __name(() => removeTag(tag), "click_handler");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("tag" in $$new_props)
      $$invalidate(0, tag = $$new_props.tag);
    if ("remover" in $$new_props)
      $$invalidate(1, remover = $$new_props.remover);
    if ("path" in $$new_props)
      $$invalidate(5, path = $$new_props.path);
  };
  return [tag, remover, doc, removeTag, $$restProps, path, click_handler2];
}
__name(instance$1d, "instance$1d");
class Tag extends SvelteComponent {
  static {
    __name(this, "Tag");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$1d, create_fragment$1k, safe_not_equal, { tag: 0, remover: 1, path: 5 });
  }
}
function get_each_context$j(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i];
  return child_ctx;
}
__name(get_each_context$j, "get_each_context$j");
function create_if_block_4$7(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "loading...";
      attr(div, "class", "title flex1 svelte-n656zp");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
__name(create_if_block_4$7, "create_if_block_4$7");
function create_if_block$v(ctx) {
  let div6;
  let div0;
  let div3;
  let div1;
  let a0;
  let t0_value = (
    /*FFMessage*/
    ctx[1].actor.name + ""
  );
  let t0;
  let a0_aria_label_value;
  let div2;
  let a1;
  let t1_value = (
    /*FFMessage*/
    ctx[1].item.name + ""
  );
  let t1;
  let a1_aria_label_value;
  let div5;
  let div4;
  let t2_value = (
    /*FFMessage*/
    ctx[1].item.type + ""
  );
  let t2;
  let div6_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*showProfileImage*/
    ctx[4] && create_if_block_3$a(ctx)
  );
  let if_block1 = (
    /*item*/
    ctx[2]?.system?.tags?.length > 0 && create_if_block_2$e(ctx)
  );
  function select_block_type(ctx2, dirty) {
    if (
      /*showDescription*/
      ctx2[0]
    )
      return create_if_block_1$i;
    return create_else_block$8;
  }
  __name(select_block_type, "select_block_type");
  let current_block_type = select_block_type(ctx);
  let if_block2 = current_block_type(ctx);
  return {
    c() {
      div6 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      div3 = element("div");
      div1 = element("div");
      a0 = element("a");
      t0 = text(t0_value);
      div2 = element("div");
      a1 = element("a");
      t1 = text(t1_value);
      div5 = element("div");
      div4 = element("div");
      t2 = text(t2_value);
      if (if_block1)
        if_block1.c();
      if_block2.c();
      attr(div0, "class", "texture svelte-n656zp");
      attr(a0, "role", "button");
      attr(a0, "aria-label", a0_aria_label_value = "Open " + /*FFMessage*/
      ctx[1].actor.name + "'s character sheet");
      attr(div1, "class", "col actor-name no-overflow ellipsis");
      attr(a1, "role", "button");
      attr(a1, "aria-label", a1_aria_label_value = "Open " + /*FFMessage*/
      ctx[1].item.name + " item sheet");
      attr(div2, "class", "col font-cinzel smaller item-name no-overflow ellipsis");
      attr(div3, "class", "flexcol no-overflow names svelte-n656zp");
      attr(div4, "class", "right type-label smaller gold");
      attr(div6, "class", div6_class_value = "title " + /*tagsColumnClass*/
      ctx[3] + " svelte-n656zp");
      attr(div6, "role", "button");
      attr(div6, "aria-label", "Toggle description");
    },
    m(target, anchor) {
      insert(target, div6, anchor);
      append(div6, div0);
      if (if_block0)
        if_block0.m(div6, null);
      append(div6, div3);
      append(div3, div1);
      append(div1, a0);
      append(a0, t0);
      append(div3, div2);
      append(div2, a1);
      append(a1, t1);
      append(div6, div5);
      append(div5, div4);
      append(div4, t2);
      if (if_block1)
        if_block1.m(div5, null);
      if_block2.m(div6, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            a0,
            "click",
            /*openActorSheet*/
            ctx[7]
          ),
          listen(
            a1,
            "click",
            /*click_handler*/
            ctx[10]
          ),
          listen(
            div6,
            "click",
            /*handleTitleClick*/
            ctx[8]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (
        /*showProfileImage*/
        ctx2[4]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_3$a(ctx2);
          if_block0.c();
          if_block0.m(div6, div3);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if ((!current || dirty & /*FFMessage*/
      2) && t0_value !== (t0_value = /*FFMessage*/
      ctx2[1].actor.name + ""))
        set_data(t0, t0_value);
      if (!current || dirty & /*FFMessage*/
      2 && a0_aria_label_value !== (a0_aria_label_value = "Open " + /*FFMessage*/
      ctx2[1].actor.name + "'s character sheet")) {
        attr(a0, "aria-label", a0_aria_label_value);
      }
      if ((!current || dirty & /*FFMessage*/
      2) && t1_value !== (t1_value = /*FFMessage*/
      ctx2[1].item.name + ""))
        set_data(t1, t1_value);
      if (!current || dirty & /*FFMessage*/
      2 && a1_aria_label_value !== (a1_aria_label_value = "Open " + /*FFMessage*/
      ctx2[1].item.name + " item sheet")) {
        attr(a1, "aria-label", a1_aria_label_value);
      }
      if ((!current || dirty & /*FFMessage*/
      2) && t2_value !== (t2_value = /*FFMessage*/
      ctx2[1].item.type + ""))
        set_data(t2, t2_value);
      if (
        /*item*/
        ctx2[2]?.system?.tags?.length > 0
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*item*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2$e(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div5, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block2) {
        if_block2.p(ctx2, dirty);
      } else {
        if_block2.d(1);
        if_block2 = current_block_type(ctx2);
        if (if_block2) {
          if_block2.c();
          if_block2.m(div6, null);
        }
      }
      if (!current || dirty & /*tagsColumnClass*/
      8 && div6_class_value !== (div6_class_value = "title " + /*tagsColumnClass*/
      ctx2[3] + " svelte-n656zp")) {
        attr(div6, "class", div6_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div6);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if_block2.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_if_block$v, "create_if_block$v");
function create_if_block_3$a(ctx) {
  let div;
  let img;
  let img_src_value;
  let img_alt_value;
  let div_aria_label_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      img = element("img");
      attr(img, "class", "icon avatar svelte-n656zp");
      if (!src_url_equal(img.src, img_src_value = /*FFMessage*/
      ctx[1].actor.img))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*FFMessage*/
      ctx[1].actor.name);
      attr(div, "role", "button");
      attr(div, "aria-label", div_aria_label_value = "Open " + /*FFMessage*/
      ctx[1].actor.name + "'s character sheet");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, img);
      if (!mounted) {
        dispose = listen(
          div,
          "click",
          /*openActorSheet*/
          ctx[7]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*FFMessage*/
      2 && !src_url_equal(img.src, img_src_value = /*FFMessage*/
      ctx2[1].actor.img)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*FFMessage*/
      2 && img_alt_value !== (img_alt_value = /*FFMessage*/
      ctx2[1].actor.name)) {
        attr(img, "alt", img_alt_value);
      }
      if (dirty & /*FFMessage*/
      2 && div_aria_label_value !== (div_aria_label_value = "Open " + /*FFMessage*/
      ctx2[1].actor.name + "'s character sheet")) {
        attr(div, "aria-label", div_aria_label_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block_3$a, "create_if_block_3$a");
function create_if_block_2$e(ctx) {
  let div1;
  let div0;
  let current;
  let each_value = ensure_array_like(
    /*item*/
    ctx[2]?.system?.tags
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$j(get_each_context$j(ctx, each_value, i));
  }
  const out = /* @__PURE__ */ __name((i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  }), "out");
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "flexrow right no-overflow");
      set_style(div0, "justify-content", "flex-end");
      set_style(div0, "gap", "2px");
      attr(div1, "class", "right");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*item*/
      4) {
        each_value = ensure_array_like(
          /*item*/
          ctx2[2]?.system?.tags
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$j(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$j(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div0, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
__name(create_if_block_2$e, "create_if_block_2$e");
function create_each_block$j(ctx) {
  let div;
  let tag_1;
  let current;
  tag_1 = new Tag({
    props: {
      class: "badge smaller round low",
      tag: (
        /*tag*/
        ctx[14]
      ),
      remover: false
    }
  });
  return {
    c() {
      div = element("div");
      create_component(tag_1.$$.fragment);
      attr(div, "class", "flex0 right");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(tag_1, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const tag_1_changes = {};
      if (dirty & /*item*/
      4)
        tag_1_changes.tag = /*tag*/
        ctx2[14];
      tag_1.$set(tag_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tag_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tag_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(tag_1);
    }
  };
}
__name(create_each_block$j, "create_each_block$j");
function create_else_block$8(ctx) {
  let img;
  let img_src_value;
  let img_alt_value;
  return {
    c() {
      img = element("img");
      attr(img, "class", "icon right item pointer svelte-n656zp");
      if (!src_url_equal(img.src, img_src_value = /*FFMessage*/
      ctx[1].item.img))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*FFMessage*/
      ctx[1].item.name);
      attr(img, "data-tooltip", localize$1("Expand"));
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*FFMessage*/
      2 && !src_url_equal(img.src, img_src_value = /*FFMessage*/
      ctx2[1].item.img)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*FFMessage*/
      2 && img_alt_value !== (img_alt_value = /*FFMessage*/
      ctx2[1].item.name)) {
        attr(img, "alt", img_alt_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
__name(create_else_block$8, "create_else_block$8");
function create_if_block_1$i(ctx) {
  let img;
  let img_src_value;
  let img_alt_value;
  return {
    c() {
      img = element("img");
      attr(img, "class", "icon right item pointer svelte-n656zp");
      if (!src_url_equal(img.src, img_src_value = /*FFMessage*/
      ctx[1].item.img))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*FFMessage*/
      ctx[1].item.name);
      attr(img, "data-tooltip", localize$1("Collapse"));
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*FFMessage*/
      2 && !src_url_equal(img.src, img_src_value = /*FFMessage*/
      ctx2[1].item.img)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*FFMessage*/
      2 && img_alt_value !== (img_alt_value = /*FFMessage*/
      ctx2[1].item.name)) {
        attr(img, "alt", img_alt_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
__name(create_if_block_1$i, "create_if_block_1$i");
function create_fragment$1j(ctx) {
  let div;
  let if_block0_anchor;
  let current;
  let if_block0 = !/*FFMessage*/
  ctx[1] && create_if_block_4$7();
  let if_block1 = (
    /*FFMessage*/
    ctx[1] && create_if_block$v(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      if_block0_anchor = empty();
      if (if_block1)
        if_block1.c();
      attr(div, "class", "chat-title svelte-n656zp");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append(div, if_block0_anchor);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!/*FFMessage*/
      ctx2[1]) {
        if (if_block0)
          ;
        else {
          if_block0 = create_if_block_4$7();
          if_block0.c();
          if_block0.m(div, if_block0_anchor);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*FFMessage*/
        ctx2[1]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*FFMessage*/
          2) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$v(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
__name(create_fragment$1j, "create_fragment$1j");
function instance$1c($$self, $$props, $$invalidate) {
  let showProfileImage;
  let tagsColumnClass;
  let $message;
  let { showDescription = false } = $$props;
  const dispatch2 = createEventDispatcher();
  const message = getContext("message");
  component_subscribe($$self, message, (value) => $$invalidate(9, $message = value));
  let FFMessage;
  let actor;
  let item = {};
  const openItemSheet = /* @__PURE__ */ __name(async (e, uuid) => {
    e.stopPropagation();
    item.sheet.render(true);
  }, "openItemSheet");
  const openActorSheet = /* @__PURE__ */ __name((e) => {
    e.stopPropagation();
    actor.sheet.render(true);
  }, "openActorSheet");
  const handleTitleClick = /* @__PURE__ */ __name(() => {
    dispatch2("toggleDescription");
  }, "handleTitleClick");
  onMount(async () => {
    if (FFMessage?.item?.uuid) {
      $$invalidate(2, item = await fromUuid(FFMessage.item.uuid));
    }
  });
  const click_handler2 = /* @__PURE__ */ __name((e) => openItemSheet(e, FFMessage.item.uuid), "click_handler");
  $$self.$$set = ($$props2) => {
    if ("showDescription" in $$props2)
      $$invalidate(0, showDescription = $$props2.showDescription);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$message, FFMessage*/
    514) {
      if ($message) {
        $$invalidate(1, FFMessage = $message.getFlag(SYSTEM_ID, "data"));
        if (FFMessage?.actor?._id) {
          actor = game.actors.get(FFMessage.actor._id);
        }
      }
    }
    if ($$self.$$.dirty & /*item*/
    4) {
      $$invalidate(3, tagsColumnClass = item?.system?.tags?.length > 1 ? "flex4" : item?.system?.tags?.length > 0 ? "flex2" : "flex1");
    }
  };
  $$invalidate(4, showProfileImage = game.settings.get(SYSTEM_ID, "showChatProfileImages"));
  return [
    showDescription,
    FFMessage,
    item,
    tagsColumnClass,
    showProfileImage,
    message,
    openItemSheet,
    openActorSheet,
    handleTitleClick,
    $message,
    click_handler2
  ];
}
__name(instance$1c, "instance$1c");
let ChatTitle$1 = class ChatTitle extends SvelteComponent {
  static {
    __name(this, "ChatTitle");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$1c, create_fragment$1j, safe_not_equal, { showDescription: 0 });
  }
};
function create_fragment$1i(ctx) {
  let div5;
  let div4;
  let chattitle;
  let div3;
  let div2;
  let button;
  let div0;
  let t_value = window.game.i18n.format(`FFXIV.Chat.Buttons.${/*applied*/
  ctx[1] ? "AppliedTo" : "ApplyItemToTarget"}`, [
    /*FFMessage*/
    ctx[0].item.name,
    /*FFMessage*/
    ctx[0].actor.name
  ]) + "";
  let t;
  let div1;
  let button_class_value;
  let current;
  let mounted;
  let dispose;
  chattitle = new ChatTitle$1({
    props: { sheet: (
      /*FFMessage*/
      ctx[0].item.sheet
    ) }
  });
  return {
    c() {
      div5 = element("div");
      div4 = element("div");
      create_component(chattitle.$$.fragment);
      div3 = element("div");
      div2 = element("div");
      button = element("button");
      div0 = element("div");
      t = text(t_value);
      div1 = element("div");
      div1.innerHTML = `<i class="fa fa-crosshairs mr-sm right mt-sm gold"></i>`;
      attr(div0, "class", "flex3 pa-sm");
      attr(div1, "class", "flex0");
      attr(button, "class", button_class_value = "short wide stealth gold rowimgbezelbutton flexrow " + /*buttonCss*/
      ctx[2] + " svelte-vsw1te");
      attr(div2, "class", "flex4 buttons svelte-vsw1te");
      attr(div3, "class", "flexrow justify-vertical mt-sm");
      attr(div4, "class", "chat svelte-vsw1te");
      attr(div5, "class", "FFXIV");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div4);
      mount_component(chattitle, div4, null);
      append(div4, div3);
      append(div3, div2);
      append(div2, button);
      append(button, div0);
      append(div0, t);
      append(button, div1);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*applyToTarget*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const chattitle_changes = {};
      if (dirty & /*FFMessage*/
      1)
        chattitle_changes.sheet = /*FFMessage*/
        ctx2[0].item.sheet;
      chattitle.$set(chattitle_changes);
      if ((!current || dirty & /*applied, FFMessage*/
      3) && t_value !== (t_value = window.game.i18n.format(`FFXIV.Chat.Buttons.${/*applied*/
      ctx2[1] ? "AppliedTo" : "ApplyItemToTarget"}`, [
        /*FFMessage*/
        ctx2[0].item.name,
        /*FFMessage*/
        ctx2[0].actor.name
      ]) + ""))
        set_data(t, t_value);
      if (!current || dirty & /*buttonCss*/
      4 && button_class_value !== (button_class_value = "short wide stealth gold rowimgbezelbutton flexrow " + /*buttonCss*/
      ctx2[2] + " svelte-vsw1te")) {
        attr(button, "class", button_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(chattitle.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(chattitle.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div5);
      }
      destroy_component(chattitle);
      mounted = false;
      dispose();
    }
  };
}
__name(create_fragment$1i, "create_fragment$1i");
function instance$1b($$self, $$props, $$invalidate) {
  let hasTargets;
  let disabled;
  let buttonCss;
  let applied;
  let $message;
  let $mappedGameTargets;
  component_subscribe($$self, mappedGameTargets, ($$value) => $$invalidate(9, $mappedGameTargets = $$value));
  let { FFMessage } = $$props;
  let { messageId } = $$props;
  const message = getContext("message");
  component_subscribe($$self, message, (value) => $$invalidate(8, $message = value));
  async function applyToTarget() {
    game.system.log.d("applyToTarget");
    game.system.log.d("messageId", messageId);
    const item = FFMessage.item;
    const itemToUpdate = game.actors.get(FFMessage.actor._id).items.get(FFMessage.item._id);
    game.system.log.d("FFMessage", FFMessage);
    game.system.log.d("item", item);
    const itemQuantity = Number(itemToUpdate.system.quantity);
    if (itemQuantity <= 0) {
      ui.notifications.error("The actor doesn't have sufficient quantity of this item to apply.");
      return;
    }
    const effects = item.effects;
    game.system.log.d("effects", effects);
    const customChanges = [];
    const customMode = activeEffectModes.find((x) => x.label === "custom").value;
    game.system.log.d("customMode", customMode);
    for (const effect of effects) {
      const changes = effect.changes;
      for (const change of changes) {
        const mode = change.mode;
        game.system.log.d("mode", mode);
        if (mode === customMode) {
          customChanges.push(change);
        }
      }
    }
    game.system.log.d("customChanges", customChanges);
    for (const change of customChanges) {
      const key = change.key;
      const value = Number(change.value);
      for (const target of $mappedGameTargets) {
        const targetActor = fromUuidSync(target.actorUuid);
        const oldValue = Number(resolveDotpath(targetActor, key));
        game.system.log.d("oldValue", oldValue);
        let newValue = oldValue + value;
        game.system.log.d("proposed nuewValue", value);
        const keyIsVal = key.endsWith(".val");
        if (keyIsVal) {
          const keyMin = key.replace(".val", ".min");
          const keyMax = key.replace(".val", ".max");
          const min = resolveDotpath(targetActor, keyMin);
          const max = resolveDotpath(targetActor, keyMax);
          game.system.log.d("min", min);
          game.system.log.d("max", max);
          if (min !== void 0 && newValue < min) {
            game.system.log.d("min matched");
            newValue = min;
          }
          if (max !== void 0 && newValue > max) {
            game.system.log.d("max matched");
            newValue = max;
          }
        }
        game.system.log.d("value", value);
        game.system.log.d("newValue", newValue);
        game.system.log.d("before update", resolveDotpath(targetActor, key));
        await targetActor.update({ [key]: newValue });
        game.system.log.d("after update", resolveDotpath(targetActor, key));
        const actor = await fromUuid(target.actorUuid);
        game.system.log.d("actor var", resolveDotpath(actor, key));
      }
    }
    await itemToUpdate.update({
      "system.quantity": itemToUpdate.system.quantity - 1
    });
    game.system.log.d("Updated item ", itemToUpdate);
    await $message.update({
      flags: { [SYSTEM_ID]: { data: { applied: true } } }
    });
    game.system.log.d("message ", game.messages.get(messageId));
  }
  __name(applyToTarget, "applyToTarget");
  onMount(async () => {
    game.system.log.d("EquipmentChat mounted");
    game.system.log.d("FFMessage", FFMessage);
  });
  $$self.$$set = ($$props2) => {
    if ("FFMessage" in $$props2)
      $$invalidate(0, FFMessage = $$props2.FFMessage);
    if ("messageId" in $$props2)
      $$invalidate(5, messageId = $$props2.messageId);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$mappedGameTargets*/
    512) {
      $$invalidate(7, hasTargets = $mappedGameTargets.size > 0);
    }
    if ($$self.$$.dirty & /*hasTargets*/
    128) {
      $$invalidate(6, disabled = hasTargets ? false : true);
    }
    if ($$self.$$.dirty & /*$message*/
    256) {
      $$invalidate(1, applied = $message?.flags[SYSTEM_ID]?.data?.applied);
    }
    if ($$self.$$.dirty & /*disabled, applied*/
    66) {
      $$invalidate(2, buttonCss = disabled || applied ? "disabled" : "");
    }
  };
  game.settings.get(SYSTEM_ID, "showChatProfileImages");
  game.settings.get(SYSTEM_ID, "chatMessageSenderIsActorOwner");
  return [
    FFMessage,
    applied,
    buttonCss,
    message,
    applyToTarget,
    messageId,
    disabled,
    hasTargets,
    $message,
    $mappedGameTargets
  ];
}
__name(instance$1b, "instance$1b");
class EquipmentChat extends SvelteComponent {
  static {
    __name(this, "EquipmentChat");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$1b, create_fragment$1i, safe_not_equal, { FFMessage: 0, messageId: 5 });
  }
}
function create_fragment$1h(ctx) {
  let div3;
  let chattitle;
  let div2;
  let div1;
  let div0;
  let raw_value = (
    /*FFMessage*/
    ctx[0].item.system.description + ""
  );
  let div1_class_value;
  let div2_class_value;
  let current;
  chattitle = new ChatTitle$1({
    props: {
      showDescription: (
        /*showDescription*/
        ctx[1]
      )
    }
  });
  chattitle.$on(
    "toggleDescription",
    /*handleToggleDescription*/
    ctx[3]
  );
  return {
    c() {
      div3 = element("div");
      create_component(chattitle.$$.fragment);
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      attr(div0, "class", "flex4 inset");
      attr(div0, "id", "chat-description");
      attr(div1, "class", div1_class_value = "flexrow " + /*showDescription*/
      (ctx[1] ? "visible" : "") + " svelte-bdfh4i");
      attr(div2, "class", div2_class_value = "description-wrapper " + /*showDescription*/
      (ctx[1] ? "expanded" : "") + " svelte-bdfh4i");
      attr(div3, "class", "chat");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      mount_component(chattitle, div3, null);
      append(div3, div2);
      append(div2, div1);
      append(div1, div0);
      div0.innerHTML = raw_value;
      current = true;
    },
    p(ctx2, [dirty]) {
      const chattitle_changes = {};
      if (dirty & /*showDescription*/
      2)
        chattitle_changes.showDescription = /*showDescription*/
        ctx2[1];
      chattitle.$set(chattitle_changes);
      if ((!current || dirty & /*FFMessage*/
      1) && raw_value !== (raw_value = /*FFMessage*/
      ctx2[0].item.system.description + ""))
        div0.innerHTML = raw_value;
      if (!current || dirty & /*showDescription*/
      2 && div1_class_value !== (div1_class_value = "flexrow " + /*showDescription*/
      (ctx2[1] ? "visible" : "") + " svelte-bdfh4i")) {
        attr(div1, "class", div1_class_value);
      }
      if (!current || dirty & /*showDescription*/
      2 && div2_class_value !== (div2_class_value = "description-wrapper " + /*showDescription*/
      (ctx2[1] ? "expanded" : "") + " svelte-bdfh4i")) {
        attr(div2, "class", div2_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(chattitle.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(chattitle.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      destroy_component(chattitle);
    }
  };
}
__name(create_fragment$1h, "create_fragment$1h");
function instance$1a($$self, $$props, $$invalidate) {
  let hasTargets;
  let disabled;
  let applied;
  let $message;
  let $mappedGameTargets;
  component_subscribe($$self, mappedGameTargets, ($$value) => $$invalidate(8, $mappedGameTargets = $$value));
  let { FFMessage } = $$props;
  let showDescription = game.settings.get(SYSTEM_ID, "defaultChatDescriptionVisible");
  const message = getContext("message");
  component_subscribe($$self, message, (value) => $$invalidate(7, $message = value));
  const handleToggleDescription = /* @__PURE__ */ __name(() => {
    $$invalidate(1, showDescription = !showDescription);
  }, "handleToggleDescription");
  onMount(async () => {
  });
  $$self.$$set = ($$props2) => {
    if ("FFMessage" in $$props2)
      $$invalidate(0, FFMessage = $$props2.FFMessage);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$mappedGameTargets*/
    256) {
      $$invalidate(6, hasTargets = $mappedGameTargets.size > 0);
    }
    if ($$self.$$.dirty & /*hasTargets*/
    64) {
      $$invalidate(5, disabled = hasTargets ? false : true);
    }
    if ($$self.$$.dirty & /*$message*/
    128) {
      $$invalidate(4, applied = $message?.flags[SYSTEM_ID]?.data?.applied);
    }
    if ($$self.$$.dirty & /*disabled, applied*/
    48)
      ;
  };
  game.settings.get(SYSTEM_ID, "showChatProfileImages");
  return [
    FFMessage,
    showDescription,
    message,
    handleToggleDescription,
    applied,
    disabled,
    hasTargets,
    $message,
    $mappedGameTargets
  ];
}
__name(instance$1a, "instance$1a");
class RollChat extends SvelteComponent {
  static {
    __name(this, "RollChat");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$1a, create_fragment$1h, safe_not_equal, { FFMessage: 0 });
  }
}
function createDamageText(token, amount, isHealing = false) {
  const displayValue = `${isHealing ? "+" : "-"}${Math.abs(amount)}`;
  canvas.interface.createScrollingText(
    token.center,
    displayValue,
    {
      anchor: CONST.TEXT_ANCHOR_POINTS.TOP,
      direction: CONST.TEXT_ANCHOR_POINTS.TOP,
      duration: 1e3,
      distance: 100,
      fontSize: 36,
      fill: isHealing ? "#00ff00" : "#ff0000",
      stroke: "#000",
      strokeThickness: 4
    }
  );
}
__name(createDamageText, "createDamageText");
function create_fragment$1g(ctx) {
  let svg;
  let g;
  let path0;
  let path1;
  let svg_style_value;
  let svg_levels = [
    /*$$props*/
    ctx[6],
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 106 114" },
    {
      style: svg_style_value = "--size: " + /*size*/
      ctx[0] + "px; --stroke-width: " + /*strokeWidth*/
      ctx[1] + "px; transform: scaleX(" + /*flip*/
      (ctx[5] === "horizontal" || /*flip*/
      ctx[5] === "both" ? "-1" : "1") + ") scaleY(" + /*flip*/
      (ctx[5] === "vertical" || /*flip*/
      ctx[5] === "both" ? "-1" : "1") + ") rotate(" + /*rotation*/
      ctx[3] + "deg);"
    }
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  return {
    c() {
      svg = svg_element("svg");
      g = svg_element("g");
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr(path0, "d", "M81.3438 77.9688C81.1465 78.3361 81.0124 78.7302 80.8125 79.0938C81.1317 78.9786 81.4026 78.8896 81.7188 78.7812C81.5892 78.5192 81.4693 78.1846 81.3438 77.9688Z");
      attr(path0, "class", "svelte-6fk7cz");
      attr(path1, "d", "M105.562-0.09375L101.594 2.9375L101.562 9.40625C100.176 11.8292 96.6661 18.0195 94.4375 21.25C91.9565 24.844 85.5632 31.5625 85.5625 31.5625C85.5625 31.5625 86.2142 39.4735 85.5312 44.1875C84.9762 48.0195 83.0215 57.3338 81.6875 60.9688C80.0565 65.4144 78.969 68.6598 76.75 73.375C74.2739 74.1356 71.1542 75.7678 68.7188 77.0938C65.8498 78.6567 61.6277 82.2972 58.4688 84.2812C54.9897 86.4662 52.005 88.4043 48.25 90.6562C44.578 92.8583 40.7035 94.9483 37.1875 96.7812C33.9525 98.4692 31.748 99.4527 28.375 100.844C24.968 102.249 21.2595 103.187 17.6875 104.312C16.1979 104.781 14.8079 105.122 12.5 105.781L2.71875 105.812L0.21875 109.656L0 110L0.03125 114L99.0938 114L110 102.438L110 64.9375L110 0L105.562-0.09375ZM101.5 22.8438L101.375 69.1875C99.4872 69.1884 95.5264 69.1648 93.0625 69.5312C90.3515 69.9343 87.4145 70.324 84.8438 70.75C84.815 70.7548 84.779 70.7761 84.75 70.7812C84.7015 70.9048 84.674 71.0658 84.625 71.1875C84.5719 71.0159 84.5813 71.0035 84.5312 70.8438C84.5989 70.8305 84.6833 70.7931 84.75 70.7812C86.8489 65.4361 88.5838 58.421 89.9688 53.8125C91.1018 50.0435 91.6521 45.5913 91.9688 42.1562C92.2438 39.1772 91.8747 33.1875 91.875 33.1875C91.875 33.1875 96.4028 29.0543 97.5938 27.6562C98.8107 26.2262 100.412 24.2097 101.5 22.8438ZM94.6562 76.6562C97.516 76.6333 100.082 76.748 101.344 76.8125L101.281 99L95.1562 105.562L60.5625 105.656C62.7372 103.386 66.1864 99.8114 68.5625 97C69.5049 95.8849 70.4357 94.7502 71.375 93.625C71.6949 93.637 71.897 93.6024 72.1562 93.625C74.5343 93.832 78.4323 94.0907 81.1562 94.8438C83.7372 95.5577 88.5 98.1562 88.5 98.1562L90.2188 96.5C90.2188 96.5 88.273 93.0432 87.5 90.1562C86.749 87.3533 86.8763 80.8318 86.4062 77.9688C86.3789 77.8025 86.2852 77.5255 86.25 77.3438C88.6428 76.8397 91.7965 76.6792 94.6562 76.6562ZM81.3438 77.9688C81.4694 78.1846 81.5892 78.5192 81.7188 78.7812C81.9761 79.3017 82.2442 79.7392 82.4375 80.4062C82.7985 81.6513 82.6952 85.5942 83.0312 87.2812C83.4852 89.5562 84.2812 91.8438 84.2812 91.8438C84.2812 91.8438 81.3383 90.2571 79.7812 89.9688C79.1209 89.8468 76.606 89.2347 74.8438 89C75.4858 88.0766 76.1973 87.1987 76.75 86.2188C77.9875 84.0246 79.4247 81.6174 80.8125 79.0938C81.0124 78.7302 81.1465 78.3361 81.3438 77.9688ZM70.7188 83.9062C70.0811 84.8651 69.4293 85.9537 68.8125 86.7812C66.3415 90.0943 62.1708 94.7322 59.25 97.6562C56.9022 100.007 53.0594 103.512 50.6875 105.688L34.0625 105.719C36.1231 105.042 38.1655 104.468 40.125 103.594C43.643 102.024 47.9697 99.7545 51.7188 97.5312C55.5907 95.2352 60.3202 92.1225 63.375 89.8125C65.3525 88.3175 68.236 85.6926 70.7188 83.9062Z");
      attr(path1, "class", "svelte-6fk7cz");
      set_style(
        g,
        "fill",
        /*fill*/
        ctx[4]
      );
      set_style(
        g,
        "stroke",
        /*strokeColor*/
        ctx[2]
      );
      set_style(
        g,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      set_svg_attributes(svg, svg_data);
      toggle_class(svg, "svelte-6fk7cz", true);
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, g);
      append(g, path0);
      append(g, path1);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*fill*/
      16) {
        set_style(
          g,
          "fill",
          /*fill*/
          ctx2[4]
        );
      }
      if (dirty & /*strokeColor*/
      4) {
        set_style(
          g,
          "stroke",
          /*strokeColor*/
          ctx2[2]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        set_style(
          g,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        dirty & /*$$props*/
        64 && /*$$props*/
        ctx2[6],
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 106 114" },
        dirty & /*size, strokeWidth, flip, rotation*/
        43 && svg_style_value !== (svg_style_value = "--size: " + /*size*/
        ctx2[0] + "px; --stroke-width: " + /*strokeWidth*/
        ctx2[1] + "px; transform: scaleX(" + /*flip*/
        (ctx2[5] === "horizontal" || /*flip*/
        ctx2[5] === "both" ? "-1" : "1") + ") scaleY(" + /*flip*/
        (ctx2[5] === "vertical" || /*flip*/
        ctx2[5] === "both" ? "-1" : "1") + ") rotate(" + /*rotation*/
        ctx2[3] + "deg);") && { style: svg_style_value }
      ]));
      toggle_class(svg, "svelte-6fk7cz", true);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
__name(create_fragment$1g, "create_fragment$1g");
function instance$19($$self, $$props, $$invalidate) {
  let { size = 100 } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { strokeColor = "#000" } = $$props;
  let { rotation = 0 } = $$props;
  let { fill = "currentColor" } = $$props;
  let { flip = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("strokeWidth" in $$new_props)
      $$invalidate(1, strokeWidth = $$new_props.strokeWidth);
    if ("strokeColor" in $$new_props)
      $$invalidate(2, strokeColor = $$new_props.strokeColor);
    if ("rotation" in $$new_props)
      $$invalidate(3, rotation = $$new_props.rotation);
    if ("fill" in $$new_props)
      $$invalidate(4, fill = $$new_props.fill);
    if ("flip" in $$new_props)
      $$invalidate(5, flip = $$new_props.flip);
  };
  $$props = exclude_internal_props($$props);
  return [size, strokeWidth, strokeColor, rotation, fill, flip, $$props];
}
__name(instance$19, "instance$19");
class Corner extends SvelteComponent {
  static {
    __name(this, "Corner");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$19, create_fragment$1g, safe_not_equal, {
      size: 0,
      strokeWidth: 1,
      strokeColor: 2,
      rotation: 3,
      fill: 4,
      flip: 5
    });
  }
}
function create_else_block$7(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
__name(create_else_block$7, "create_else_block$7");
function create_if_block$u(ctx) {
  let img_1;
  let img_1_src_value;
  let mounted;
  let dispose;
  return {
    c() {
      img_1 = element("img");
      if (!src_url_equal(img_1.src, img_1_src_value = /*imgSrc*/
      ctx[1]))
        attr(img_1, "src", img_1_src_value);
      attr(img_1, "alt", "avatar");
      attr(img_1, "class", "svelte-13e0b37");
    },
    m(target, anchor) {
      insert(target, img_1, anchor);
      if (!mounted) {
        dispose = listen(img_1, "click", function() {
          if (is_function(
            /*onclick*/
            ctx[3]
          ))
            ctx[3].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*imgSrc*/
      2 && !src_url_equal(img_1.src, img_1_src_value = /*imgSrc*/
      ctx[1])) {
        attr(img_1, "src", img_1_src_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(img_1);
      }
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block$u, "create_if_block$u");
function create_fragment$1f(ctx) {
  let div1;
  let div0;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let corner0;
  let corner1;
  let corner2;
  let corner3;
  let div1_class_value;
  let current;
  const if_block_creators = [create_if_block$u, create_else_block$7];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*img*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  __name(select_block_type, "select_block_type");
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  corner0 = new Corner({
    props: {
      class: "corner bottom-right",
      strokeColor: (
        /*strokeColor*/
        ctx[2]
      ),
      size: (
        /*size*/
        ctx[4]
      )
    }
  });
  corner1 = new Corner({
    props: {
      class: "corner bottom-left",
      flip: "horizontal",
      strokeColor: (
        /*strokeColor*/
        ctx[2]
      ),
      size: (
        /*size*/
        ctx[4]
      )
    }
  });
  corner2 = new Corner({
    props: {
      class: "corner top-right",
      flip: "vertical",
      strokeColor: (
        /*strokeColor*/
        ctx[2]
      ),
      size: (
        /*size*/
        ctx[4]
      )
    }
  });
  corner3 = new Corner({
    props: {
      class: "corner top-left",
      flip: "both",
      strokeColor: (
        /*strokeColor*/
        ctx[2]
      ),
      size: (
        /*size*/
        ctx[4]
      )
    }
  });
  let div0_levels = [
    { class: "frame" },
    /*$$restProps*/
    ctx[5]
  ];
  let div_data = {};
  for (let i = 0; i < div0_levels.length; i += 1) {
    div_data = assign(div_data, div0_levels[i]);
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if_block.c();
      if_block_anchor = empty();
      create_component(corner0.$$.fragment);
      create_component(corner1.$$.fragment);
      create_component(corner2.$$.fragment);
      create_component(corner3.$$.fragment);
      set_attributes(div0, div_data);
      toggle_class(div0, "svelte-13e0b37", true);
      attr(div1, "class", div1_class_value = "atom " + /*$$restProps*/
      (ctx[5]?.class?.includes("high") ? "high" : ""));
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if_blocks[current_block_type_index].m(div0, null);
      append(div0, if_block_anchor);
      mount_component(corner0, div0, null);
      mount_component(corner1, div0, null);
      mount_component(corner2, div0, null);
      mount_component(corner3, div0, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div0, if_block_anchor);
      }
      const corner0_changes = {};
      if (dirty & /*strokeColor*/
      4)
        corner0_changes.strokeColor = /*strokeColor*/
        ctx2[2];
      if (dirty & /*size*/
      16)
        corner0_changes.size = /*size*/
        ctx2[4];
      corner0.$set(corner0_changes);
      const corner1_changes = {};
      if (dirty & /*strokeColor*/
      4)
        corner1_changes.strokeColor = /*strokeColor*/
        ctx2[2];
      if (dirty & /*size*/
      16)
        corner1_changes.size = /*size*/
        ctx2[4];
      corner1.$set(corner1_changes);
      const corner2_changes = {};
      if (dirty & /*strokeColor*/
      4)
        corner2_changes.strokeColor = /*strokeColor*/
        ctx2[2];
      if (dirty & /*size*/
      16)
        corner2_changes.size = /*size*/
        ctx2[4];
      corner2.$set(corner2_changes);
      const corner3_changes = {};
      if (dirty & /*strokeColor*/
      4)
        corner3_changes.strokeColor = /*strokeColor*/
        ctx2[2];
      if (dirty & /*size*/
      16)
        corner3_changes.size = /*size*/
        ctx2[4];
      corner3.$set(corner3_changes);
      set_attributes(div0, div_data = get_spread_update(div0_levels, [{ class: "frame" }, dirty & /*$$restProps*/
      32 && /*$$restProps*/
      ctx2[5]]));
      toggle_class(div0, "svelte-13e0b37", true);
      if (!current || dirty & /*$$restProps*/
      32 && div1_class_value !== (div1_class_value = "atom " + /*$$restProps*/
      (ctx2[5]?.class?.includes("high") ? "high" : ""))) {
        attr(div1, "class", div1_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(corner0.$$.fragment, local);
      transition_in(corner1.$$.fragment, local);
      transition_in(corner2.$$.fragment, local);
      transition_in(corner3.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(corner0.$$.fragment, local);
      transition_out(corner1.$$.fragment, local);
      transition_out(corner2.$$.fragment, local);
      transition_out(corner3.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if_blocks[current_block_type_index].d();
      destroy_component(corner0);
      destroy_component(corner1);
      destroy_component(corner2);
      destroy_component(corner3);
    }
  };
}
__name(create_fragment$1f, "create_fragment$1f");
function instance$18($$self, $$props, $$invalidate) {
  const omit_props_names = ["img", "imgSrc", "strokeColor", "onclick", "size"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { img = false } = $$props;
  let { imgSrc = `${ASSET_PATH}/portraits/witch2.webp` } = $$props;
  let { strokeColor = "#514030" } = $$props;
  let { onclick = void 0 } = $$props;
  let { size = 50 } = $$props;
  onMount(() => {
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("img" in $$new_props)
      $$invalidate(0, img = $$new_props.img);
    if ("imgSrc" in $$new_props)
      $$invalidate(1, imgSrc = $$new_props.imgSrc);
    if ("strokeColor" in $$new_props)
      $$invalidate(2, strokeColor = $$new_props.strokeColor);
    if ("onclick" in $$new_props)
      $$invalidate(3, onclick = $$new_props.onclick);
    if ("size" in $$new_props)
      $$invalidate(4, size = $$new_props.size);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  return [img, imgSrc, strokeColor, onclick, size, $$restProps, $$scope, slots];
}
__name(instance$18, "instance$18");
class PortraitFrame extends SvelteComponent {
  static {
    __name(this, "PortraitFrame");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$18, create_fragment$1f, safe_not_equal, {
      img: 0,
      imgSrc: 1,
      strokeColor: 2,
      onclick: 3,
      size: 4
    });
  }
}
function create_if_block_8$1(ctx) {
  let li;
  let t0;
  let t1_value = (
    /*$item*/
    ctx[0]?.system?.costMP + ""
  );
  let t1;
  let t2;
  return {
    c() {
      li = element("li");
      t0 = text("Cost: ");
      t1 = text(t1_value);
      t2 = text(" MP");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, t0);
      append(li, t1);
      append(li, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*$item*/
      1 && t1_value !== (t1_value = /*$item*/
      ctx2[0]?.system?.costMP + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
    }
  };
}
__name(create_if_block_8$1, "create_if_block_8$1");
function create_if_block_7$1(ctx) {
  let li;
  let t_value = (
    /*CROptions*/
    ctx[2].find(
      /*func*/
      ctx[5]
    )?.label + ""
  );
  let t;
  return {
    c() {
      li = element("li");
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*$item*/
      1 && t_value !== (t_value = /*CROptions*/
      ctx2[2].find(
        /*func*/
        ctx2[5]
      )?.label + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
    }
  };
}
__name(create_if_block_7$1, "create_if_block_7$1");
function create_if_block_6$3(ctx) {
  let li;
  let t_value = (
    /*$item*/
    ctx[0]?.system?.checkAttribute.toUpperCase() + ""
  );
  let t;
  return {
    c() {
      li = element("li");
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*$item*/
      1 && t_value !== (t_value = /*$item*/
      ctx2[0]?.system?.checkAttribute.toUpperCase() + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
    }
  };
}
__name(create_if_block_6$3, "create_if_block_6$3");
function create_if_block_5$3(ctx) {
  let li;
  let t_value = (
    /*limitationOptions*/
    ctx[3].find(
      /*func_1*/
      ctx[6]
    )?.label + ""
  );
  let t;
  return {
    c() {
      li = element("li");
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*$item*/
      1 && t_value !== (t_value = /*limitationOptions*/
      ctx2[3].find(
        /*func_1*/
        ctx2[6]
      )?.label + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
    }
  };
}
__name(create_if_block_5$3, "create_if_block_5$3");
function create_if_block_4$6(ctx) {
  let li;
  let t0_value = localize$1("Types.Item.Range") + "";
  let t0;
  let t1;
  let t2_value = (
    /*$item*/
    ctx[0]?.system?.rangeType + ""
  );
  let t2;
  let li_data_tooltip_value;
  return {
    c() {
      li = element("li");
      t0 = text(t0_value);
      t1 = text(": ");
      t2 = text(t2_value);
      attr(li, "data-tooltip", li_data_tooltip_value = /*rangeDescription*/
      ctx[4](
        /*$item*/
        ctx[0]?.system?.rangeType
      ));
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, t0);
      append(li, t1);
      append(li, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*$item*/
      1 && t2_value !== (t2_value = /*$item*/
      ctx2[0]?.system?.rangeType + ""))
        set_data(t2, t2_value);
      if (dirty & /*$item*/
      1 && li_data_tooltip_value !== (li_data_tooltip_value = /*rangeDescription*/
      ctx2[4](
        /*$item*/
        ctx2[0]?.system?.rangeType
      ))) {
        attr(li, "data-tooltip", li_data_tooltip_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
    }
  };
}
__name(create_if_block_4$6, "create_if_block_4$6");
function create_if_block_3$9(ctx) {
  let li;
  let t0_value = localize$1("Types.Item.Target") + "";
  let t0;
  let t1;
  let t2_value = (
    /*$item*/
    ctx[0]?.system?.target.capitalize() + ""
  );
  let t2;
  return {
    c() {
      li = element("li");
      t0 = text(t0_value);
      t1 = text(": ");
      t2 = text(t2_value);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, t0);
      append(li, t1);
      append(li, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*$item*/
      1 && t2_value !== (t2_value = /*$item*/
      ctx2[0]?.system?.target.capitalize() + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
    }
  };
}
__name(create_if_block_3$9, "create_if_block_3$9");
function create_if_block_2$d(ctx) {
  let li;
  let t0_value = localize$1("Types.Item.Trigger") + "";
  let t0;
  let t1;
  let t2_value = (
    /*$item*/
    ctx[0]?.system?.trigger.capitalize() + ""
  );
  let t2;
  return {
    c() {
      li = element("li");
      t0 = text(t0_value);
      t1 = text(": ");
      t2 = text(t2_value);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, t0);
      append(li, t1);
      append(li, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*$item*/
      1 && t2_value !== (t2_value = /*$item*/
      ctx2[0]?.system?.trigger.capitalize() + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
    }
  };
}
__name(create_if_block_2$d, "create_if_block_2$d");
function create_if_block$t(ctx) {
  let li;
  let t0_value = localize$1("Types.Item.Types.action.DirectHit") + "";
  let t0;
  let t1;
  let t2_value = (
    /*$item*/
    ctx[0]?.system?.directHitType.capitalize() + ""
  );
  let t2;
  let if_block = (
    /*$item*/
    ctx[0]?.system?.directHitDamage && create_if_block_1$h(ctx)
  );
  return {
    c() {
      li = element("li");
      t0 = text(t0_value);
      t1 = text(": ");
      t2 = text(t2_value);
      if (if_block)
        if_block.c();
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, t0);
      append(li, t1);
      append(li, t2);
      if (if_block)
        if_block.m(li, null);
    },
    p(ctx2, dirty) {
      if (dirty & /*$item*/
      1 && t2_value !== (t2_value = /*$item*/
      ctx2[0]?.system?.directHitType.capitalize() + ""))
        set_data(t2, t2_value);
      if (
        /*$item*/
        ctx2[0]?.system?.directHitDamage
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$h(ctx2);
          if_block.c();
          if_block.m(li, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      if (if_block)
        if_block.d();
    }
  };
}
__name(create_if_block$t, "create_if_block$t");
function create_if_block_1$h(ctx) {
  let t0;
  let t1_value = (
    /*$item*/
    ctx[0]?.system?.directHitDamage + ""
  );
  let t1;
  return {
    c() {
      t0 = text(": ");
      t1 = text(t1_value);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$item*/
      1 && t1_value !== (t1_value = /*$item*/
      ctx2[0]?.system?.directHitDamage + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
    }
  };
}
__name(create_if_block_1$h, "create_if_block_1$h");
function create_fragment$1e(ctx) {
  let div3;
  let div2;
  let div1;
  let div0;
  let ol;
  let li;
  let t_value = (
    /*$item*/
    ctx[0]?.system?.type?.capitalize() + ""
  );
  let t;
  let if_block0_anchor;
  let if_block1_anchor;
  let if_block2_anchor;
  let if_block3_anchor;
  let if_block4_anchor;
  let if_block5_anchor;
  let if_block6_anchor;
  let if_block0 = (
    /*$item*/
    ctx[0]?.system?.hasCostMP && create_if_block_8$1(ctx)
  );
  let if_block1 = (
    /*$item*/
    ctx[0]?.system?.hasCR && create_if_block_7$1(ctx)
  );
  let if_block2 = (
    /*$item*/
    ctx[0]?.system?.hasCheck && create_if_block_6$3(ctx)
  );
  let if_block3 = (
    /*$item*/
    ctx[0]?.system?.hasLimitation && create_if_block_5$3(ctx)
  );
  let if_block4 = (
    /*$item*/
    ctx[0]?.system?.hasRanged && create_if_block_4$6(ctx)
  );
  let if_block5 = (
    /*$item*/
    ctx[0]?.system?.hasTarget && create_if_block_3$9(ctx)
  );
  let if_block6 = (
    /*$item*/
    ctx[0]?.system?.hasTrigger && create_if_block_2$d(ctx)
  );
  let if_block7 = (
    /*$item*/
    ctx[0]?.system?.directHitType && create_if_block$t(ctx)
  );
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      ol = element("ol");
      li = element("li");
      t = text(t_value);
      if (if_block0)
        if_block0.c();
      if_block0_anchor = empty();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
      if (if_block3)
        if_block3.c();
      if_block3_anchor = empty();
      if (if_block4)
        if_block4.c();
      if_block4_anchor = empty();
      if (if_block5)
        if_block5.c();
      if_block5_anchor = empty();
      if (if_block6)
        if_block6.c();
      if_block6_anchor = empty();
      if (if_block7)
        if_block7.c();
      attr(li, "class", "bg-gold white border-gold");
      attr(ol, "class", "properties-list svelte-1j7mfxl");
      attr(div0, "class", "flexcol flex1 left svelte-1j7mfxl");
      attr(div1, "class", "flexrow svelte-1j7mfxl");
      attr(div2, "class", "flexcol description-tab svelte-1j7mfxl");
      attr(div3, "class", "item-header");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div1);
      append(div1, div0);
      append(div0, ol);
      append(ol, li);
      append(li, t);
      if (if_block0)
        if_block0.m(ol, null);
      append(ol, if_block0_anchor);
      if (if_block1)
        if_block1.m(ol, null);
      append(ol, if_block1_anchor);
      if (if_block2)
        if_block2.m(ol, null);
      append(ol, if_block2_anchor);
      if (if_block3)
        if_block3.m(ol, null);
      append(ol, if_block3_anchor);
      if (if_block4)
        if_block4.m(ol, null);
      append(ol, if_block4_anchor);
      if (if_block5)
        if_block5.m(ol, null);
      append(ol, if_block5_anchor);
      if (if_block6)
        if_block6.m(ol, null);
      append(ol, if_block6_anchor);
      if (if_block7)
        if_block7.m(ol, null);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$item*/
      1 && t_value !== (t_value = /*$item*/
      ctx2[0]?.system?.type?.capitalize() + ""))
        set_data(t, t_value);
      if (
        /*$item*/
        ctx2[0]?.system?.hasCostMP
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_8$1(ctx2);
          if_block0.c();
          if_block0.m(ol, if_block0_anchor);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*$item*/
        ctx2[0]?.system?.hasCR
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_7$1(ctx2);
          if_block1.c();
          if_block1.m(ol, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*$item*/
        ctx2[0]?.system?.hasCheck
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_6$3(ctx2);
          if_block2.c();
          if_block2.m(ol, if_block2_anchor);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (
        /*$item*/
        ctx2[0]?.system?.hasLimitation
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
        } else {
          if_block3 = create_if_block_5$3(ctx2);
          if_block3.c();
          if_block3.m(ol, if_block3_anchor);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (
        /*$item*/
        ctx2[0]?.system?.hasRanged
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
        } else {
          if_block4 = create_if_block_4$6(ctx2);
          if_block4.c();
          if_block4.m(ol, if_block4_anchor);
        }
      } else if (if_block4) {
        if_block4.d(1);
        if_block4 = null;
      }
      if (
        /*$item*/
        ctx2[0]?.system?.hasTarget
      ) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
        } else {
          if_block5 = create_if_block_3$9(ctx2);
          if_block5.c();
          if_block5.m(ol, if_block5_anchor);
        }
      } else if (if_block5) {
        if_block5.d(1);
        if_block5 = null;
      }
      if (
        /*$item*/
        ctx2[0]?.system?.hasTrigger
      ) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
        } else {
          if_block6 = create_if_block_2$d(ctx2);
          if_block6.c();
          if_block6.m(ol, if_block6_anchor);
        }
      } else if (if_block6) {
        if_block6.d(1);
        if_block6 = null;
      }
      if (
        /*$item*/
        ctx2[0]?.system?.directHitType
      ) {
        if (if_block7) {
          if_block7.p(ctx2, dirty);
        } else {
          if_block7 = create_if_block$t(ctx2);
          if_block7.c();
          if_block7.m(ol, null);
        }
      } else if (if_block7) {
        if_block7.d(1);
        if_block7 = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      if (if_block5)
        if_block5.d();
      if (if_block6)
        if_block6.d();
      if (if_block7)
        if_block7.d();
    }
  };
}
__name(create_fragment$1e, "create_fragment$1e");
function instance$17($$self, $$props, $$invalidate) {
  let $item;
  const item = getContext("#doc");
  component_subscribe($$self, item, (value) => $$invalidate(0, $item = value));
  const CROptions = getCROptions();
  const limitationOptions = getLimitationOptions();
  const rangeOptions = getRangeOptions();
  const rangeDescription = /* @__PURE__ */ __name((range) => {
    const rangeOption = rangeOptions.find((option) => option.value === range);
    return rangeOption ? rangeOption.label : range;
  }, "rangeDescription");
  const func = /* @__PURE__ */ __name((option) => option.value === $item?.system?.CR, "func");
  const func_1 = /* @__PURE__ */ __name((option) => option.value === $item?.system?.limitation, "func_1");
  return [$item, item, CROptions, limitationOptions, rangeDescription, func, func_1];
}
__name(instance$17, "instance$17");
let Header$4 = class Header extends SvelteComponent {
  static {
    __name(this, "Header");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$17, create_fragment$1e, safe_not_equal, {});
  }
};
function create_fragment$1d(ctx) {
  let svg;
  let path0;
  let path1;
  let svg_levels = [
    /*$$props*/
    ctx[5],
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "68 33 457 497" },
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) }
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  return {
    c() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr(
        path0,
        "fill",
        /*fill*/
        ctx[1]
      );
      attr(
        path0,
        "opacity",
        /*opacity*/
        ctx[3]
      );
      attr(path0, "stroke", "none");
      attr(path0, "d", "M204.904602,524.370789 C202.419769,522.398743 201.128571,520.069763 200.468048,517.443359 C196.461655,501.512726 185.031342,492.296661 171.326187,485.151917 C158.590408,478.512543 144.666260,477.275879 130.681992,476.330566 C123.219444,475.826172 116.004601,474.368439 109.255928,470.971741 C110.009483,467.237274 113.019157,466.700195 115.287971,465.792694 C122.697716,462.828949 125.715134,457.700500 124.864571,449.742798 C124.230072,443.806427 124.628395,437.807159 123.809494,431.820435 C122.148384,419.676544 113.961716,410.441071 101.989792,408.363464 C96.511818,407.412842 91.974396,405.064087 88.166229,401.021179 C80.917534,393.325653 74.622894,384.993622 70.318176,375.272186 C69.580841,373.607086 68.785416,371.985168 68.670296,370.078674 C68.459007,366.579712 69.651787,364.942657 73.324554,366.118164 C78.715096,367.843445 83.409988,366.299774 87.954224,363.307922 C101.538925,354.364014 110.188980,342.244659 111.291000,325.751709 C111.755264,318.803436 110.623352,311.780914 107.459396,305.353302 C105.692230,301.763336 105.276939,298.103363 106.037788,294.194153 C107.301529,287.701050 104.149017,281.731415 97.731491,279.617462 C93.099556,278.091705 90.206230,275.718781 89.698227,270.695709 C89.165581,265.429047 91.714905,262.277893 96.170151,260.013763 C99.433098,258.355530 102.548256,256.368073 104.945511,253.494034 C108.531487,249.194839 109.904480,244.454742 107.443237,239.139389 C105.070007,234.014114 100.829407,231.831772 95.323860,232.044510 C92.834572,232.140701 90.361969,232.626999 87.872292,232.765915 C84.890617,232.932281 82.416931,231.302261 83.028877,228.461090 C84.974648,219.427002 84.125168,210.678070 81.758743,201.919846 C81.606613,201.356827 81.954597,200.658646 82.054062,200.110779 C84.135979,199.140228 85.337219,200.627472 86.745354,201.346680 C93.716621,204.907211 100.631554,208.582108 107.660675,212.024048 C114.213821,215.232925 120.574715,214.583267 126.550148,210.393845 C134.219574,205.016708 140.711395,198.734680 142.299728,189.192032 C145.120865,188.197876 146.438766,190.131332 148.042191,191.102753 C154.973663,195.302094 160.410904,194.507812 165.901993,188.629089 C167.866150,186.526291 167.987305,184.843155 165.463348,183.444458 C160.292114,180.578690 159.434204,176.624771 160.423859,170.864166 C161.691864,163.483414 158.457382,157.199219 152.317673,152.676437 C147.596344,149.198502 145.075653,144.533554 144.701141,138.720428 C144.476334,135.230865 145.908524,133.906494 149.559052,134.722717 C159.459274,136.936371 161.954239,135.885300 167.212372,127.194107 C171.350067,120.354904 175.342163,113.420990 179.181625,106.410133 C182.119156,101.046181 186.121628,96.721893 190.694168,92.742805 C193.495728,90.304878 195.360138,91.029793 197.248535,93.614998 C199.178253,96.256805 199.993179,99.270462 200.273804,102.471855 C201.016983,110.949303 204.905594,114.533127 213.498932,114.661285 C213.998734,114.668739 214.499359,114.645531 214.998566,114.664246 C217.753387,114.767471 221.070419,113.965820 221.999969,117.763557 C222.873627,121.332954 222.428574,124.657921 219.158203,127.180023 C215.999588,129.615921 213.090149,132.373093 209.959122,134.847244 C207.627014,136.690063 207.845566,138.512527 209.137665,140.909500 C214.211792,150.322449 224.170700,154.418106 236.655075,152.445709 C244.044739,151.278214 249.237869,147.731323 252.167862,140.734024 C253.380997,137.836868 255.106476,135.129669 256.798065,132.462387 C260.744507,126.239693 263.872681,119.772224 265.501770,112.460777 C267.894257,101.723152 277.625183,96.527824 288.026886,100.203217 C300.463318,104.597565 312.561493,103.593346 324.529327,98.629906 C332.033813,95.517563 337.743591,90.330841 341.753998,83.299149 C344.913269,77.759819 348.970886,72.918259 353.113342,68.119186 C355.468170,65.391052 358.070740,64.900673 361.038818,66.886421 C371.328735,73.770699 381.384308,72.879143 391.320831,66.111649 C393.109619,64.893349 395.162445,64.010910 396.792786,62.620838 C403.694489,56.736298 410.828857,54.007317 420.184021,57.377129 C426.380371,59.609131 432.627228,57.153507 437.819305,52.793751 C443.608521,47.932667 448.134003,41.938026 452.993774,36.238579 C453.837280,35.249344 454.342438,33.900146 456.419952,33.424694 C460.600800,40.110023 461.224945,47.471279 459.701965,55.079353 C457.874847,64.206917 452.680634,71.576584 446.460724,78.195793 C441.150452,83.846939 436.749756,89.979683 433.786560,97.188019 C430.592194,104.958733 424.822662,108.960396 416.206635,108.348747 C411.428741,108.009567 406.921936,108.631401 403.006439,111.773323 C401.508148,112.975616 399.701111,112.914154 397.773712,112.621010 C390.764069,111.554901 383.888397,111.762833 377.181458,114.641441 C373.495331,116.223526 369.770325,115.284485 366.052185,113.814392 C352.622528,108.504509 340.398804,111.412560 332.218109,121.578987 C329.079742,125.479126 327.361603,129.881577 327.319977,134.896133 C327.281281,139.561401 327.182587,144.230804 327.324738,148.891861 C327.565552,156.788223 333.014709,162.414749 340.952026,162.527466 C346.080261,162.600296 350.760895,163.706635 355.398102,165.821381 C360.594025,168.190933 373.041534,164.348923 376.372498,159.716476 C377.745056,157.807663 377.776306,155.682312 377.583984,153.494888 C377.442902,151.890259 376.621765,149.993118 378.670227,149.091431 C380.607971,148.238510 382.595886,148.614700 384.366241,149.820938 C387.464417,151.931885 387.608307,155.013794 387.120636,158.295853 C385.810852,167.111298 389.578003,174.411652 395.278473,180.275330 C401.316772,186.486450 411.219757,183.036804 414.627014,174.593369 C415.671692,172.004654 414.150696,168.116394 417.882751,166.878906 C420.768677,165.921951 423.346313,167.793243 426.055603,168.496750 C429.768158,169.460770 433.507141,169.920242 437.419586,169.362549 C442.022736,168.706390 446.652008,169.451691 449.841553,173.077454 C452.879364,176.530640 456.037445,177.050949 460.037964,175.449677 C461.570343,174.836319 463.223328,174.473206 464.853333,174.165680 C468.094818,173.554199 470.073669,172.380646 468.899902,168.443970 C468.047089,165.583786 468.918213,162.742920 471.077393,160.604584 C474.515228,157.199921 475.003174,153.169693 474.355438,148.627213 C473.566467,143.094238 475.623657,141.130829 481.112732,142.233276 C488.469604,143.710876 493.889923,140.919357 497.675140,134.856201 C499.582916,131.800385 502.118164,129.921829 505.394165,128.957108 C508.629333,128.004395 511.031311,130.159149 509.798828,133.257935 C507.876068,138.092346 506.954407,143.156677 505.506042,148.092941 C504.743835,150.690582 502.938477,152.234894 500.618988,153.449600 C494.719696,156.539001 488.912415,159.805115 482.993469,162.855316 C480.273132,164.257172 479.138214,166.283829 479.264008,169.285126 C479.385345,172.182510 480.858582,173.887955 483.475830,174.824066 C486.458588,175.890884 488.291626,177.927750 488.011230,181.194443 C487.718872,184.599915 485.235352,185.795685 482.204254,186.383987 C471.960938,188.372025 463.123688,192.386642 458.817749,202.852646 C454.014313,214.527893 457.971008,227.338699 469.268341,236.534515 C475.037842,241.230759 474.924194,247.003326 468.948425,251.553162 C468.156647,252.155991 467.268707,252.634094 466.417084,253.156540 C464.256104,254.482239 461.980774,255.811844 462.244537,258.816986 C462.515442,261.903229 464.842072,263.398865 467.398224,264.346283 C470.184204,265.378876 472.485016,266.824738 473.701996,269.625610 C474.875244,272.326050 474.416840,274.886322 472.691315,277.161469 C468.959839,282.081390 467.165894,287.716980 466.204987,293.720032 C465.603180,297.479767 464.296936,300.822998 460.211823,302.188354 C459.606110,302.390778 458.828033,302.770325 458.591797,303.281494 C454.971558,311.114777 449.026062,318.373901 452.625854,327.997803 C453.962524,331.571289 455.481537,335.206940 455.977112,338.939056 C457.221222,348.309082 462.684235,354.534027 469.938599,359.798035 C479.476379,366.718933 495.894073,363.569611 503.823975,353.054199 C509.453705,345.588898 512.293762,336.891724 514.565552,327.968750 C515.084229,325.931732 515.141296,323.687286 517.062561,322.171387 C519.269165,322.763092 519.068054,324.612335 519.242615,326.161560 C520.215210,334.792816 522.150085,343.180511 525.287292,351.295105 C528.127319,358.641174 527.318665,362.170471 520.818970,366.807587 C510.243530,374.352478 499.500946,381.671753 488.673035,388.851166 C481.232452,393.784698 475.350311,399.605133 472.803497,408.583557 C470.773285,415.740723 464.613403,418.105316 457.886200,419.354156 C444.865326,421.771423 436.634552,429.942719 433.766174,442.842834 C432.777527,447.289093 433.916656,451.415710 434.992554,455.593628 C436.028015,459.614349 437.176117,463.581268 437.643341,467.754272 C438.115417,471.970703 436.346985,474.046387 432.428131,474.737152 C431.446625,474.910126 430.439606,475.192688 429.466675,475.120972 C417.899170,474.268707 408.952667,479.549103 400.883362,487.087494 C394.540253,493.013336 388.635895,499.347351 382.982880,505.915985 C378.483185,511.144531 377.449310,517.642761 377.437958,524.160767 C377.429504,529.011230 375.289246,530.429932 371.041382,529.890686 C359.885864,528.474365 349.770233,525.370728 342.425262,515.731445 C333.888916,504.528625 322.391296,499.635986 308.174072,502.255524 C300.072601,503.748199 295.158081,509.136353 291.330750,515.914551 C285.204773,526.763672 282.346405,527.858948 270.309967,524.637756 C265.274811,523.290283 260.569305,521.255737 256.004211,518.821655 C247.665176,514.375305 239.216293,513.897339 230.600861,518.013855 C225.943283,520.239258 221.245468,522.380432 216.589172,524.608459 C212.782532,526.429932 209.011139,527.166016 204.904602,524.370789");
      attr(
        path1,
        "fill",
        /*innerFill*/
        ctx[2]
      );
      attr(
        path1,
        "opacity",
        /*innerOpacity*/
        ctx[4]
      );
      attr(path1, "stroke", "none");
      attr(path1, "d", "M145.391006,328.313843 C145.749557,333.124908 145.836517,337.974457 146.512604,342.740479 C149.844406,366.228180 157.764481,388.064362 172.454330,406.796448 C207.885147,451.976837 253.545258,473.913361 311.208374,462.542816 C394.724213,446.074402 448.898895,358.338837 413.354034,272.423553 C383.390564,199.999008 304.321991,171.473511 237.636749,195.441040 C182.528870,215.247513 146.276688,267.715546 145.391006,328.313843 z");
      set_svg_attributes(svg, svg_data);
      toggle_class(svg, "svelte-y040ka", true);
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path0);
      append(svg, path1);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*fill*/
      2) {
        attr(
          path0,
          "fill",
          /*fill*/
          ctx2[1]
        );
      }
      if (dirty & /*opacity*/
      8) {
        attr(
          path0,
          "opacity",
          /*opacity*/
          ctx2[3]
        );
      }
      if (dirty & /*innerFill*/
      4) {
        attr(
          path1,
          "fill",
          /*innerFill*/
          ctx2[2]
        );
      }
      if (dirty & /*innerOpacity*/
      16) {
        attr(
          path1,
          "opacity",
          /*innerOpacity*/
          ctx2[4]
        );
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        dirty & /*$$props*/
        32 && /*$$props*/
        ctx2[5],
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "68 33 457 497" },
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) }
      ]));
      toggle_class(svg, "svelte-y040ka", true);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
__name(create_fragment$1d, "create_fragment$1d");
function instance$16($$self, $$props, $$invalidate) {
  let { size = 35 } = $$props;
  let { fill = "currentColor" } = $$props;
  let { innerFill = "currentColor" } = $$props;
  let { opacity = 1 } = $$props;
  let { innerOpacity = 1 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("fill" in $$new_props)
      $$invalidate(1, fill = $$new_props.fill);
    if ("innerFill" in $$new_props)
      $$invalidate(2, innerFill = $$new_props.innerFill);
    if ("opacity" in $$new_props)
      $$invalidate(3, opacity = $$new_props.opacity);
    if ("innerOpacity" in $$new_props)
      $$invalidate(4, innerOpacity = $$new_props.innerOpacity);
  };
  $$props = exclude_internal_props($$props);
  return [size, fill, innerFill, opacity, innerOpacity, $$props];
}
__name(instance$16, "instance$16");
class Meteor extends SvelteComponent {
  static {
    __name(this, "Meteor");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$16, create_fragment$1d, safe_not_equal, {
      size: 0,
      fill: 1,
      innerFill: 2,
      opacity: 3,
      innerOpacity: 4
    });
  }
}
const { Boolean: Boolean_1 } = globals;
function get_each_context$i(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[32] = list[i];
  return child_ctx;
}
__name(get_each_context$i, "get_each_context$i");
function create_if_block_6$2(ctx) {
  let div2;
  let div1;
  let div0;
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      attr(div1, "class", "flex3 content");
      attr(div2, "class", "flexrow gap-4 leather mt-xs");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      div0.innerHTML = /*content*/
      ctx[1];
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*content*/
      2)
        div0.innerHTML = /*content*/
        ctx2[1];
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
    }
  };
}
__name(create_if_block_6$2, "create_if_block_6$2");
function create_if_block$s(ctx) {
  let div1;
  let div0;
  let current;
  let each_value = ensure_array_like(
    /*targetTokens*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$i(get_each_context$i(ctx, each_value, i));
  }
  const out = /* @__PURE__ */ __name((i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  }), "out");
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "target-list svelte-ugr7oj");
      attr(div1, "class", "action-result svelte-ugr7oj");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*targetTokens, isApplyDisabled, undoResult, applyResult, displayDirectHitDisplayFormula, isHit, displayDirectHitDamage, item, displayDamageFormula, displayDamage, FFMessage, openActorSheet*/
      31725) {
        each_value = ensure_array_like(
          /*targetTokens*/
          ctx2[3]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$i(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$i(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div0, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean_1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
__name(create_if_block$s, "create_if_block$s");
function create_if_block_1$g(ctx) {
  let div17;
  let div16;
  let div0;
  let div15;
  let div9;
  let div8;
  let div1;
  let div7;
  let div2;
  let t0_value = (
    /*target*/
    ctx[32].name + ""
  );
  let t0;
  let div6;
  let div3;
  let div4;
  let t3_value = getDefenseValue(
    /*target*/
    ctx[32]
  ) + "";
  let t3;
  let div5;
  let current_block_type_index;
  let if_block1;
  let div10;
  let if_block2_anchor;
  let div10_class_value;
  let div14;
  let div13;
  let div11;
  let button0;
  let i0;
  let button0_disabled_value;
  let div12;
  let button1;
  let i1;
  let button1_disabled_value;
  let div15_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*target*/
    ctx[32] && !/*target*/
    ctx[32].isUnlinked && create_if_block_5$2(ctx)
  );
  const if_block_creators = [create_if_block_4$5, create_else_block$6];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*FFMessage*/
      ctx2[0]?.isCritical
    )
      return 0;
    return 1;
  }
  __name(select_block_type, "select_block_type");
  current_block_type_index = select_block_type(ctx);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block2 = (
    /*item*/
    ctx[9]?.system?.baseEffectDamage && create_if_block_3$8(ctx)
  );
  let if_block3 = (
    /*item*/
    ctx[9]?.system?.hasDirectHit && create_if_block_2$c(ctx)
  );
  return {
    c() {
      div17 = element("div");
      div16 = element("div");
      div0 = element("div");
      div15 = element("div");
      div9 = element("div");
      div8 = element("div");
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      div7 = element("div");
      div2 = element("div");
      t0 = text(t0_value);
      div6 = element("div");
      div3 = element("div");
      div3.textContent = `${localize$1("Types.Actor.Types.PC.Attributes.secondary.def.Abbreviation")} `;
      div4 = element("div");
      t3 = text(t3_value);
      div5 = element("div");
      if_block1.c();
      div10 = element("div");
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
      if (if_block3)
        if_block3.c();
      div14 = element("div");
      div13 = element("div");
      div11 = element("div");
      button0 = element("button");
      i0 = element("i");
      div12 = element("div");
      button1 = element("button");
      i1 = element("i");
      attr(div0, "class", "texture svelte-ugr7oj");
      attr(div1, "class", "flex0 target-info pointer svelte-ugr7oj");
      attr(div2, "class", "col target-name font-cinzel smaller svelte-ugr7oj");
      attr(div3, "class", "flex1 left font-cinzel");
      attr(div3, "data-tooltip-class", "FFXIV-tooltip");
      attr(div3, "data-tooltip", "Defense");
      attr(div4, "class", "flex1 m1-xs left");
      attr(div5, "class", "flex1 relative right");
      attr(div6, "class", "col flexrow justify-vertical no-wrap");
      attr(div7, "class", "flex1 flexcol thin-border");
      attr(div8, "class", "flexrow justify-vertical gap-4");
      attr(div9, "class", "flex3");
      attr(div10, "class", div10_class_value = "flex2 thin-border offwhite " + /*isApplyDisabled*/
      (ctx[2](
        /*target*/
        ctx[32]
      ) ? "bg-silver" : "bg-gold"));
      set_style(div10, "min-height", "2.6rem");
      attr(i0, "class", "fa-solid fa-check");
      attr(button0, "class", "stealth apply-trait svelte-ugr7oj");
      button0.disabled = button0_disabled_value = /*isApplyDisabled*/
      ctx[2](
        /*target*/
        ctx[32]
      );
      attr(div11, "class", "flex1");
      attr(i1, "class", "fa-solid fa-refresh");
      attr(button1, "class", "stealth apply-trait svelte-ugr7oj");
      button1.disabled = button1_disabled_value = !/*isApplyDisabled*/
      ctx[2](
        /*target*/
        ctx[32]
      );
      attr(div12, "class", "flex1");
      attr(div13, "class", "flexcol");
      attr(div14, "class", "flex0");
      attr(div15, "class", div15_class_value = "target-row flexrow " + /*target*/
      (ctx[32].isUnlinked ? "unlinked" : "") + " svelte-ugr7oj");
      attr(div16, "class", "background svelte-ugr7oj");
      attr(div17, "class", "leatherbook svelte-ugr7oj");
    },
    m(target, anchor) {
      insert(target, div17, anchor);
      append(div17, div16);
      append(div16, div0);
      append(div16, div15);
      append(div15, div9);
      append(div9, div8);
      append(div8, div1);
      if (if_block0)
        if_block0.m(div1, null);
      append(div8, div7);
      append(div7, div2);
      append(div2, t0);
      append(div7, div6);
      append(div6, div3);
      append(div6, div4);
      append(div4, t3);
      append(div6, div5);
      if_blocks[current_block_type_index].m(div5, null);
      append(div15, div10);
      if (if_block2)
        if_block2.m(div10, null);
      append(div10, if_block2_anchor);
      if (if_block3)
        if_block3.m(div10, null);
      append(div15, div14);
      append(div14, div13);
      append(div13, div11);
      append(div11, button0);
      append(button0, i0);
      append(div13, div12);
      append(div12, button1);
      append(button1, i1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", function() {
            if (is_function(
              /*applyResult*/
              ctx[11](
                /*target*/
                ctx[32]
              )
            ))
              ctx[11](
                /*target*/
                ctx[32]
              ).apply(this, arguments);
          }),
          listen(button1, "click", function() {
            if (is_function(
              /*undoResult*/
              ctx[12](
                /*target*/
                ctx[32]
              )
            ))
              ctx[12](
                /*target*/
                ctx[32]
              ).apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*target*/
        ctx[32] && !/*target*/
        ctx[32].isUnlinked
      ) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_5$2(ctx);
          if_block0.c();
          if_block0.m(div1, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if ((!current || dirty[0] & /*targetTokens*/
      8) && t0_value !== (t0_value = /*target*/
      ctx[32].name + ""))
        set_data(t0, t0_value);
      if ((!current || dirty[0] & /*targetTokens*/
      8) && t3_value !== (t3_value = getDefenseValue(
        /*target*/
        ctx[32]
      ) + ""))
        set_data(t3, t3_value);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block1.c();
        } else {
          if_block1.p(ctx, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(div5, null);
      }
      if (
        /*item*/
        ctx[9]?.system?.baseEffectDamage
      )
        if_block2.p(ctx, dirty);
      if (
        /*item*/
        ctx[9]?.system?.hasDirectHit
      )
        if_block3.p(ctx, dirty);
      if (!current || dirty[0] & /*isApplyDisabled, targetTokens*/
      12 && div10_class_value !== (div10_class_value = "flex2 thin-border offwhite " + /*isApplyDisabled*/
      (ctx[2](
        /*target*/
        ctx[32]
      ) ? "bg-silver" : "bg-gold"))) {
        attr(div10, "class", div10_class_value);
      }
      if (!current || dirty[0] & /*isApplyDisabled, targetTokens*/
      12 && button0_disabled_value !== (button0_disabled_value = /*isApplyDisabled*/
      ctx[2](
        /*target*/
        ctx[32]
      ))) {
        button0.disabled = button0_disabled_value;
      }
      if (!current || dirty[0] & /*isApplyDisabled, targetTokens*/
      12 && button1_disabled_value !== (button1_disabled_value = !/*isApplyDisabled*/
      ctx[2](
        /*target*/
        ctx[32]
      ))) {
        button1.disabled = button1_disabled_value;
      }
      if (!current || dirty[0] & /*targetTokens*/
      8 && div15_class_value !== (div15_class_value = "target-row flexrow " + /*target*/
      (ctx[32].isUnlinked ? "unlinked" : "") + " svelte-ugr7oj")) {
        attr(div15, "class", div15_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div17);
      }
      if (if_block0)
        if_block0.d();
      if_blocks[current_block_type_index].d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_if_block_1$g, "create_if_block_1$g");
function create_if_block_5$2(ctx) {
  let img;
  let img_src_value;
  let img_alt_value;
  let mounted;
  let dispose;
  return {
    c() {
      img = element("img");
      attr(img, "class", "target-img clickable svelte-ugr7oj");
      if (!src_url_equal(img.src, img_src_value = getTargetImage(
        /*target*/
        ctx[32]
      )))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*target*/
      ctx[32].name);
    },
    m(target, anchor) {
      insert(target, img, anchor);
      if (!mounted) {
        dispose = listen(img, "click", function() {
          if (is_function(
            /*openActorSheet*/
            ctx[14](
              /*target*/
              ctx[32].actor
            )
          ))
            ctx[14](
              /*target*/
              ctx[32].actor
            ).apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*targetTokens*/
      8 && !src_url_equal(img.src, img_src_value = getTargetImage(
        /*target*/
        ctx[32]
      ))) {
        attr(img, "src", img_src_value);
      }
      if (dirty[0] & /*targetTokens*/
      8 && img_alt_value !== (img_alt_value = /*target*/
      ctx[32].name)) {
        attr(img, "alt", img_alt_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block_5$2, "create_if_block_5$2");
function create_else_block$6(ctx) {
  let i;
  let i_class_value;
  let i_data_tooltip_value;
  return {
    c() {
      i = element("i");
      attr(i, "class", i_class_value = "icon fa-solid bg-white round " + /*isHit*/
      (ctx[13](
        /*target*/
        ctx[32]
      ) ? "fa-circle-check positive" : "fa-circle-xmark negative") + " svelte-ugr7oj");
      attr(i, "data-tooltip", i_data_tooltip_value = /*isHit*/
      ctx[13](
        /*target*/
        ctx[32]
      ) ? localize$1("DirectHit") : localize$1("Types.Item.Types.action.DirectHitMissed"));
    },
    m(target, anchor) {
      insert(target, i, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*targetTokens*/
      8 && i_class_value !== (i_class_value = "icon fa-solid bg-white round " + /*isHit*/
      (ctx2[13](
        /*target*/
        ctx2[32]
      ) ? "fa-circle-check positive" : "fa-circle-xmark negative") + " svelte-ugr7oj")) {
        attr(i, "class", i_class_value);
      }
      if (dirty[0] & /*targetTokens*/
      8 && i_data_tooltip_value !== (i_data_tooltip_value = /*isHit*/
      ctx2[13](
        /*target*/
        ctx2[32]
      ) ? localize$1("DirectHit") : localize$1("Types.Item.Types.action.DirectHitMissed"))) {
        attr(i, "data-tooltip", i_data_tooltip_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(i);
      }
    }
  };
}
__name(create_else_block$6, "create_else_block$6");
function create_if_block_4$5(ctx) {
  let div1;
  let meteor;
  let div0;
  let i;
  let i_class_value;
  let current;
  meteor = new Meteor({
    props: {
      fill: "var(--ff-border-color)",
      innerFill: "var(--message-color)",
      innerOpacity: "1",
      opacity: "1",
      size: "25"
    }
  });
  return {
    c() {
      div1 = element("div");
      create_component(meteor.$$.fragment);
      div0 = element("div");
      i = element("i");
      attr(i, "class", i_class_value = "icon fa-solid bg-white round " + /*isHit*/
      (ctx[13](
        /*target*/
        ctx[32]
      ) ? "fa-circle-check positive" : "fa-circle-xmark negative") + " svelte-ugr7oj");
      attr(i, "data-tooltip", localize$1("CriticalSuccess"));
      attr(div0, "class", "overlay svelte-ugr7oj");
      set_style(div0, "margin", "0");
      set_style(div0, "font-size", "1rem");
      set_style(div0, "color", "#fff");
      attr(div1, "class", "critical svelte-ugr7oj");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      mount_component(meteor, div1, null);
      append(div1, div0);
      append(div0, i);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty[0] & /*targetTokens*/
      8 && i_class_value !== (i_class_value = "icon fa-solid bg-white round " + /*isHit*/
      (ctx2[13](
        /*target*/
        ctx2[32]
      ) ? "fa-circle-check positive" : "fa-circle-xmark negative") + " svelte-ugr7oj")) {
        attr(i, "class", i_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(meteor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(meteor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(meteor);
    }
  };
}
__name(create_if_block_4$5, "create_if_block_4$5");
function create_if_block_3$8(ctx) {
  let div2;
  let div0;
  let div1;
  let t1_value = (
    /*displayDamage*/
    ctx[8](
      /*target*/
      ctx[32]
    ) + ""
  );
  let t1;
  let div2_data_tooltip_value;
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      div0.textContent = `${localize$1("Damage")}`;
      div1 = element("div");
      t1 = text(t1_value);
      attr(div0, "class", "flex3 left font-cinzel smaller");
      attr(div1, "class", "flex1 right no-wrap");
      attr(div2, "class", "flex1 formula flexrow justify-vertical active");
      attr(div2, "data-tooltip-class", "FFXIV-tooltip");
      attr(div2, "data-tooltip", div2_data_tooltip_value = /*displayDamageFormula*/
      ctx[7](
        /*target*/
        ctx[32]
      ));
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div2, div1);
      append(div1, t1);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*displayDamage, targetTokens*/
      264 && t1_value !== (t1_value = /*displayDamage*/
      ctx2[8](
        /*target*/
        ctx2[32]
      ) + ""))
        set_data(t1, t1_value);
      if (dirty[0] & /*displayDamageFormula, targetTokens*/
      136 && div2_data_tooltip_value !== (div2_data_tooltip_value = /*displayDamageFormula*/
      ctx2[7](
        /*target*/
        ctx2[32]
      ))) {
        attr(div2, "data-tooltip", div2_data_tooltip_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
    }
  };
}
__name(create_if_block_3$8, "create_if_block_3$8");
function create_if_block_2$c(ctx) {
  let div2;
  let div0;
  let div1;
  let t1_value = (
    /*isHit*/
    (ctx[13](
      /*target*/
      ctx[32]
    ) ? (
      /*displayDirectHitDamage*/
      ctx[6](
        /*target*/
        ctx[32]
      )
    ) : "N/A") + ""
  );
  let t1;
  let div2_data_tooltip_value;
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      div0.textContent = `${localize$1("Types.Item.Types.action.DirectHit")}`;
      div1 = element("div");
      t1 = text(t1_value);
      attr(div0, "class", "flex3 left font-cinzel even-smaller");
      attr(div1, "class", "flex1 right no-wrap");
      attr(div2, "class", "flex1 formula flexrow justify-vertical smaller");
      attr(div2, "data-tooltip-class", "FFXIV-tooltip");
      attr(div2, "data-tooltip", div2_data_tooltip_value = /*displayDirectHitDisplayFormula*/
      ctx[5](
        /*target*/
        ctx[32]
      ));
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div2, div1);
      append(div1, t1);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*targetTokens, displayDirectHitDamage*/
      72 && t1_value !== (t1_value = /*isHit*/
      (ctx2[13](
        /*target*/
        ctx2[32]
      ) ? (
        /*displayDirectHitDamage*/
        ctx2[6](
          /*target*/
          ctx2[32]
        )
      ) : "N/A") + ""))
        set_data(t1, t1_value);
      if (dirty[0] & /*displayDirectHitDisplayFormula, targetTokens*/
      40 && div2_data_tooltip_value !== (div2_data_tooltip_value = /*displayDirectHitDisplayFormula*/
      ctx2[5](
        /*target*/
        ctx2[32]
      ))) {
        attr(div2, "data-tooltip", div2_data_tooltip_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
    }
  };
}
__name(create_if_block_2$c, "create_if_block_2$c");
function create_each_block$i(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*target*/
    ctx[32] && create_if_block_1$g(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*target*/
        ctx2[32]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*targetTokens*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$g(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
__name(create_each_block$i, "create_each_block$i");
function create_fragment$1c(ctx) {
  let div3;
  let chattitle;
  let div2;
  let div1;
  let div0;
  let html_tag;
  let raw_value = (
    /*item*/
    ctx[9]?.system?.description + ""
  );
  let html_anchor;
  let header;
  let div1_class_value;
  let div2_class_value;
  let if_block0_anchor;
  let current;
  chattitle = new ChatTitle$1({});
  chattitle.$on(
    "toggleDescription",
    /*handleToggleDescription*/
    ctx[15]
  );
  header = new Header$4({});
  let if_block0 = (
    /*content*/
    ctx[1] && create_if_block_6$2(ctx)
  );
  let if_block1 = (
    /*FFMessage*/
    ctx[0]?.item?.type === "action" && /*item*/
    ctx[9] && /*targetTokens*/
    ctx[3].length && create_if_block$s(ctx)
  );
  return {
    c() {
      div3 = element("div");
      create_component(chattitle.$$.fragment);
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      create_component(header.$$.fragment);
      if (if_block0)
        if_block0.c();
      if_block0_anchor = empty();
      if (if_block1)
        if_block1.c();
      html_tag.a = html_anchor;
      attr(div0, "class", "flex4 inset svelte-ugr7oj");
      attr(div0, "id", "chat-description");
      attr(div1, "class", div1_class_value = "flexrow mt-xs " + /*showDescription*/
      (ctx[4] ? "visible" : "") + " svelte-ugr7oj");
      attr(div2, "class", div2_class_value = "description-wrapper " + /*showDescription*/
      (ctx[4] ? "expanded" : "") + " svelte-ugr7oj");
      attr(div3, "class", "chat");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      mount_component(chattitle, div3, null);
      append(div3, div2);
      append(div2, div1);
      append(div1, div0);
      html_tag.m(raw_value, div0);
      append(div0, html_anchor);
      mount_component(header, div0, null);
      if (if_block0)
        if_block0.m(div3, null);
      append(div3, if_block0_anchor);
      if (if_block1)
        if_block1.m(div3, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty[0] & /*showDescription*/
      16 && div1_class_value !== (div1_class_value = "flexrow mt-xs " + /*showDescription*/
      (ctx2[4] ? "visible" : "") + " svelte-ugr7oj")) {
        attr(div1, "class", div1_class_value);
      }
      if (!current || dirty[0] & /*showDescription*/
      16 && div2_class_value !== (div2_class_value = "description-wrapper " + /*showDescription*/
      (ctx2[4] ? "expanded" : "") + " svelte-ugr7oj")) {
        attr(div2, "class", div2_class_value);
      }
      if (
        /*content*/
        ctx2[1]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_6$2(ctx2);
          if_block0.c();
          if_block0.m(div3, if_block0_anchor);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*FFMessage*/
        ctx2[0]?.item?.type === "action" && /*item*/
        ctx2[9] && /*targetTokens*/
        ctx2[3].length
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*FFMessage, targetTokens*/
          9) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$s(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div3, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(chattitle.$$.fragment, local);
      transition_in(header.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(chattitle.$$.fragment, local);
      transition_out(header.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      destroy_component(chattitle);
      destroy_component(header);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
__name(create_fragment$1c, "create_fragment$1c");
function getDefenseValue(target) {
  if (target?.isUnlinked || !target?.actor?.system?.attributes)
    return 0;
  if (target?.actor?.type === "npc") {
    const defense2 = target?.actor?.system?.attributes?.defence?.val || 0;
    return defense2;
  }
  const defense = target?.actor?.system?.attributes?.secondary?.def?.val || 0;
  const magicDefense = target?.actor?.system?.attributes?.secondary?.mag?.val || 0;
  return Math.max(defense, magicDefense);
}
__name(getDefenseValue, "getDefenseValue");
function getTargetImage(target) {
  if (target?.isUnlinked)
    return null;
  return target?.document?.texture?.src || target?.actor?.img;
}
__name(getTargetImage, "getTargetImage");
function instance$15($$self, $$props, $$invalidate) {
  let actor;
  let isApplyDisabled;
  let displayDamage;
  let displayDamageFormula;
  let displayDirectHitDamage;
  let displayDirectHitDisplayFormula;
  let penalty;
  let totalRoll;
  let $message;
  let { FFMessage } = $$props;
  let { FFMessageState } = $$props;
  let { content } = $$props;
  let { classes = "" } = $$props;
  const item = fromUuidSync(FFMessage.item.uuid);
  if (item) {
    const Item2 = new TJSDocument();
    Item2.set(item);
    setContext("#doc", Item2);
  }
  const message = getContext("message");
  component_subscribe($$self, message, (value) => $$invalidate(26, $message = value));
  let isMounted = false;
  let targetTokens = false;
  let showDescription = false;
  let roll = 0;
  let hasTargets = false;
  function getDamageResults(passedTargets) {
    const DamageResults = /* @__PURE__ */ new Map();
    for (const id of passedTargets) {
      let token = canvas.tokens.get(id);
      let baseEffectDamage = item?.system?.baseEffectDamage;
      if (FFMessage?.isCritical && baseEffectDamage) {
        baseEffectDamage = baseEffectDamage.replace(/(\d+)d(\d+)/g, (match, count, sides) => {
          return `${parseInt(count, 10) * 2}d${sides}`;
        });
      }
      const directHitDamage = item?.system?.directHitDamage;
      const baseDamageFormula = item?.system?.hasSplitDamage ? `Split BaseDamage (${baseEffectDamage}  ${passedTargets.length})` : `Base Damage (${baseEffectDamage})`;
      const directHitDisplayFormula = item?.system?.hasSplitDamage ? `Split Direct Hit (${directHitDamage}  ${passedTargets.length})` : `Direct Hit (${directHitDamage})`;
      const damageResult = {
        damage: baseEffectDamage,
        healing: item?.system?.baseEffectHealing,
        baseDamageFormula,
        directHit: item?.system?.hasDirectHit ? directHitDamage : null,
        directHitFormula: item?.system?.hasDirectHit ? directHitDamage : null,
        directHitDisplayFormula: item?.system?.hasDirectHit ? directHitDisplayFormula : null,
        directHitResult: false,
        applied: false,
        originalHP: token.actor?.system.points.HP.val,
        wasKOd: false
      };
      DamageResults.set(id, damageResult);
    }
    if (DamageResults.size > 0) {
      Hooks.callAll("FFXIV.processAdditionalBaseDamageFromItem", { item, actor, DamageResults });
      Hooks.callAll("FFXIV.DamageDiceReroll", {
        item,
        actor,
        DamageResults,
        isCritical: FFMessage?.isCritical
      });
    }
    return DamageResults;
  }
  __name(getDamageResults, "getDamageResults");
  async function initializeStores() {
    if (FFMessage?.item?.type === "action" && hasTargets) {
      let storedDamageResults = FFMessageState.damageResults;
      if (FFMessage.targets.length > 0) {
        if (!storedDamageResults && !FFMessageState.initialised) {
          storedDamageResults = getDamageResults(FFMessage.targets);
          if ($message) {
            await $message.update({
              flags: {
                [SYSTEM_ID]: {
                  state: {
                    damageResults: Object.fromEntries(storedDamageResults),
                    initialised: true
                  }
                }
              }
            });
          }
        }
        if (canvas.ready) {
          $$invalidate(3, targetTokens = FFMessage.targets.map((id) => canvas.tokens.get(id)).filter(Boolean));
        } else {
          Hooks.once("canvasReady", () => {
            $$invalidate(3, targetTokens = FFMessage.targets.map((id) => canvas.tokens.get(id)).filter(Boolean));
          });
        }
      }
    }
  }
  __name(initializeStores, "initializeStores");
  onMount(async () => {
    if (!isMounted) {
      await initializeStores();
      isMounted = true;
    }
    game.system.log.o("[ACTION ROLL CHAT] Mounted targetTokens", targetTokens);
  });
  async function applyResult(target) {
    if (isApplyDisabled(target))
      return;
    const newDamageResults = { ...FFMessageState.damageResults };
    newDamageResults[target.id] = {
      ...newDamageResults[target.id],
      applied: true
    };
    await $message.update({
      flags: {
        [SYSTEM_ID]: {
          state: { damageResults: newDamageResults }
        }
      }
    });
    const token = canvas.tokens.get(target.id);
    if (!token)
      return;
    const damageResults = FFMessageState.damageResults[target.id];
    if (!damageResults)
      return;
    const baseDamage = parseInt(damageResults.damage) || 0;
    let directHitDamage = 0;
    if (isHit(target) && item?.system?.hasDirectHit && item?.system?.directHitDamage) {
      if (damageResults.directHit.includes("d")) {
        const directHitRoll = await new Roll(damageResults.directHit).evaluate({ async: true });
        if (game.modules.get("dice-so-nice")?.active) {
          await game.dice3d.showForRoll(directHitRoll);
        }
        directHitDamage = directHitRoll.total;
      } else {
        directHitDamage = parseInt(damageResults.directHit) || 0;
      }
    }
    const totalDamage2 = baseDamage + directHitDamage;
    game.system.log.o("[DAMAGE] Calculating total:", { baseDamage, directHitDamage, totalDamage: totalDamage2 });
    createDamageText(token, totalDamage2);
    const currentBP = token.actor.system.points.BP.val;
    let remainingDamage = totalDamage2;
    let newBP = currentBP;
    game.system.log.o("[BARRIER] Before damage application:", { currentBP, totalDamage: totalDamage2, remainingDamage });
    if (currentBP > 0) {
      if (currentBP >= totalDamage2) {
        newBP = currentBP - totalDamage2;
        remainingDamage = 0;
      } else {
        remainingDamage = totalDamage2 - currentBP;
        newBP = 0;
      }
      game.system.log.o("[BARRIER] After barrier calculation:", { newBP, remainingDamage });
      await token.actor.update({ "system.points.BP.val": newBP });
    }
    const currentHP = token.actor.system.points.HP.val;
    const newHP = Math.max(currentHP - remainingDamage, 0);
    game.system.log.o("[KO CHECK] Before HP update:", { currentHP, remainingDamage, newHP });
    await token.actor.update({ "system.points.HP.val": newHP });
    await Hooks.callAll("FFXIV.onDamage", {
      actor: token.actor,
      damage: remainingDamage
    });
    game.system.log.o("[KO CHECK] After HP update:", {
      updatedCurrentHP: token.actor.system.points.HP.val,
      hasKoStatus: token.actor.statuses.has("ko")
    });
    if (token.actor.system.points.HP.val === 0 && !token.actor.statuses.has("ko")) {
      game.system.log.o("[KO CHECK] Applying KO status");
      await token.actor.toggleStatusEffect("ko");
      game.system.log.o("[KO CHECK] KO status applied");
    }
    newDamageResults[target.id] = {
      ...newDamageResults[target.id],
      wasKOd: newHP <= 0,
      directHitResult: directHitDamage
    };
    await $message.update({
      flags: {
        [SYSTEM_ID]: {
          state: { damageResults: newDamageResults }
        }
      }
    });
  }
  __name(applyResult, "applyResult");
  async function undoResult(target) {
    if (!target.actor || target.isUnlinked)
      return;
    const token = canvas.tokens.get(target.id);
    if (!token)
      return;
    const result = FFMessageState.damageResults[target.id];
    if (!result || !result.applied)
      return;
    const currentHP = token.actor.system.points.HP.val;
    const originalHP = result.originalHP;
    if (currentHP !== originalHP) {
      createDamageText(token, originalHP - currentHP, true);
      await token.actor.update({ "system.points.HP.val": originalHP });
    }
    if (result.wasKOd) {
      await token.actor.toggleStatusEffect("ko");
    }
    const newDamageResults = { ...FFMessageState.damageResults };
    newDamageResults[target.id] = {
      ...newDamageResults[target.id],
      applied: false,
      wasKOd: false,
      directHitResult: false
    };
    await $message.update({
      flags: {
        [SYSTEM_ID]: {
          state: { damageResults: newDamageResults }
        }
      }
    });
  }
  __name(undoResult, "undoResult");
  function isHit(target) {
    return totalRoll >= getDefenseValue(target);
  }
  __name(isHit, "isHit");
  function openActorSheet(actor2) {
    if (!actor2)
      return;
    actor2?.sheet?.render(true);
  }
  __name(openActorSheet, "openActorSheet");
  const handleToggleDescription = /* @__PURE__ */ __name(() => {
    $$invalidate(4, showDescription = !showDescription);
  }, "handleToggleDescription");
  $$self.$$set = ($$props2) => {
    if ("FFMessage" in $$props2)
      $$invalidate(0, FFMessage = $$props2.FFMessage);
    if ("FFMessageState" in $$props2)
      $$invalidate(16, FFMessageState = $$props2.FFMessageState);
    if ("content" in $$props2)
      $$invalidate(1, content = $$props2.content);
    if ("classes" in $$props2)
      $$invalidate(17, classes = $$props2.classes);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*FFMessage*/
    1) {
      actor = game.actors.get(FFMessage?.actor?._id);
    }
    if ($$self.$$.dirty[0] & /*FFMessageState*/
    65536) {
      $$invalidate(2, isApplyDisabled = /* @__PURE__ */ __name((target) => target.isUnlinked || FFMessageState.damageResults[target.id]?.applied, "isApplyDisabled"));
    }
    if ($$self.$$.dirty[0] & /*FFMessageState*/
    65536) {
      $$invalidate(8, displayDamage = /* @__PURE__ */ __name((target) => FFMessageState.damageResults[target.id]?.damage, "displayDamage"));
    }
    if ($$self.$$.dirty[0] & /*FFMessageState*/
    65536) {
      $$invalidate(7, displayDamageFormula = /* @__PURE__ */ __name((target) => FFMessageState.damageResults[target.id]?.baseDamageFormula, "displayDamageFormula"));
    }
    if ($$self.$$.dirty[0] & /*isApplyDisabled, FFMessageState*/
    65540) {
      $$invalidate(6, displayDirectHitDamage = /* @__PURE__ */ __name((target) => isApplyDisabled(target) ? FFMessageState.damageResults[target.id]?.directHitResult : FFMessageState.damageResults[target.id]?.directHit, "displayDirectHitDamage"));
    }
    if ($$self.$$.dirty[0] & /*FFMessageState*/
    65536) {
      $$invalidate(5, displayDirectHitDisplayFormula = /* @__PURE__ */ __name((target) => FFMessageState.damageResults[target.id]?.directHitDisplayFormula, "displayDirectHitDisplayFormula"));
    }
    if ($$self.$$.dirty[0] & /*FFMessage*/
    1) {
      $$invalidate(18, roll = FFMessage?.roll || 0);
    }
    if ($$self.$$.dirty[0] & /*FFMessage*/
    1) {
      $$invalidate(19, penalty = FFMessage?.extraModifiers?.penalty || 0);
    }
    if ($$self.$$.dirty[0] & /*roll, penalty*/
    786432) {
      totalRoll = roll - penalty;
    }
    if ($$self.$$.dirty[0] & /*FFMessage*/
    1) {
      hasTargets = FFMessage?.hasTargets || false;
    }
  };
  game.settings.get(SYSTEM_ID, "showChatProfileImages");
  return [
    FFMessage,
    content,
    isApplyDisabled,
    targetTokens,
    showDescription,
    displayDirectHitDisplayFormula,
    displayDirectHitDamage,
    displayDamageFormula,
    displayDamage,
    item,
    message,
    applyResult,
    undoResult,
    isHit,
    openActorSheet,
    handleToggleDescription,
    FFMessageState,
    classes,
    roll,
    penalty
  ];
}
__name(instance$15, "instance$15");
class ActionRollChat extends SvelteComponent {
  static {
    __name(this, "ActionRollChat");
  }
  constructor(options) {
    super();
    init$1(
      this,
      options,
      instance$15,
      create_fragment$1c,
      safe_not_equal,
      {
        FFMessage: 0,
        FFMessageState: 16,
        content: 1,
        classes: 17
      },
      null,
      [-1, -1]
    );
  }
}
const get_rightImage_slot_changes = /* @__PURE__ */ __name((dirty) => ({}), "get_rightImage_slot_changes");
const get_rightImage_slot_context = /* @__PURE__ */ __name((ctx) => ({}), "get_rightImage_slot_context");
function create_if_block_2$b(ctx) {
  let div;
  let img;
  let img_src_value;
  let img_alt_value;
  return {
    c() {
      div = element("div");
      img = element("img");
      attr(img, "class", "actor-img svelte-84n429");
      if (!src_url_equal(img.src, img_src_value = /*data*/
      ctx[0].actor.img))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*data*/
      ctx[0].actor.name);
      attr(div, "class", "portrait left svelte-84n429");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, img);
    },
    p(ctx2, dirty) {
      if (dirty & /*data*/
      1 && !src_url_equal(img.src, img_src_value = /*data*/
      ctx2[0].actor.img)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*data*/
      1 && img_alt_value !== (img_alt_value = /*data*/
      ctx2[0].actor.name)) {
        attr(img, "alt", img_alt_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
__name(create_if_block_2$b, "create_if_block_2$b");
function create_if_block$r(ctx) {
  let div;
  let current;
  const rightImage_slot_template = (
    /*#slots*/
    ctx[8].rightImage
  );
  const rightImage_slot = create_slot(
    rightImage_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_rightImage_slot_context
  );
  const rightImage_slot_or_fallback = rightImage_slot || fallback_block(ctx);
  let if_block = (
    /*overlayValue*/
    ctx[1] && create_if_block_1$f(ctx)
  );
  return {
    c() {
      div = element("div");
      rightImage_slot_or_fallback.c();
      if (if_block)
        if_block.c();
      attr(div, "class", "portrait right svelte-84n429");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      {
        rightImage_slot_or_fallback.m(div, null);
      }
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (rightImage_slot) {
        if (rightImage_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            rightImage_slot,
            rightImage_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              rightImage_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_rightImage_slot_changes
            ),
            get_rightImage_slot_context
          );
        }
      } else {
        if (rightImage_slot_or_fallback.p && (!current || dirty & /*data*/
        1)) {
          rightImage_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (
        /*overlayValue*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$f(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(rightImage_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(rightImage_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      rightImage_slot_or_fallback.d(detaching);
      if (if_block)
        if_block.d();
    }
  };
}
__name(create_if_block$r, "create_if_block$r");
function fallback_block(ctx) {
  let img;
  let img_src_value;
  let img_alt_value;
  return {
    c() {
      img = element("img");
      attr(img, "class", "actor-img svelte-84n429");
      if (!src_url_equal(img.src, img_src_value = /*data*/
      ctx[0].item?.img || /*data*/
      ctx[0].actor.img))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*data*/
      ctx[0].item?.name || /*data*/
      ctx[0].actor.name);
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*data*/
      1 && !src_url_equal(img.src, img_src_value = /*data*/
      ctx2[0].item?.img || /*data*/
      ctx2[0].actor.img)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*data*/
      1 && img_alt_value !== (img_alt_value = /*data*/
      ctx2[0].item?.name || /*data*/
      ctx2[0].actor.name)) {
        attr(img, "alt", img_alt_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
__name(fallback_block, "fallback_block");
function create_if_block_1$f(ctx) {
  let div;
  let t;
  return {
    c() {
      div = element("div");
      t = text(
        /*overlayValue*/
        ctx[1]
      );
      attr(div, "class", "overlay svelte-84n429");
      set_style(
        div,
        "margin",
        /*overlayMargin*/
        ctx[4]
      );
      set_style(
        div,
        "font-size",
        /*overlaySize*/
        ctx[3]
      );
      set_style(
        div,
        "color",
        /*overlayColor*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*overlayValue*/
      2)
        set_data(
          t,
          /*overlayValue*/
          ctx2[1]
        );
      if (dirty & /*overlayMargin*/
      16) {
        set_style(
          div,
          "margin",
          /*overlayMargin*/
          ctx2[4]
        );
      }
      if (dirty & /*overlaySize*/
      8) {
        set_style(
          div,
          "font-size",
          /*overlaySize*/
          ctx2[3]
        );
      }
      if (dirty & /*overlayColor*/
      4) {
        set_style(
          div,
          "color",
          /*overlayColor*/
          ctx2[2]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
__name(create_if_block_1$f, "create_if_block_1$f");
function create_fragment$1b(ctx) {
  let div2;
  let div1;
  let div0;
  let t;
  let current;
  let if_block0 = (
    /*showProfileImage*/
    ctx[6] && create_if_block_2$b(ctx)
  );
  let if_block1 = (
    /*showProfileImage*/
    ctx[6] && create_if_block$r(ctx)
  );
  return {
    c() {
      div2 = element("div");
      if (if_block0)
        if_block0.c();
      div1 = element("div");
      div0 = element("div");
      t = text(
        /*title*/
        ctx[5]
      );
      if (if_block1)
        if_block1.c();
      attr(div0, "class", "flavor svelte-84n429");
      attr(div1, "class", "flex4 title-block font-cinzel svelte-84n429");
      attr(div2, "class", "chat-title flexrow justify-vertical mx-sm svelte-84n429");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      if (if_block0)
        if_block0.m(div2, null);
      append(div2, div1);
      append(div1, div0);
      append(div0, t);
      if (if_block1)
        if_block1.m(div2, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*showProfileImage*/
        ctx2[6]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2$b(ctx2);
          if_block0.c();
          if_block0.m(div2, div1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!current || dirty & /*title*/
      32)
        set_data(
          t,
          /*title*/
          ctx2[5]
        );
      if (
        /*showProfileImage*/
        ctx2[6]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*showProfileImage*/
          64) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$r(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div2, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
__name(create_fragment$1b, "create_fragment$1b");
function instance$14($$self, $$props, $$invalidate) {
  let showProfileImage;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { data } = $$props;
  let { overlayValue = "" } = $$props;
  let { overlayColor = "black" } = $$props;
  let { overlaySize = "0.8em" } = $$props;
  let { overlayMargin = "2px 0 0 0" } = $$props;
  let { title = "" } = $$props;
  const message = getContext("message");
  game.system.log.d("ChatTitle - message context:", message);
  game.system.log.d("ChatTitle - data prop:", data);
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("overlayValue" in $$props2)
      $$invalidate(1, overlayValue = $$props2.overlayValue);
    if ("overlayColor" in $$props2)
      $$invalidate(2, overlayColor = $$props2.overlayColor);
    if ("overlaySize" in $$props2)
      $$invalidate(3, overlaySize = $$props2.overlaySize);
    if ("overlayMargin" in $$props2)
      $$invalidate(4, overlayMargin = $$props2.overlayMargin);
    if ("title" in $$props2)
      $$invalidate(5, title = $$props2.title);
    if ("$$scope" in $$props2)
      $$invalidate(7, $$scope = $$props2.$$scope);
  };
  $$invalidate(6, showProfileImage = game.settings.get(SYSTEM_ID, "showChatProfileImages"));
  return [
    data,
    overlayValue,
    overlayColor,
    overlaySize,
    overlayMargin,
    title,
    showProfileImage,
    $$scope,
    slots
  ];
}
__name(instance$14, "instance$14");
class ChatTitle2 extends SvelteComponent {
  static {
    __name(this, "ChatTitle");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$14, create_fragment$1b, safe_not_equal, {
      data: 0,
      overlayValue: 1,
      overlayColor: 2,
      overlaySize: 3,
      overlayMargin: 4,
      title: 5
    });
  }
}
function create_else_block$5(ctx) {
  let chattitle;
  let current;
  chattitle = new ChatTitle2({
    props: {
      title: (
        /*title*/
        ctx[3]
      ),
      data: (
        /*FFMessage*/
        ctx[0]
      ),
      overlayValue: (
        /*$message*/
        ctx[4]?.rolls[0]?.total
      ),
      overlayColor: "var(--off-white)",
      overlaySize: "1rem",
      overlayMargin: "0 0 0 0",
      $$slots: { rightImage: [create_rightImage_slot_1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(chattitle.$$.fragment);
    },
    m(target, anchor) {
      mount_component(chattitle, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const chattitle_changes = {};
      if (dirty & /*title*/
      8)
        chattitle_changes.title = /*title*/
        ctx2[3];
      if (dirty & /*FFMessage*/
      1)
        chattitle_changes.data = /*FFMessage*/
        ctx2[0];
      if (dirty & /*$message*/
      16)
        chattitle_changes.overlayValue = /*$message*/
        ctx2[4]?.rolls[0]?.total;
      if (dirty & /*$$scope*/
      2048) {
        chattitle_changes.$$scope = { dirty, ctx: ctx2 };
      }
      chattitle.$set(chattitle_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(chattitle.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(chattitle.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(chattitle, detaching);
    }
  };
}
__name(create_else_block$5, "create_else_block$5");
function create_if_block$q(ctx) {
  let chattitle;
  let current;
  chattitle = new ChatTitle2({
    props: {
      title: (
        /*title*/
        ctx[3]
      ),
      data: (
        /*FFMessage*/
        ctx[0]
      ),
      overlayValue: (
        /*$message*/
        ctx[4]?.rolls[0]?.total
      ),
      overlayColor: "var(--off-white)",
      overlaySize: "0.8rem",
      $$slots: { rightImage: [create_rightImage_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(chattitle.$$.fragment);
    },
    m(target, anchor) {
      mount_component(chattitle, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const chattitle_changes = {};
      if (dirty & /*title*/
      8)
        chattitle_changes.title = /*title*/
        ctx2[3];
      if (dirty & /*FFMessage*/
      1)
        chattitle_changes.data = /*FFMessage*/
        ctx2[0];
      if (dirty & /*$message*/
      16)
        chattitle_changes.overlayValue = /*$message*/
        ctx2[4]?.rolls[0]?.total;
      if (dirty & /*$$scope*/
      2048) {
        chattitle_changes.$$scope = { dirty, ctx: ctx2 };
      }
      chattitle.$set(chattitle_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(chattitle.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(chattitle.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(chattitle, detaching);
    }
  };
}
__name(create_if_block$q, "create_if_block$q");
function create_rightImage_slot_1(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = `${" "}`;
      attr(div, "slot", "rightImage");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
__name(create_rightImage_slot_1, "create_rightImage_slot_1");
function create_rightImage_slot(ctx) {
  let meteor;
  let current;
  meteor = new Meteor({
    props: {
      size: "28",
      fill: "var(--ff-border-color)",
      innerFill: "var(--message-color)",
      innerOpacity: "1",
      opacity: "1"
    }
  });
  return {
    c() {
      create_component(meteor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(meteor, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(meteor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(meteor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(meteor, detaching);
    }
  };
}
__name(create_rightImage_slot, "create_rightImage_slot");
function create_fragment$1a(ctx) {
  let div2;
  let div0;
  let current_block_type_index;
  let if_block;
  let div1;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block$q, create_else_block$5];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*FFMessage*/
      ctx2[0]?.isCritical
    )
      return 0;
    return 1;
  }
  __name(select_block_type, "select_block_type");
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      if_block.c();
      div1 = element("div");
      attr(div0, "class", "col");
      attr(div0, "role", "button");
      attr(div1, "class", "col content");
      attr(
        div1,
        "style",
        /*style*/
        ctx[2]
      );
      attr(div2, "class", "flexcol pointer");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      if_blocks[current_block_type_index].m(div0, null);
      append(div2, div1);
      div1.innerHTML = /*content*/
      ctx[1];
      current = true;
      if (!mounted) {
        dispose = listen(
          div0,
          "click",
          /*toggleContent*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div0, null);
      }
      if (!current || dirty & /*content*/
      2)
        div1.innerHTML = /*content*/
        ctx2[1];
      if (!current || dirty & /*style*/
      4) {
        attr(
          div1,
          "style",
          /*style*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if_blocks[current_block_type_index].d();
      mounted = false;
      dispose();
    }
  };
}
__name(create_fragment$1a, "create_fragment$1a");
function instance$13($$self, $$props, $$invalidate) {
  let title;
  let height;
  let style;
  let $message;
  let { FFMessage } = $$props;
  let { content } = $$props;
  let { enableToggle = true } = $$props;
  let isContentVisible = false;
  const message = getContext("message");
  component_subscribe($$self, message, (value) => $$invalidate(4, $message = value));
  onMount(async () => {
  });
  function toggleContent() {
    if (enableToggle) {
      $$invalidate(8, isContentVisible = !isContentVisible);
    }
  }
  __name(toggleContent, "toggleContent");
  $$self.$$set = ($$props2) => {
    if ("FFMessage" in $$props2)
      $$invalidate(0, FFMessage = $$props2.FFMessage);
    if ("content" in $$props2)
      $$invalidate(1, content = $$props2.content);
    if ("enableToggle" in $$props2)
      $$invalidate(7, enableToggle = $$props2.enableToggle);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*FFMessage*/
    1) {
      $$invalidate(3, title = FFMessage.flavor);
    }
    if ($$self.$$.dirty & /*isContentVisible*/
    256) {
      $$invalidate(9, height = isContentVisible ? "1000px" : "0");
    }
    if ($$self.$$.dirty & /*height*/
    512) {
      $$invalidate(2, style = `max-height: ${height}; overflow: hidden; transition: max-height 0.3s ease;`);
    }
  };
  game.settings.get(SYSTEM_ID, "showChatProfileImages");
  return [
    FFMessage,
    content,
    style,
    title,
    $message,
    message,
    toggleContent,
    enableToggle,
    isContentVisible,
    height
  ];
}
__name(instance$13, "instance$13");
class AttributeRollChat extends SvelteComponent {
  static {
    __name(this, "AttributeRollChat");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$13, create_fragment$1a, safe_not_equal, {
      FFMessage: 0,
      content: 1,
      enableToggle: 7
    });
  }
}
const ChatComponents = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ActionRollChat,
  AttributeRollChat,
  EquipmentChat,
  RollChat
}, Symbol.toStringTag, { value: "Module" }));
function create_if_block$p(ctx) {
  let switch_instance;
  let div;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*$$props*/
    ctx[6]
  ];
  var switch_value = ChatComponents[
    /*FFMessage*/
    ctx[0].chatTemplate
  ];
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    if (dirty !== void 0 && dirty & /*$$props*/
    64) {
      switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*$$props*/
        ctx2[6]
      )]));
    }
    return { props: switch_instance_props };
  }
  __name(switch_props, "switch_props");
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      div = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
      set_style(div, "display", "contents");
      set_style(
        div,
        "--message-color",
        /*messageColor*/
        ctx[2]
      );
      set_style(
        div,
        "--message-contrast",
        /*messageContrast*/
        ctx[3]
      );
      set_style(
        div,
        "--message-color-rgb",
        /*messageColorRGB*/
        ctx[4]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (switch_instance)
        mount_component(switch_instance, div, null);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*messageColor*/
      4) {
        set_style(
          div,
          "--message-color",
          /*messageColor*/
          ctx2[2]
        );
      }
      if (dirty & /*messageContrast*/
      8) {
        set_style(
          div,
          "--message-contrast",
          /*messageContrast*/
          ctx2[3]
        );
      }
      if (dirty & /*messageColorRGB*/
      16) {
        set_style(
          div,
          "--message-color-rgb",
          /*messageColorRGB*/
          ctx2[4]
        );
      }
      if (dirty & /*FFMessage*/
      1 && switch_value !== (switch_value = ChatComponents[
        /*FFMessage*/
        ctx2[0].chatTemplate
      ])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
            detach(div);
          });
          check_outros();
        }
        if (switch_value) {
          insert(switch_instance_anchor.parentNode, div, switch_instance_anchor);
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*$$props*/
        64 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*$$props*/
          ctx2[6]
        )]) : {};
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (detaching && switch_instance)
        detach(div);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
__name(create_if_block$p, "create_if_block$p");
function create_fragment$19(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*isReady*/
    ctx[1] && create_if_block$p(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*isReady*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*isReady*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$p(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
__name(create_fragment$19, "create_fragment$19");
function instance$12($$self, $$props, $$invalidate) {
  let $actor;
  let { FFMessage } = $$props;
  let { messageId } = $$props;
  let isReady = false;
  let actor = new TJSDocument(
    void 0,
    {
      delete: () => {
      }
    }
  );
  component_subscribe($$self, actor, (value) => $$invalidate(8, $actor = value));
  let message = new TJSDocument(void 0);
  const sourceActor = game.actors.get(FFMessage.actor._id);
  const sourceMessage = game.messages.get(messageId);
  actor.set(sourceActor);
  message.set(sourceMessage);
  setContext("sourceActor", actor);
  setContext("message", message);
  let messageColor;
  let messageContrast;
  let messageColorRGB;
  onMount(() => {
    $$invalidate(1, isReady = true);
  });
  $$self.$$set = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("FFMessage" in $$new_props)
      $$invalidate(0, FFMessage = $$new_props.FFMessage);
    if ("messageId" in $$new_props)
      $$invalidate(7, messageId = $$new_props.messageId);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$actor*/
    256) {
      if ($actor) {
        const ownerColor = getActorOwner($actor).color;
        const colorCalc = new ColourContrastCalculator(ownerColor);
        const cssVars = colorCalc.getCSSVariables();
        $$invalidate(2, messageColor = cssVars.color);
        $$invalidate(3, messageContrast = cssVars.contrast);
        $$invalidate(4, messageColorRGB = cssVars.rgb);
      }
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    FFMessage,
    isReady,
    messageColor,
    messageContrast,
    messageColorRGB,
    actor,
    $$props,
    messageId,
    $actor
  ];
}
__name(instance$12, "instance$12");
class FFChat extends SvelteComponent {
  static {
    __name(this, "FFChat");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$12, create_fragment$19, safe_not_equal, { FFMessage: 0, messageId: 7 });
  }
}
function renderChatMessage() {
  Hooks.on("renderChatMessage", (message, html) => {
    console.log("renderChatMessage HOOK TRIGGERED");
    const FFMessage = message.getFlag(SYSTEM_ID, "data");
    const FFMessageState = message.getFlag(SYSTEM_ID, "state");
    game.system.log.p(">>>>>> race renderChatMessage HOOK TRIGGERED <<<<<<", {
      messageId: message.id,
      hasFFMessage: !!FFMessage,
      flags: message.flags[SYSTEM_ID]
    });
    const messageHeader = html.find(".message-header");
    if (messageHeader.length) {
      messageHeader.prepend('<div class="texture"></div>');
    }
    if (message.flags[SYSTEM_ID]?.css) {
      html.addClass(message.flags[SYSTEM_ID].css);
    }
    if (typeof FFMessage === "object") {
      const originalContent = html[0].innerHTML;
      const tempDiv = document.createElement("div");
      tempDiv.innerHTML = originalContent;
      const header = tempDiv.querySelector(".message-header");
      if (header) {
        const sourceActor = game.actors.get(FFMessage.actor._id);
        const actorOwner = getActorOwner(sourceActor);
        const messageSender = header.querySelector(".message-sender");
        if (messageSender) {
          messageSender.textContent = actorOwner.name;
        }
        if (messageSender.length) {
          game.system.log.p("messageSender", messageSender);
          messageSender[0].textContent = actorOwner.name;
        }
        const ownerColor = actorOwner.color;
        const colorCalc = new ColourContrastCalculator(ownerColor);
        const cssVars = colorCalc.getCSSVariables();
        header.style.setProperty("--message-color", cssVars.color);
        header.style.setProperty("--message-contrast", cssVars.contrast);
        header.style.setProperty("--message-color-rgb", cssVars.rgb);
      }
      let content;
      if (["AttributeRollChat", "ActionRollChat"].includes(FFMessage.chatTemplate)) {
        const messageContent = tempDiv.querySelector(".message-content");
        const flavorText = tempDiv.querySelector(".flavor-text");
        const contentToPass = `
        ${flavorText ? `<span class="flavor-text">${flavorText.innerHTML}</span>` : ""}
        ${messageContent ? messageContent.innerHTML : ""}
      `;
        if (header) {
          const headerFlavorText = header.querySelector(".flavor-text");
          if (headerFlavorText) {
            headerFlavorText.remove();
          }
          html[0].innerHTML = header.outerHTML;
        }
        content = contentToPass;
      } else {
        if (header) {
          const originalHeader = html[0].querySelector(".message-header");
          if (originalHeader) {
            originalHeader.outerHTML = header.outerHTML;
          }
        }
        content = originalContent;
      }
      html.addClass(SYSTEM_CODE);
      html.addClass("leather");
      message._svelteComponent = new FFChat({
        target: html[0],
        props: {
          classes: "leather",
          FFMessage,
          FFMessageState,
          messageId: message._id,
          content
        }
      });
    }
  });
}
__name(renderChatMessage, "renderChatMessage");
function renderCombatTracker() {
  Hooks.on("renderCombatTracker", (app, html, data) => {
    const isCombatActive = !!game.combat?.started;
    const updateDebounced = Timing.debounce(async (combatant, value) => {
      const newInitiative = parseInt(value, 10);
      if (!isNaN(newInitiative) && combatant) {
        await combatant.update({ initiative: newInitiative });
      }
    }, 600);
    $(html).find(".combatant").each((index, element2) => {
      const combatantId = $(element2).data("combatant-id");
      const combatant = game.combat?.combatants.get(combatantId);
      if (combatant && !isCombatActive) {
        const $initiative = $(element2).find(".initiative");
        $initiative.attr("contenteditable", "true");
        $initiative.on("input", (event) => {
          updateDebounced(combatant, $(event.currentTarget).text());
        });
        $initiative.on("dblclick contextmenu", (event) => {
          event.stopPropagation();
          event.preventDefault();
        });
        $initiative.on("blur", async (event) => {
          const newInitiative = parseInt($(event.currentTarget).text(), 10);
          if (!isNaN(newInitiative) && combatant) {
            await combatant.update({ initiative: newInitiative });
          }
        });
      }
    });
    if (data.combat?.turns?.length) {
      Hooks.call("updateCombatant", data.combat.turns[0], {});
    }
  });
}
__name(renderCombatTracker, "renderCombatTracker");
function updateCombatant() {
  Hooks.on("updateCombatant", async (combatant, updateData) => {
    const combat = combatant.parent;
    if (!combat) {
      return;
    }
    const turns = combat.turns;
    turns.sort((a, b) => {
      const aIsNPC = a.actor?.type === "NPC";
      const bIsNPC = b.actor?.type === "NPC";
      if (aIsNPC !== bIsNPC)
        return aIsNPC ? 1 : -1;
      const ia = Number.isNumeric(a.initiative) ? a.initiative : -9999;
      const ib = Number.isNumeric(b.initiative) ? b.initiative : -9999;
      return ib - ia;
    });
    const firstNPCIndex = turns.findIndex((t) => t.actor?.type === "NPC");
    await combat.update({ turns });
    if (firstNPCIndex > 0 && firstNPCIndex < turns.length) {
      const tracker = ui.combat;
      if (!tracker) {
        return;
      }
      const combatants = tracker.element.find(".combatant");
      combatants.each((index, element2) => {
        const $element = $(element2);
        $element.removeClass("npc-group-start pc-group-end");
        if (index === firstNPCIndex) {
          $element.addClass("npc-group-start");
        } else if (index === firstNPCIndex - 1) {
          $element.addClass("pc-group-end");
        }
      });
    }
  });
}
__name(updateCombatant, "updateCombatant");
function getDefaultStatusEffects() {
  return [
    {
      id: "dead",
      name: localize$1("statusEffects.dead.name"),
      icon: "icons/svg/skull.svg",
      img: "icons/svg/skull.svg",
      description: localize$1("statusEffects.dead.description"),
      flags: { [SYSTEM_ID]: { periodic: false, special: false } },
      changes: []
    },
    {
      id: "comatose",
      name: localize$1("statusEffects.comatose.name"),
      icon: `systems/${SYSTEM_ID}/assets/icons/status/coma.svg`,
      img: `systems/${SYSTEM_ID}/assets/icons/status/coma.svg`,
      description: localize$1("statusEffects.comatose.description"),
      flags: { [SYSTEM_ID]: { periodic: false, special: false } },
      changes: []
    },
    {
      id: "ko",
      name: localize$1("statusEffects.ko.name"),
      icon: "icons/svg/unconscious.svg",
      img: "icons/svg/unconscious.svg",
      description: localize$1("statusEffects.ko.description"),
      flags: { [SYSTEM_ID]: { periodic: false, special: false } },
      changes: []
    },
    {
      id: "surprised",
      name: localize$1("statusEffects.surprised.name"),
      icon: "icons/svg/stoned.svg",
      img: "icons/svg/stoned.svg",
      description: localize$1("statusEffects.surprised.description"),
      flags: { [SYSTEM_ID]: { periodic: false, special: false } },
      changes: []
    },
    {
      id: "brink",
      name: localize$1("statusEffects.brink.name"),
      icon: `systems/${SYSTEM_ID}/assets/icons/status/supine.svg`,
      img: `systems/${SYSTEM_ID}/assets/icons/status/supine.svg`,
      description: localize$1("statusEffects.brink.description"),
      flags: { [SYSTEM_ID]: { periodic: false, special: false } },
      changes: []
    },
    {
      id: "bind",
      name: localize$1("statusEffects.bind.name"),
      icon: "icons/svg/net.svg",
      img: "icons/svg/net.svg",
      description: localize$1("statusEffects.bind.description"),
      flags: { [SYSTEM_ID]: { periodic: false, special: false } },
      changes: []
    },
    {
      id: "enmity",
      name: localize$1("statusEffects.enmity.name"),
      icon: `systems/${SYSTEM_ID}/assets/icons/status/enrage.svg`,
      img: `systems/${SYSTEM_ID}/assets/icons/status/enrage.svg`,
      description: localize$1("statusEffects.enmity.description"),
      flags: { [SYSTEM_ID]: { periodic: false, special: false } },
      changes: []
    },
    {
      id: "weakness",
      name: localize$1("statusEffects.weakness.name"),
      icon: `systems/${SYSTEM_ID}/assets/icons/status/crutch.svg`,
      img: `systems/${SYSTEM_ID}/assets/icons/status/crutch.svg`,
      description: localize$1("statusEffects.weakness.description"),
      flags: { [SYSTEM_ID]: { periodic: false, special: false } },
      changes: []
    },
    {
      id: "stun",
      name: localize$1("statusEffects.stun.name"),
      icon: "icons/svg/daze.svg",
      img: "icons/svg/daze.svg",
      description: localize$1("statusEffects.stun.description"),
      flags: { [SYSTEM_ID]: { periodic: false, special: false } },
      changes: []
    },
    {
      id: "prone",
      name: localize$1("statusEffects.prone.name"),
      icon: `systems/${SYSTEM_ID}/assets/icons/status/prone.svg`,
      img: `systems/${SYSTEM_ID}/assets/icons/status/prone.svg`,
      description: localize$1("statusEffects.prone.description"),
      flags: { [SYSTEM_ID]: { periodic: false, special: false } },
      changes: []
    },
    {
      id: "blind",
      name: localize$1("statusEffects.blind.name"),
      description: localize$1("statusEffects.blind.description"),
      icon: `systems/${SYSTEM_ID}/assets/icons/status/blindfold.svg`,
      img: `systems/${SYSTEM_ID}/assets/icons/status/blindfold.svg`,
      flags: { [SYSTEM_ID]: { periodic: false, special: false } },
      changes: []
    },
    {
      id: "slow",
      name: localize$1("statusEffects.slow.name"),
      description: localize$1("statusEffects.slow.description"),
      icon: `systems/${SYSTEM_ID}/assets/icons/status/slowed.svg`,
      img: `systems/${SYSTEM_ID}/assets/icons/status/slowed.svg`,
      flags: { [SYSTEM_ID]: { periodic: false, special: false } },
      changes: [
        {
          key: "system.attributes.secondary.spd.val",
          value: 0.5,
          mode: activeEffectModes.find((mode) => mode.label === "multiply").value,
          priority: 1
        },
        {
          key: "system.globalCheckMod",
          value: -2,
          mode: activeEffectModes.find((mode) => mode.label === "add").value,
          priority: 1
        }
      ]
    },
    {
      id: "transcendent",
      name: localize$1("statusEffects.transcendent.name"),
      icon: "icons/svg/ice-aura.svg",
      img: "icons/svg/ice-aura.svg",
      description: localize$1("statusEffects.transcendent.description"),
      flags: { [SYSTEM_ID]: { periodic: false, special: true } },
      changes: []
    },
    {
      id: "focus",
      name: localize$1("statusEffects.focus.name"),
      icon: "icons/svg/eye.svg",
      img: "icons/svg/eye.svg",
      description: localize$1("statusEffects.focus.description"),
      flags: { [SYSTEM_ID]: { periodic: false, special: true } },
      changes: []
    }
  ];
}
__name(getDefaultStatusEffects, "getDefaultStatusEffects");
class FFTokenHUD extends TokenHUD {
  static {
    __name(this, "FFTokenHUD");
  }
  /** @type {Array} The default status effects for tokens */
  defaultStatusEffects;
  /**
   * Initialize the token HUD
   * @param {...any} args - Arguments passed to the constructor
   */
  constructor(...args) {
    super(...args);
    if (typeof this.defaultStatusEffects === "undefined") {
      console.log("defaultStatusEffects not found, getting default status effects");
      this.defaultStatusEffects = getDefaultStatusEffects();
    }
    const that = this;
    Handlebars.registerHelper("showStatusEffectNames", function() {
      return game.settings.get(`${SYSTEM_ID}`, "show-status-effect-names");
    });
    Handlebars.registerHelper("checkStatusAndEffect", function(title) {
      return title && game.settings.get(`${SYSTEM_ID}`, "show-status-effect-names");
    });
    Handlebars.registerHelper("getDescription", function(status) {
      return that.defaultStatusEffects.find((i) => i.id == [status.id])?.description || status.title;
    });
    Handlebars.registerHelper("titleCssClass", function(cond) {
      return game.settings.get(`${SYSTEM_ID}`, "show-status-effect-names") ? "show-title" : "hide-title";
    });
  }
  /**
   * Get the default options for the token HUD
   * @return {object} The default options
   */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      template: `systems/${SYSTEM_ID}/src/extensions/templates/token-hud.html`
    });
  }
}
function canvasReady$1() {
  Hooks.on("canvasReady", () => {
    CONFIG.statusEffects = getDefaultStatusEffects();
    canvas.hud.token = new FFTokenHUD({ defaultStatusEffects: CONFIG.statusEffects });
  });
}
__name(canvasReady$1, "canvasReady$1");
function backInOut(t) {
  const s = 1.70158 * 1.525;
  if ((t *= 2) < 1)
    return 0.5 * (t * t * ((s + 1) * t - s));
  return 0.5 * ((t -= 2) * t * ((s + 1) * t + s) + 2);
}
__name(backInOut, "backInOut");
function backIn(t) {
  const s = 1.70158;
  return t * t * ((s + 1) * t - s);
}
__name(backIn, "backIn");
function backOut(t) {
  const s = 1.70158;
  return --t * t * ((s + 1) * t + s) + 1;
}
__name(backOut, "backOut");
function bounceOut(t) {
  const a = 4 / 11;
  const b = 8 / 11;
  const c = 9 / 10;
  const ca = 4356 / 361;
  const cb = 35442 / 1805;
  const cc = 16061 / 1805;
  const t2 = t * t;
  return t < a ? 7.5625 * t2 : t < b ? 9.075 * t2 - 9.9 * t + 3.4 : t < c ? ca * t2 - cb * t + cc : 10.8 * t * t - 20.52 * t + 10.72;
}
__name(bounceOut, "bounceOut");
function bounceInOut(t) {
  return t < 0.5 ? 0.5 * (1 - bounceOut(1 - t * 2)) : 0.5 * bounceOut(t * 2 - 1) + 0.5;
}
__name(bounceInOut, "bounceInOut");
function bounceIn(t) {
  return 1 - bounceOut(1 - t);
}
__name(bounceIn, "bounceIn");
function circInOut(t) {
  if ((t *= 2) < 1)
    return -0.5 * (Math.sqrt(1 - t * t) - 1);
  return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
}
__name(circInOut, "circInOut");
function circIn(t) {
  return 1 - Math.sqrt(1 - t * t);
}
__name(circIn, "circIn");
function circOut(t) {
  return Math.sqrt(1 - --t * t);
}
__name(circOut, "circOut");
function cubicInOut(t) {
  return t < 0.5 ? 4 * t * t * t : 0.5 * Math.pow(2 * t - 2, 3) + 1;
}
__name(cubicInOut, "cubicInOut");
function cubicIn(t) {
  return t * t * t;
}
__name(cubicIn, "cubicIn");
function cubicOut(t) {
  const f = t - 1;
  return f * f * f + 1;
}
__name(cubicOut, "cubicOut");
function elasticInOut(t) {
  return t < 0.5 ? 0.5 * Math.sin(13 * Math.PI / 2 * 2 * t) * Math.pow(2, 10 * (2 * t - 1)) : 0.5 * Math.sin(-13 * Math.PI / 2 * (2 * t - 1 + 1)) * Math.pow(2, -10 * (2 * t - 1)) + 1;
}
__name(elasticInOut, "elasticInOut");
function elasticIn(t) {
  return Math.sin(13 * t * Math.PI / 2) * Math.pow(2, 10 * (t - 1));
}
__name(elasticIn, "elasticIn");
function elasticOut(t) {
  return Math.sin(-13 * (t + 1) * Math.PI / 2) * Math.pow(2, -10 * t) + 1;
}
__name(elasticOut, "elasticOut");
function expoInOut(t) {
  return t === 0 || t === 1 ? t : t < 0.5 ? 0.5 * Math.pow(2, 20 * t - 10) : -0.5 * Math.pow(2, 10 - t * 20) + 1;
}
__name(expoInOut, "expoInOut");
function expoIn(t) {
  return t === 0 ? t : Math.pow(2, 10 * (t - 1));
}
__name(expoIn, "expoIn");
function expoOut(t) {
  return t === 1 ? t : 1 - Math.pow(2, -10 * t);
}
__name(expoOut, "expoOut");
function quadInOut(t) {
  t /= 0.5;
  if (t < 1)
    return 0.5 * t * t;
  t--;
  return -0.5 * (t * (t - 2) - 1);
}
__name(quadInOut, "quadInOut");
function quadIn(t) {
  return t * t;
}
__name(quadIn, "quadIn");
function quadOut(t) {
  return -t * (t - 2);
}
__name(quadOut, "quadOut");
function quartInOut(t) {
  return t < 0.5 ? 8 * Math.pow(t, 4) : -8 * Math.pow(t - 1, 4) + 1;
}
__name(quartInOut, "quartInOut");
function quartIn(t) {
  return Math.pow(t, 4);
}
__name(quartIn, "quartIn");
function quartOut(t) {
  return Math.pow(t - 1, 3) * (1 - t) + 1;
}
__name(quartOut, "quartOut");
function quintInOut(t) {
  if ((t *= 2) < 1)
    return 0.5 * t * t * t * t * t;
  return 0.5 * ((t -= 2) * t * t * t * t + 2);
}
__name(quintInOut, "quintInOut");
function quintIn(t) {
  return t * t * t * t * t;
}
__name(quintIn, "quintIn");
function quintOut(t) {
  return --t * t * t * t * t + 1;
}
__name(quintOut, "quintOut");
function sineInOut(t) {
  return -0.5 * (Math.cos(Math.PI * t) - 1);
}
__name(sineInOut, "sineInOut");
function sineIn(t) {
  const v = Math.cos(t * Math.PI * 0.5);
  if (Math.abs(v) < 1e-14)
    return 1;
  else
    return 1 - v;
}
__name(sineIn, "sineIn");
function sineOut(t) {
  return Math.sin(t * Math.PI / 2);
}
__name(sineOut, "sineOut");
const svelteEasingFunc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  backIn,
  backInOut,
  backOut,
  bounceIn,
  bounceInOut,
  bounceOut,
  circIn,
  circInOut,
  circOut,
  cubicIn,
  cubicInOut,
  cubicOut,
  elasticIn,
  elasticInOut,
  elasticOut,
  expoIn,
  expoInOut,
  expoOut,
  linear: identity,
  quadIn,
  quadInOut,
  quadOut,
  quartIn,
  quartInOut,
  quartOut,
  quintIn,
  quintInOut,
  quintOut,
  sineIn,
  sineInOut,
  sineOut
}, Symbol.toStringTag, { value: "Module" }));
class StyleParse {
  static {
    __name(this, "StyleParse");
  }
  static #regexPixels = /(\d+)\s*px/;
  /**
   * Parses a pixel string / computed styles. Ex. `100px` returns `100`.
   *
   * @param {string}   value - Value to parse.
   *
   * @returns {number|undefined} The integer component of a pixel string.
   */
  static pixels(value) {
    if (typeof value !== "string") {
      return void 0;
    }
    const isPixels = this.#regexPixels.test(value);
    const number = parseInt(value);
    return isPixels && Number.isFinite(number) ? number : void 0;
  }
  /**
   * Returns the pixel value for `1rem` based on the root document element. You may apply an optional multiplier.
   *
   * @param {number} [multiplier=1] - Optional multiplier to apply to `rem` pixel value; default: 1.
   *
   * @param {object} [options] - Optional parameters.
   *
   * @param {Document} [options.targetDocument=document] The target DOM {@link Document} if different from the main
   *        browser global `document`.
   *
   * @returns {number} The pixel value for `1rem` with or without a multiplier based on the root document element.
   */
  static remPixels(multiplier = 1, { targetDocument = document } = {}) {
    return targetDocument?.documentElement ? multiplier * parseFloat(globalThis.getComputedStyle(targetDocument.documentElement).fontSize) : void 0;
  }
}
class TJSStyleManager {
  static {
    __name(this, "TJSStyleManager");
  }
  /** @type {CSSStyleRule} */
  #cssRule;
  /** @type {string} */
  #docKey;
  /** @type {string} */
  #selector;
  /** @type {HTMLStyleElement} */
  #styleElement;
  /** @type {number} */
  #version;
  /**
   *
   * @param {object}   opts - Options.
   *
   * @param {string}   opts.docKey - Required key providing a link to a specific style sheet element.
   *
   * @param {string}   [opts.selector=:root] - Selector element.
   *
   * @param {Document} [opts.document] - Target document to load styles into.
   *
   * @param {number}   [opts.version] - An integer representing the version / level of styles being managed.
   */
  constructor({ docKey, selector = ":root", document: document2 = globalThis.document, version: version2 } = {}) {
    if (typeof docKey !== "string") {
      throw new TypeError(`StyleManager error: 'docKey' is not a string.`);
    }
    if (Object.prototype.toString.call(document2) !== "[object HTMLDocument]") {
      throw new TypeError(`TJSStyleManager error: 'document' is not an instance of HTMLDocument.`);
    }
    if (typeof selector !== "string") {
      throw new TypeError(`StyleManager error: 'selector' is not a string.`);
    }
    if (version2 !== void 0 && !Number.isSafeInteger(version2) && version2 < 1) {
      throw new TypeError(`StyleManager error: 'version' is defined and is not a positive integer >= 1.`);
    }
    this.#selector = selector;
    this.#docKey = docKey;
    this.#version = version2;
    if (document2[this.#docKey] === void 0) {
      this.#styleElement = document2.createElement("style");
      document2.head.append(this.#styleElement);
      this.#styleElement._STYLE_MANAGER_VERSION = version2;
      this.#styleElement.sheet.insertRule(`${selector} {}`, 0);
      this.#cssRule = this.#styleElement.sheet.cssRules[0];
      document2[docKey] = this.#styleElement;
    } else {
      this.#styleElement = document2[docKey];
      this.#cssRule = this.#styleElement.sheet.cssRules[0];
      if (version2) {
        const existingVersion = this.#styleElement._STYLE_MANAGER_VERSION ?? 0;
        if (version2 > existingVersion) {
          this.#cssRule.style.cssText = "";
        }
      }
    }
  }
  /**
   * @returns {string} Provides an accessor to get the `cssText` for the style sheet.
   */
  get cssText() {
    return this.#cssRule.style.cssText;
  }
  /**
   * @returns {number} Returns the version of this instance.
   */
  get version() {
    return this.#version;
  }
  /**
   * Provides a copy constructor to duplicate an existing TJSStyleManager instance into a new document.
   *
   * Note: This is used to support the `PopOut` module.
   *
   * @param {Document} [document] Target browser document to clone into.
   *
   * @returns {TJSStyleManager} New style manager instance.
   */
  clone(document2 = globalThis.document) {
    const newStyleManager = new TJSStyleManager({
      selector: this.#selector,
      docKey: this.#docKey,
      document: document2,
      version: this.#version
    });
    newStyleManager.#cssRule.style.cssText = this.#cssRule.style.cssText;
    return newStyleManager;
  }
  get() {
    const cssText = this.#cssRule.style.cssText;
    const result = {};
    if (cssText !== "") {
      for (const entry of cssText.split(";")) {
        if (entry !== "") {
          const values = entry.split(":");
          result[values[0].trim()] = values[1];
        }
      }
    }
    return result;
  }
  /**
   * Gets a particular CSS variable.
   *
   * @param {string}   key - CSS variable property key.
   *
   * @returns {string} Returns CSS variable value.
   */
  getProperty(key) {
    if (typeof key !== "string") {
      throw new TypeError(`StyleManager error: 'key' is not a string.`);
    }
    return this.#cssRule.style.getPropertyValue(key);
  }
  /**
   * Set rules by property / value; useful for CSS variables.
   *
   * @param {{ [key: string]: string }}  rules - An object with property / value string pairs to load.
   *
   * @param {boolean}                 [overwrite=true] - When true overwrites any existing values.
   */
  setProperties(rules, overwrite = true) {
    if (!isObject(rules)) {
      throw new TypeError(`StyleManager error: 'rules' is not an object.`);
    }
    if (typeof overwrite !== "boolean") {
      throw new TypeError(`StyleManager error: 'overwrite' is not a boolean.`);
    }
    if (overwrite) {
      for (const [key, value] of Object.entries(rules)) {
        this.#cssRule.style.setProperty(key, value);
      }
    } else {
      for (const [key, value] of Object.entries(rules)) {
        if (this.#cssRule.style.getPropertyValue(key) === "") {
          this.#cssRule.style.setProperty(key, value);
        }
      }
    }
  }
  /**
   * Sets a particular property.
   *
   * @param {string}   key - CSS variable property key.
   *
   * @param {string}   value - CSS variable value.
   *
   * @param {boolean}  [overwrite=true] - Overwrite any existing value.
   */
  setProperty(key, value, overwrite = true) {
    if (typeof key !== "string") {
      throw new TypeError(`StyleManager error: 'key' is not a string.`);
    }
    if (typeof value !== "string") {
      throw new TypeError(`StyleManager error: 'value' is not a string.`);
    }
    if (typeof overwrite !== "boolean") {
      throw new TypeError(`StyleManager error: 'overwrite' is not a boolean.`);
    }
    if (overwrite) {
      this.#cssRule.style.setProperty(key, value);
    } else {
      if (this.#cssRule.style.getPropertyValue(key) === "") {
        this.#cssRule.style.setProperty(key, value);
      }
    }
  }
  /**
   * Removes the property keys specified. If `keys` is an iterable list then all property keys in the list are removed.
   *
   * @param {Iterable<string>} keys - The property keys to remove.
   */
  removeProperties(keys) {
    if (!isIterable(keys)) {
      throw new TypeError(`StyleManager error: 'keys' is not an iterable list.`);
    }
    for (const key of keys) {
      if (typeof key === "string") {
        this.#cssRule.style.removeProperty(key);
      }
    }
  }
  /**
   * Removes a particular CSS variable.
   *
   * @param {string}   key - CSS variable property key.
   *
   * @returns {string} CSS variable value when removed.
   */
  removeProperty(key) {
    if (typeof key !== "string") {
      throw new TypeError(`StyleManager error: 'key' is not a string.`);
    }
    return this.#cssRule.style.removeProperty(key);
  }
}
const cssVariables = new TJSStyleManager({ docKey: "#__trl-root-styles", version: 1 });
class CrossWindow {
  static {
    __name(this, "CrossWindow");
  }
  /**
   * @private
   */
  constructor() {
  }
  // eslint-disable-line no-useless-constructor
  /**
   * Class names for all focusable element types.
   *
   * @type {string[]}
   */
  static #FocusableElementClassNames = [
    "HTMLAnchorElement",
    "HTMLButtonElement",
    "HTMLDetailsElement",
    "HTMLEmbedElement",
    "HTMLIFrameElement",
    "HTMLInputElement",
    "HTMLObjectElement",
    "HTMLSelectElement",
    "HTMLTextAreaElement"
  ];
  /**
   * DOM nodes with defined `ownerDocument` property.
   *
   * @type {Set<number>}
   */
  static #NodesWithOwnerDocument = /* @__PURE__ */ new Set([
    Node.ELEMENT_NODE,
    Node.TEXT_NODE,
    Node.COMMENT_NODE,
    Node.DOCUMENT_FRAGMENT_NODE
  ]);
  // Various UI Event sets for duck typing by constructor name.
  /**
   * Duck typing class names for pointer events.
   *
   * @type {Set<string>}
   */
  static #PointerEventSet = /* @__PURE__ */ new Set(["MouseEvent", "PointerEvent"]);
  /**
   * Duck typing class names for all UIEvents.
   *
   * @type {Set<string>}
   */
  static #UIEventSet = /* @__PURE__ */ new Set([
    "UIEvent",
    "FocusEvent",
    "MouseEvent",
    "WheelEvent",
    "KeyboardEvent",
    "PointerEvent",
    "TouchEvent",
    "InputEvent",
    "CompositionEvent",
    "DragEvent"
  ]);
  /**
   * Duck typing class names for events considered as user input.
   *
   * @type {Set<string>}
   */
  static #UserInputEventSet = /* @__PURE__ */ new Set(["KeyboardEvent", "MouseEvent", "PointerEvent"]);
  /**
   * Internal options used by `#checkDOMInstanceType` when retrieving the Window reference from a Node that doesn't
   * define `ownerDocument`.
   *
   * @type {{throws: boolean}}
   */
  static #optionsInternalCheckDOM = { throws: false };
  // DOM Querying ---------------------------------------------------------------------------------------------------
  /**
   * Convenience method to retrieve the `document.activeElement` value in the current Window context of a DOM Node /
   * Element, EventTarget, Document, or Window.
   *
   * @param {Document | EventTarget | Node | UIEvent | Window}  target - DOM Node / Element, EventTarget, Document,
   *        UIEvent or Window to query.
   *
   * @param {object} [options] - Options.
   *
   * @param {boolean} [options.throws=true] - When `true` and target is invalid throw an exception. If `false` and the
   *        target is invalid `undefined` is returned; default: `true`.
   *
   * @returns {Element | null} Active element or `undefined` when `throws` option is `false` and the target is invalid.
   *
   * @throws {@link TypeError} Target must be a DOM Node / Element, Document, UIEvent, or Window.
   */
  static getActiveElement(target, { throws = true } = {}) {
    if (this.#NodesWithOwnerDocument.has(target?.nodeType)) {
      return target?.ownerDocument?.activeElement ?? null;
    }
    if (this.isUIEvent(target) && isObject(target?.view)) {
      return target?.view?.document?.activeElement ?? null;
    }
    if (isObject(target?.defaultView)) {
      return target?.activeElement ?? null;
    }
    if (isObject(target?.document) && isObject(target?.location)) {
      return target?.document?.activeElement ?? null;
    }
    if (throws) {
      throw new TypeError(`'target' must be a DOM Node / Element, Document, UIEvent, or Window.`);
    }
    return void 0;
  }
  /**
   * Convenience method to retrieve the `Document` value in the current context of a DOM Node / Element, EventTarget,
   * Document, UIEvent, or Window.
   *
   * @param {Document | EventTarget | Node | UIEvent | Window}  target - DOM Node / Element, EventTarget, Document,
   *        UIEvent or Window to query.
   *
   * @param {object} [options] - Options.
   *
   * @param {boolean} [options.throws=true] - When `true` and target is invalid throw an exception. If `false` and the
   *        target is invalid `undefined` is returned; default: `true`.
   *
   * @returns {Document} Active document or `undefined` when `throws` option is `false` and the target is invalid.
   *
   * @throws {@link TypeError} Target must be a DOM Node / Element, Document, UIEvent, or Window.
   */
  static getDocument(target, { throws = true } = {}) {
    if (this.#NodesWithOwnerDocument.has(target?.nodeType)) {
      return target?.ownerDocument;
    }
    if (this.isUIEvent(target) && isObject(target?.view)) {
      return target?.view?.document;
    }
    if (isObject(target?.defaultView)) {
      return target;
    }
    if (isObject(target?.document) && isObject(target?.location)) {
      return target?.document;
    }
    if (throws) {
      throw new TypeError(`'target' must be a DOM Node / Element, Document, UIEvent, or Window.`);
    }
    return void 0;
  }
  /**
   * Convenience method to retrieve the `Window` value in the current context of a DOM Node / Element, EventTarget,
   * Document, or Window.
   *
   * @param {Document | EventTarget | Node | UIEvent | Window}  target - DOM Node / Element, EventTarget, Document,
   *        UIEvent or Window to query.
   *
   * @param {object} [options] - Options.
   *
   * @param {boolean} [options.throws=true] - When `true` and target is invalid throw an exception. If `false` and the
   *        target is invalid `undefined` is returned; default: `true`.
   *
   * @returns {Window} Active window or `undefined` when `throws` option is `false` and the target is invalid.
   *
   * @throws {@link TypeError} Target must be a DOM Node / Element, Document, UIEvent, or Window.
   */
  static getWindow(target, { throws = true } = {}) {
    if (this.#NodesWithOwnerDocument.has(target?.nodeType)) {
      return target.ownerDocument?.defaultView ?? globalThis;
    }
    if (this.isUIEvent(target) && isObject(target?.view)) {
      return target.view ?? globalThis;
    }
    if (isObject(target?.defaultView)) {
      return target.defaultView ?? globalThis;
    }
    if (isObject(target?.document) && isObject(target?.location)) {
      return target;
    }
    if (throws) {
      throw new TypeError(`'target' must be a DOM Node / Element, Document, UIEvent, or Window.`);
    }
    return void 0;
  }
  // ES / Browser API basic prototype tests -------------------------------------------------------------------------
  /**
   * Provides basic prototype string type checking if `target` is a Document.
   *
   * @param {unknown}  target - A potential Document to test.
   *
   * @returns {target is Document} Is `target` a Document.
   */
  static isDocument(target) {
    return isObject(target) && Object.prototype.toString.call(target) === "[object Document]";
  }
  /**
   * Provides basic prototype string type checking if `target` is a Map.
   *
   * @param {unknown}  target - A potential Map to test.
   *
   * @returns {target is Map} Is `target` a Map.
   */
  static isMap(target) {
    return isObject(target) && Object.prototype.toString.call(target) === "[object Map]";
  }
  /**
   * Provides basic prototype string type checking if `target` is a Promise.
   *
   * @param {unknown}  target - A potential Promise to test.
   *
   * @returns {target is Promise} Is `target` a Promise.
   */
  static isPromise(target) {
    return isObject(target) && Object.prototype.toString.call(target) === "[object Promise]";
  }
  /**
   * Provides basic prototype string type checking if `target` is a RegExp.
   *
   * @param {unknown}  target - A potential RegExp to test.
   *
   * @returns {target is RegExp} Is `target` a RegExp.
   */
  static isRegExp(target) {
    return isObject(target) && Object.prototype.toString.call(target) === "[object RegExp]";
  }
  /**
   * Provides basic prototype string type checking if `target` is a Set.
   *
   * @param {unknown}  target - A potential Set to test.
   *
   * @returns {target is Set} Is `target` a Set.
   */
  static isSet(target) {
    return isObject(target) && Object.prototype.toString.call(target) === "[object Set]";
  }
  /**
   * Provides basic prototype string type checking if `target` is a URL.
   *
   * @param {unknown}  target - A potential URL to test.
   *
   * @returns {target is URL} Is `target` a URL.
   */
  static isURL(target) {
    return isObject(target) && Object.prototype.toString.call(target) === "[object URL]";
  }
  /**
   * Provides basic prototype string type checking if `target` is a Window.
   *
   * @param {unknown}  target - A potential Window to test.
   *
   * @returns {target is Window} Is `target` a Window.
   */
  static isWindow(target) {
    return isObject(target) && Object.prototype.toString.call(target) === "[object Window]";
  }
  // DOM Element typing ---------------------------------------------------------------------------------------------
  /**
   * Ensures that the given target is an `instanceof` all known DOM elements that are focusable. Please note that
   * additional checks are required regarding focusable state; use {@link A11yHelper.isFocusable} for a complete check.
   *
   * @param {unknown}  target - Target to test for `instanceof` focusable HTML element.
   *
   * @returns {boolean} Is target an `instanceof` a focusable DOM element.
   */
  static isFocusableHTMLElement(target) {
    for (let cntr = this.#FocusableElementClassNames.length; --cntr >= 0; ) {
      if (this.#checkDOMInstanceType(target, Node.ELEMENT_NODE, this.#FocusableElementClassNames[cntr])) {
        return true;
      }
    }
    return false;
  }
  /**
   * Provides precise type checking if `target` is a DocumentFragment.
   *
   * @param {unknown}  target - A potential DocumentFragment to test.
   *
   * @returns {target is DocumentFragment} Is `target` a DocumentFragment.
   */
  static isDocumentFragment(target) {
    return this.#checkDOMInstanceType(target, Node.DOCUMENT_FRAGMENT_NODE, "DocumentFragment");
  }
  /**
   * Provides precise type checking if `target` is an Element.
   *
   * @param {unknown}  target - A potential Element to test.
   *
   * @returns {target is Element} Is `target` an Element.
   */
  static isElement(target) {
    return this.#checkDOMInstanceType(target, Node.ELEMENT_NODE, "Element");
  }
  /**
   * Provides precise type checking if `target` is a HTMLAnchorElement.
   *
   * @param {unknown}  target - A potential HTMLAnchorElement to test.
   *
   * @returns {target is HTMLAnchorElement} Is `target` a HTMLAnchorElement.
   */
  static isHTMLAnchorElement(target) {
    return this.#checkDOMInstanceType(target, Node.ELEMENT_NODE, "HTMLAnchorElement");
  }
  /**
   * Provides precise type checking if `target` is a HTMLElement.
   *
   * @param {unknown}  target - A potential HTMLElement to test.
   *
   * @returns {target is HTMLElement} Is `target` a HTMLElement.
   */
  static isHTMLElement(target) {
    return this.#checkDOMInstanceType(target, Node.ELEMENT_NODE, "HTMLElement");
  }
  /**
   * Provides precise type checking if `target` is a Node.
   *
   * @param {unknown}  target - A potential Node to test.
   *
   * @returns {target is Node} Is `target` a DOM Node.
   */
  static isNode(target) {
    if (typeof target?.nodeType !== "number") {
      return false;
    }
    if (target instanceof globalThis.Node) {
      return true;
    }
    const activeWindow = this.getWindow(target, this.#optionsInternalCheckDOM);
    const TargetNode = activeWindow?.Node;
    return TargetNode && target instanceof TargetNode;
  }
  /**
   * Provides precise type checking if `target` is a ShadowRoot.
   *
   * @param {unknown}  target - A potential ShadowRoot to test.
   *
   * @returns {target is ShadowRoot} Is `target` a ShadowRoot.
   */
  static isShadowRoot(target) {
    return this.#checkDOMInstanceType(target, Node.DOCUMENT_FRAGMENT_NODE, "ShadowRoot");
  }
  /**
   * Provides precise type checking if `target` is a SVGElement.
   *
   * @param {unknown}  target - A potential SVGElement to test.
   *
   * @returns {target is SVGElement} Is `target` a SVGElement.
   */
  static isSVGElement(target) {
    return this.#checkDOMInstanceType(target, Node.ELEMENT_NODE, "SVGElement");
  }
  // Event typing ---------------------------------------------------------------------------------------------------
  /**
   * Provides basic duck type checking for `Event` signature and optional constructor name(s).
   *
   * @param {unknown}  target - A potential DOM event to test.
   *
   * @param {string | Set<string>} [types] Specific constructor name or Set of constructor names to match.
   *
   * @returns {target is Event} Is `target` an Event with optional constructor name check.
   */
  static isEvent(target, types) {
    if (typeof target?.type !== "string" || typeof target?.defaultPrevented !== "boolean" || typeof target?.stopPropagation !== "function") {
      return false;
    }
    return types !== void 0 ? this.isCtorName(target, types) : true;
  }
  /**
   * Provides basic duck type checking for `Event` signature for standard mouse / pointer events including
   * `MouseEvent` and `PointerEvent`.
   *
   * @param {unknown}  target - A potential DOM event to test.
   *
   * @returns {target is PointerEvent} Is `target` a MouseEvent or PointerEvent.
   */
  static isPointerEvent(target) {
    return this.isEvent(target, this.#PointerEventSet);
  }
  /**
   * Provides basic duck type checking for `Event` signature for all UI events.
   *
   * @param {unknown}  target - A potential DOM event to test.
   *
   * @returns {target is UIEvent} Is `target` a UIEvent.
   * @see https://developer.mozilla.org/en-US/docs/Web/API/UIEvent
   */
  static isUIEvent(target) {
    return this.isEvent(target, this.#UIEventSet);
  }
  /**
   * Provides basic duck type checking for `Event` signature for standard user input events including `KeyboardEvent`,
   * `MouseEvent`, and `PointerEvent`.
   *
   * @param {unknown}  target - A potential DOM event to test.
   *
   * @returns {target is KeyboardEvent | MouseEvent | PointerEvent} Is `target` a Keyboard, MouseEvent, or
   *          PointerEvent.
   */
  static isUserInputEvent(target) {
    return this.isEvent(target, this.#UserInputEventSet);
  }
  // Generic typing -------------------------------------------------------------------------------------------------
  /**
   * Provides basic type checking by constructor name(s) for objects. This can be useful when checking multiple
   * constructor names against a provided Set.
   *
   * @param {unknown}  target - Object to test for constructor name.
   *
   * @param {string | Set<string>} types Specific constructor name or Set of constructor names to match.
   *
   * @returns {boolean} Does the provided object constructor name match the types provided.
   */
  static isCtorName(target, types) {
    if (!isObject(target)) {
      return false;
    }
    if (typeof types === "string" && target?.constructor?.name === types) {
      return true;
    }
    return !!types?.has(target?.constructor?.name);
  }
  // Internal implementation ----------------------------------------------------------------------------------------
  /**
   * Internal generic DOM `instanceof` check. First will attempt to find the class name by `globalThis` falling back
   * to the {@link Window} associated with the DOM node.
   *
   * @param {unknown}  target - Target to test.
   *
   * @param {number}   nodeType - Node type constant.
   *
   * @param {string}   className - DOM class name for instanceof check.
   *
   * @returns {boolean} Is the target the given nodeType and instance of class name.
   */
  static #checkDOMInstanceType(target, nodeType, className) {
    if (!isObject(target)) {
      return false;
    }
    if (target.nodeType !== nodeType) {
      return false;
    }
    const GlobalClass = globalThis[className];
    if (GlobalClass && target instanceof GlobalClass) {
      return true;
    }
    const activeWindow = this.#NodesWithOwnerDocument.has(target.nodeType) ? target?.ownerDocument?.defaultView : this.getWindow(target, this.#optionsInternalCheckDOM);
    const TargetClass = activeWindow?.[className];
    return TargetClass && target instanceof TargetClass;
  }
}
class ResizeObserverManager {
  static {
    __name(this, "ResizeObserverManager");
  }
  /** @type {Map<HTMLElement, import('./types-local').ResizeObserverSubscriber[]>} */
  #elMap = /* @__PURE__ */ new Map();
  /** @type {ResizeObserver} */
  #resizeObserver;
  /**
   * Defines the various shape / update type of the given target.
   *
   * @type {{ [key: string]: number }}
   */
  static #updateTypes = Object.freeze({
    none: 0,
    attribute: 1,
    function: 2,
    resizeObserved: 3,
    setContentBounds: 4,
    setDimension: 5,
    storeObject: 6,
    storesObject: 7
  });
  constructor() {
    this.#resizeObserver = new ResizeObserver((entries) => {
      for (const entry of entries) {
        const subscribers = this.#elMap.get(entry?.target);
        if (Array.isArray(subscribers)) {
          const contentWidth = entry.contentRect.width;
          const contentHeight = entry.contentRect.height;
          for (const subscriber of subscribers) {
            ResizeObserverManager.#updateSubscriber(subscriber, contentWidth, contentHeight);
          }
        }
      }
    });
  }
  /**
   * Add an {@link HTMLElement} and {@link ResizeObserverData.ResizeTarget} instance for monitoring. Create cached
   * style attributes for the given element include border & padding dimensions for offset width / height calculations.
   *
   * @param {HTMLElement}    el - The element to observe.
   *
   * @param {import('./types').ResizeObserverData.ResizeTarget} target - A target that contains one of several
   *        mechanisms for updating resize data.
   */
  add(el, target) {
    if (!CrossWindow.isHTMLElement(el)) {
      throw new TypeError(`ResizeObserverManager.add error: 'el' is not a HTMLElement.`);
    }
    if (this.#hasTarget(el, target)) {
      return;
    }
    const updateType = ResizeObserverManager.#getUpdateType(target);
    if (updateType === 0) {
      throw new Error(`ResizeObserverManager.add error: 'target' is not a valid ResizeObserverManager target.`);
    }
    const computed = globalThis.getComputedStyle(el);
    const borderBottom = StyleParse.pixels(el.style.borderBottom) ?? StyleParse.pixels(computed.borderBottom) ?? 0;
    const borderLeft = StyleParse.pixels(el.style.borderLeft) ?? StyleParse.pixels(computed.borderLeft) ?? 0;
    const borderRight = StyleParse.pixels(el.style.borderRight) ?? StyleParse.pixels(computed.borderRight) ?? 0;
    const borderTop = StyleParse.pixels(el.style.borderTop) ?? StyleParse.pixels(computed.borderTop) ?? 0;
    const paddingBottom = StyleParse.pixels(el.style.paddingBottom) ?? StyleParse.pixels(computed.paddingBottom) ?? 0;
    const paddingLeft = StyleParse.pixels(el.style.paddingLeft) ?? StyleParse.pixels(computed.paddingLeft) ?? 0;
    const paddingRight = StyleParse.pixels(el.style.paddingRight) ?? StyleParse.pixels(computed.paddingRight) ?? 0;
    const paddingTop = StyleParse.pixels(el.style.paddingTop) ?? StyleParse.pixels(computed.paddingTop) ?? 0;
    const data = {
      updateType,
      target,
      // Stores most recent contentRect.width and contentRect.height values from ResizeObserver.
      contentWidth: 0,
      contentHeight: 0,
      // Convenience data for total border & padding for offset width & height calculations.
      styles: {
        additionalWidth: borderLeft + borderRight + paddingLeft + paddingRight,
        additionalHeight: borderTop + borderBottom + paddingTop + paddingBottom
      }
    };
    if (this.#elMap.has(el)) {
      const subscribers = this.#elMap.get(el);
      subscribers.push(data);
    } else {
      this.#elMap.set(el, [data]);
    }
    this.#resizeObserver.observe(el);
  }
  /**
   * Clears and unobserves all currently tracked elements and managed targets.
   */
  clear() {
    for (const el of this.#elMap.keys()) {
      this.#resizeObserver.unobserve(el);
    }
    this.#elMap.clear();
  }
  /**
   * Removes all {@link ResizeObserverData.ResizeTarget} instances for the given element from monitoring when just an
   * element is provided otherwise removes a specific target from the monitoring map. If no more targets remain then
   * the element is removed from monitoring.
   *
   * @param {HTMLElement} el - Element to remove from monitoring.
   *
   * @param {import('./types').ResizeObserverData.ResizeTarget} [target] - A specific target to remove from monitoring.
   */
  remove(el, target = void 0) {
    const subscribers = this.#elMap.get(el);
    if (Array.isArray(subscribers)) {
      if (target !== void 0) {
        const index = subscribers.findIndex((entry) => entry.target === target);
        if (index >= 0) {
          subscribers.splice(index, 1);
        }
      } else {
        subscribers.length = 0;
      }
      if (subscribers.length === 0) {
        this.#elMap.delete(el);
        this.#resizeObserver.unobserve(el);
      }
    }
  }
  /**
   * Provides a function that when invoked with an element updates the cached styles for each subscriber of the
   * element.
   *
   * The style attributes cached to calculate offset height / width include border & padding dimensions. You only need
   * to update the cache if you change border or padding attributes of the element.
   *
   * @param {HTMLElement} el - A HTML element.
   */
  updateCache(el) {
    const subscribers = this.#elMap.get(el);
    if (Array.isArray(subscribers)) {
      const computed = globalThis.getComputedStyle(el);
      const borderBottom = StyleParse.pixels(el.style.borderBottom) ?? StyleParse.pixels(computed.borderBottom) ?? 0;
      const borderLeft = StyleParse.pixels(el.style.borderLeft) ?? StyleParse.pixels(computed.borderLeft) ?? 0;
      const borderRight = StyleParse.pixels(el.style.borderRight) ?? StyleParse.pixels(computed.borderRight) ?? 0;
      const borderTop = StyleParse.pixels(el.style.borderTop) ?? StyleParse.pixels(computed.borderTop) ?? 0;
      const paddingBottom = StyleParse.pixels(el.style.paddingBottom) ?? StyleParse.pixels(computed.paddingBottom) ?? 0;
      const paddingLeft = StyleParse.pixels(el.style.paddingLeft) ?? StyleParse.pixels(computed.paddingLeft) ?? 0;
      const paddingRight = StyleParse.pixels(el.style.paddingRight) ?? StyleParse.pixels(computed.paddingRight) ?? 0;
      const paddingTop = StyleParse.pixels(el.style.paddingTop) ?? StyleParse.pixels(computed.paddingTop) ?? 0;
      const additionalWidth = borderLeft + borderRight + paddingLeft + paddingRight;
      const additionalHeight = borderTop + borderBottom + paddingTop + paddingBottom;
      for (const subscriber of subscribers) {
        subscriber.styles.additionalWidth = additionalWidth;
        subscriber.styles.additionalHeight = additionalHeight;
        ResizeObserverManager.#updateSubscriber(subscriber, subscriber.contentWidth, subscriber.contentHeight);
      }
    }
  }
  // Internal implementation ----------------------------------------------------------------------------------------
  /**
   * Determines the shape of the target instance regarding valid update mechanisms to set width & height changes.
   *
   * @param {import('./types').ResizeObserverData.ResizeTarget}  target - The target instance.
   *
   * @returns {number} Update type value.
   */
  static #getUpdateType(target) {
    if (typeof target?.resizeObserved === "function") {
      return this.#updateTypes.resizeObserved;
    }
    if (typeof target?.setDimension === "function") {
      return this.#updateTypes.setDimension;
    }
    if (typeof target?.setContentBounds === "function") {
      return this.#updateTypes.setContentBounds;
    }
    const targetType = typeof target;
    if (targetType !== null && (targetType === "object" || targetType === "function")) {
      if (isWritableStore(target.resizeObserved)) {
        return this.#updateTypes.storeObject;
      }
      const stores = target?.stores;
      if (isObject(stores) || typeof stores === "function") {
        if (isWritableStore(stores.resizeObserved)) {
          return this.#updateTypes.storesObject;
        }
      }
    }
    if (targetType !== null && targetType === "object") {
      return this.#updateTypes.attribute;
    }
    if (targetType === "function") {
      return this.#updateTypes.function;
    }
    return this.#updateTypes.none;
  }
  /**
   * Determines if a given element and target is already being observed.
   *
   * @param {HTMLElement} el - A HTMLElement.
   *
   * @param {import('./types').ResizeObserverData.ResizeTarget} [target] - A specific target to find.
   *
   * @returns {boolean} Whether the target is already being tracked for the given element.
   */
  #hasTarget(el, target) {
    if (target === void 0 || target === null) {
      return false;
    }
    const subscribers = this.#elMap.get(el);
    if (Array.isArray(subscribers)) {
      return subscribers.findIndex((entry) => entry.target === target) >= 0;
    }
    return false;
  }
  /**
   * Updates a subscriber target with given content width & height values. Offset width & height is calculated from
   * the content values + cached styles.
   *
   * @param {import('./types-local').ResizeObserverSubscriber} subscriber - Internal data about subscriber.
   *
   * @param {number|undefined}  contentWidth - ResizeObserver `contentRect.width` value or undefined.
   *
   * @param {number|undefined}  contentHeight - ResizeObserver `contentRect.height` value or undefined.
   */
  static #updateSubscriber(subscriber, contentWidth, contentHeight) {
    const styles = subscriber.styles;
    subscriber.contentWidth = contentWidth;
    subscriber.contentHeight = contentHeight;
    const offsetWidth = Number.isFinite(contentWidth) ? contentWidth + styles.additionalWidth : void 0;
    const offsetHeight = Number.isFinite(contentHeight) ? contentHeight + styles.additionalHeight : void 0;
    const target = subscriber.target;
    switch (subscriber.updateType) {
      case this.#updateTypes.attribute:
        target.contentWidth = contentWidth;
        target.contentHeight = contentHeight;
        target.offsetWidth = offsetWidth;
        target.offsetHeight = offsetHeight;
        break;
      case this.#updateTypes.function:
        target?.(offsetWidth, offsetHeight, contentWidth, contentHeight);
        break;
      case this.#updateTypes.resizeObserved:
        target.resizeObserved?.(offsetWidth, offsetHeight, contentWidth, contentHeight);
        break;
      case this.#updateTypes.setContentBounds:
        target.setContentBounds?.(contentWidth, contentHeight);
        break;
      case this.#updateTypes.setDimension:
        target.setDimension?.(offsetWidth, offsetHeight);
        break;
      case this.#updateTypes.storeObject:
        target.resizeObserved.update((object) => {
          object.contentHeight = contentHeight;
          object.contentWidth = contentWidth;
          object.offsetHeight = offsetHeight;
          object.offsetWidth = offsetWidth;
          return object;
        });
        break;
      case this.#updateTypes.storesObject:
        target.stores.resizeObserved.update((object) => {
          object.contentHeight = contentHeight;
          object.contentWidth = contentWidth;
          object.offsetHeight = offsetHeight;
          object.offsetWidth = offsetWidth;
          return object;
        });
        break;
    }
  }
}
const resizeObserverActionManager = new ResizeObserverManager();
function resizeObserver(node, target) {
  resizeObserverActionManager.add(node, target);
  return {
    /**
     * @param {import('#runtime/util/dom/observer').ResizeObserverData.ResizeTarget} newTarget - A
     *        {@link ResizeObserverManager} target to update with observed width & height changes.
     */
    update: (newTarget) => {
      resizeObserverActionManager.remove(node, target);
      target = newTarget;
      resizeObserverActionManager.add(node, target);
    },
    destroy: () => {
      resizeObserverActionManager.remove(node, target);
    }
  };
}
__name(resizeObserver, "resizeObserver");
resizeObserver.updateCache = function(el) {
  resizeObserverActionManager.updateCache(el);
};
function applyStyles(node, properties) {
  function setProperties() {
    if (!isObject(properties)) {
      return;
    }
    for (const prop of Object.keys(properties)) {
      node.style.setProperty(`${prop}`, properties[prop]);
    }
  }
  __name(setProperties, "setProperties");
  setProperties();
  return {
    /**
     * @param {{ [key: string]: string | null }}  newProperties - Key / value object of properties to set.
     */
    update: (newProperties) => {
      properties = newProperties;
      setProperties();
    }
  };
}
__name(applyStyles, "applyStyles");
function dynamicAction(node, { action, data } = {}) {
  let actionResult;
  if (typeof action === "function") {
    actionResult = action(node, data);
  }
  return {
    /**
     * @param {import('./types').DynamicActionOptions} newOptions - Defines the new action to dynamically mount.
     */
    update: (newOptions) => {
      if (!isObject(newOptions)) {
        actionResult?.destroy?.();
        action = void 0;
        data = void 0;
        return;
      }
      const { action: newAction, data: newData } = newOptions;
      if (typeof newAction !== "function") {
        console.warn(`dynamicAction.update warning: Aborting as 'action' is not a function.`);
        return;
      }
      const hasNewData = newData !== data;
      if (hasNewData) {
        data = newData;
      }
      if (newAction !== action) {
        actionResult?.destroy?.();
        action = newAction;
        actionResult = action(node, data);
      } else if (hasNewData) {
        actionResult?.update?.(data);
      }
    },
    destroy: () => {
      actionResult?.destroy?.();
      action = void 0;
      data = void 0;
      actionResult = void 0;
    }
  };
}
__name(dynamicAction, "dynamicAction");
function lerp(start, end, amount) {
  return (1 - amount) * start + amount * end;
}
__name(lerp, "lerp");
const easingFunc = svelteEasingFunc;
function getEasingFunc(easingRef, options) {
  if (typeof easingRef === "function") {
    return easingRef;
  }
  const easingFn = easingFunc[easingRef];
  return easingFn ? easingFn : easingFunc[options?.default ?? "linear"];
}
__name(getEasingFunc, "getEasingFunc");
class TJSDefaultTransition {
  static {
    __name(this, "TJSDefaultTransition");
  }
  static #options = {};
  static #default = () => void 0;
  /**
   * @returns {() => undefined} Default empty transition.
   */
  static get default() {
    return this.#default;
  }
  /**
   * @returns {{}} Default empty options.
   */
  static get options() {
    return this.#options;
  }
}
class A11yHelper {
  static {
    __name(this, "A11yHelper");
  }
  /**
   * You can set global focus debugging enabled by setting `A11yHelper.debug = true`.
   *
   * @type {boolean}
   */
  static #globalDebug = false;
  /**
   * @returns {boolean} Global debugging enabled.
   */
  static get debug() {
    return this.#globalDebug;
  }
  /**
   * @param {boolean}  debug - Global debug enabled
   */
  static set debug(debug) {
    if (typeof debug !== "boolean") {
      throw new TypeError(`'debug' is not a boolean.`);
    }
    this.#globalDebug = debug;
  }
  /**
   * Runs a media query to determine if the user / OS configuration is set up for reduced motion / animation.
   *
   * @returns {boolean} User prefers reduced motion.
   */
  static get prefersReducedMotion() {
    return globalThis?.matchMedia("(prefers-reduced-motion: reduce)")?.matches ?? false;
  }
  /**
   * Apply focus to the HTMLElement / SVGElement targets in a given A11yFocusSource data object. An iterable list
   * `options.focusEl` can contain HTMLElement / SVGElements or selector strings. If multiple focus targets are
   * provided in a list then the first valid target found will be focused. If focus target is a string then a lookup
   * via `document.querySelector` is performed. In this case you should provide a unique selector for the desired
   * focus target.
   *
   * Note: The body of this method is postponed to the next clock tick to allow any changes in the DOM to occur that
   * might alter focus targets before applying.
   *
   * @param {A11yFocusSource | { focusSource: A11yFocusSource }}   options - The focus options instance to apply.
   */
  static applyFocusSource(options) {
    if (!isObject(options)) {
      return;
    }
    const focusOpts = isObject(options?.focusSource) ? options.focusSource : options;
    setTimeout(() => {
      const debug = typeof focusOpts.debug === "boolean" ? this.debug || focusOpts.debug : this.debug;
      if (isIterable(focusOpts.focusEl)) {
        if (debug) {
          console.debug(
            `A11yHelper.applyFocusSource debug - Attempting to apply focus target: `,
            focusOpts.focusEl
          );
        }
        for (const target of focusOpts.focusEl) {
          if (target?.nodeType === Node.ELEMENT_NODE && target?.isConnected) {
            target?.focus();
            if (debug) {
              console.debug(`A11yHelper.applyFocusSource debug - Applied focus to target: `, target);
            }
            break;
          } else if (typeof target === "string") {
            const element2 = document.querySelector(target);
            if (element2?.nodeType === Node.ELEMENT_NODE && element2?.isConnected) {
              element2?.focus();
              if (debug) {
                console.debug(`A11yHelper.applyFocusSource debug - Applied focus to target: `, element2);
              }
              break;
            } else if (debug) {
              console.debug(`A11yHelper.applyFocusSource debug - Could not query selector: `, target);
            }
          }
        }
      } else if (debug) {
        console.debug(`A11yHelper.applyFocusSource debug - No focus targets defined.`);
      }
    }, 0);
  }
  /**
   * Returns first focusable element within a specified element.
   *
   * @param {Element | Document} [element=document] - Optional element to start query.
   *
   * @param {FocusableElementOptions} [options] - Optional parameters.
   *
   * @returns {FocusableElement} First focusable child element.
   */
  static getFirstFocusableElement(element2 = document, options) {
    const focusableElements = this.getFocusableElements(element2, options);
    return focusableElements.length > 0 ? focusableElements[0] : void 0;
  }
  /**
   * Returns all focusable elements within a specified element.
   *
   * @param {Element | Document} [element=document] Optional element to start query.
   *
   * @param {FocusableElementOptions} [options] - Optional parameters.
   *
   * @returns {Array<FocusableElement>} Child keyboard focusable elements.
   */
  static getFocusableElements(element2 = document, {
    anchorHref = true,
    ignoreClasses,
    ignoreElements,
    parentHidden = false,
    selectors
  } = {}) {
    if (element2?.nodeType !== Node.ELEMENT_NODE && element2?.nodeType !== Node.DOCUMENT_NODE) {
      throw new TypeError(`'element' is not a HTMLElement, SVGElement, or Document instance.`);
    }
    if (typeof anchorHref !== "boolean") {
      throw new TypeError(`'anchorHref' is not a boolean.`);
    }
    if (ignoreClasses !== void 0 && !isIterable(ignoreClasses)) {
      throw new TypeError(`'ignoreClasses' is not an iterable list.`);
    }
    if (ignoreElements !== void 0 && !CrossWindow.isSet(ignoreElements)) {
      throw new TypeError(`'ignoreElements' is not a Set.`);
    }
    if (selectors !== void 0 && typeof selectors !== "string") {
      throw new TypeError(`'selectors' is not a string.`);
    }
    const selectorQuery = selectors ?? this.#getFocusableSelectors(anchorHref);
    let allElements = [...element2.querySelectorAll(selectorQuery)];
    if (ignoreElements && ignoreClasses) {
      allElements = allElements.filter((el) => {
        let hasIgnoreClass = false;
        for (const ignoreClass of ignoreClasses) {
          if (el.classList.contains(ignoreClass)) {
            hasIgnoreClass = true;
            break;
          }
        }
        return !hasIgnoreClass && !ignoreElements.has(el) && el.style.display !== "none" && el.style.visibility !== "hidden" && !el.hasAttribute("disabled") && !el.hasAttribute("inert") && el.getAttribute("aria-hidden") !== "true";
      });
    } else if (ignoreClasses) {
      allElements = allElements.filter((el) => {
        let hasIgnoreClass = false;
        for (const ignoreClass of ignoreClasses) {
          if (el.classList.contains(ignoreClass)) {
            hasIgnoreClass = true;
            break;
          }
        }
        return !hasIgnoreClass && el.style.display !== "none" && el.style.visibility !== "hidden" && !el.hasAttribute("disabled") && !el.hasAttribute("inert") && el.getAttribute("aria-hidden") !== "true";
      });
    } else if (ignoreElements) {
      allElements = allElements.filter((el) => {
        return !ignoreElements.has(el) && el.style.display !== "none" && el.style.visibility !== "hidden" && !el.hasAttribute("disabled") && !el.hasAttribute("inert") && el.getAttribute("aria-hidden") !== "true";
      });
    } else {
      allElements = allElements.filter((el) => {
        return el.style.display !== "none" && el.style.visibility !== "hidden" && !el.hasAttribute("disabled") && !el.hasAttribute("inert") && el.getAttribute("aria-hidden") !== "true";
      });
    }
    if (parentHidden) {
      allElements = allElements.filter((el) => {
        return !this.isParentHidden(el, element2);
      });
    }
    return allElements;
  }
  /**
   * Returns the default focusable selectors query.
   *
   * @param {boolean}  [anchorHref=true] - When true anchors must have an HREF.
   *
   * @returns {string} Focusable selectors for `querySelectorAll`.
   */
  static #getFocusableSelectors(anchorHref = true) {
    return `button, [contenteditable=""], [contenteditable="true"], details summary:not([tabindex="-1"]), embed, a${anchorHref ? "[href]" : ""}, iframe, object, input:not([type=hidden]), select, textarea, [tabindex]:not([tabindex="-1"])`;
  }
  /**
   * Gets a A11yFocusSource object from the given DOM event allowing for optional X / Y screen space overrides.
   * Browsers (Firefox / Chrome) forwards a mouse event for the context menu keyboard button. Provides detection of
   * when the context menu event is from the keyboard. Firefox as of (1/23) does not provide the correct screen space
   * coordinates, so for keyboard context menu presses coordinates are generated from the centroid point of the
   * element.
   *
   * A default fallback element or selector string may be provided to provide the focus target. If the event comes from
   * the keyboard however the source focused element is inserted as the target with the fallback value appended to the
   * list of focus targets. When A11yFocusSource is applied by {@link A11yHelper.applyFocusSource} the target focus
   * list is iterated through until a connected target is found and focus applied.
   *
   * @param {object} options - Options
   *
   * @param {KeyboardEvent | MouseEvent}   [options.event] - The source DOM event.
   *
   * @param {boolean} [options.debug] - When true {@link A11yHelper.applyFocusSource} logs focus target data.
   *
   * @param {FocusableElement | string} [options.focusEl] - A specific HTMLElement / SVGElement or selector
   *        string as the focus target.
   *
   * @param {number}   [options.x] - Used when an event isn't provided; integer of event source in screen space.
   *
   * @param {number}   [options.y] - Used when an event isn't provided; integer of event source in screen space.
   *
   * @returns {A11yFocusSource} A A11yFocusSource object.
   *
   * @see https://bugzilla.mozilla.org/show_bug.cgi?id=1426671
   * @see https://bugzilla.mozilla.org/show_bug.cgi?id=314314
   *
   * TODO: Evaluate / test against touch input devices.
   */
  static getFocusSource({ event, x, y, focusEl, debug = false }) {
    if (focusEl !== void 0 && !this.isFocusSource(focusEl)) {
      throw new TypeError(
        `A11yHelper.getFocusSource error: 'focusEl' is not a HTMLElement, SVGElement, or string.`
      );
    }
    if (debug !== void 0 && typeof debug !== "boolean") {
      throw new TypeError(`A11yHelper.getFocusSource error: 'debug' is not a boolean.`);
    }
    const debugEnabled = typeof debug === "boolean" ? this.debug || debug : this.debug;
    if (event === void 0) {
      if (typeof x !== "number") {
        throw new TypeError(`A11yHelper.getFocusSource error: 'event' not defined and 'x' is not a number.`);
      }
      if (typeof y !== "number") {
        throw new TypeError(`A11yHelper.getFocusSource error: 'event' not defined and 'y' is not a number.`);
      }
      const result2 = {
        debug,
        focusEl: focusEl !== void 0 ? [focusEl] : void 0,
        x,
        y
      };
      if (debugEnabled) {
        console.debug(`A11yHelper.getFocusSource debug: generated 'focusSource' without event: `, result2);
      }
      return result2;
    }
    if (event !== void 0 && !CrossWindow.isUserInputEvent(event)) {
      throw new TypeError(
        `A11yHelper.getFocusSource error: 'event' is not a KeyboardEvent, MouseEvent, or PointerEvent.`
      );
    }
    if (x !== void 0 && !Number.isInteger(x)) {
      throw new TypeError(`A11yHelper.getFocusSource error: 'x' is not a number.`);
    }
    if (y !== void 0 && !Number.isInteger(y)) {
      throw new TypeError(`A11yHelper.getFocusSource error: 'y' is not a number.`);
    }
    let targetEl;
    if (event) {
      if (A11yHelper.isFocusable(event.target)) {
        targetEl = event.target;
        if (debugEnabled) {
          console.debug(`A11yHelper.getFocusSource debug: 'targetEl' set to event.target: `, targetEl);
        }
      } else if (A11yHelper.isFocusable(event.currentTarget)) {
        targetEl = event.currentTarget;
        if (debugEnabled) {
          console.debug(`A11yHelper.getFocusSource debug: 'targetEl' set to event.currentTarget: `, targetEl);
        }
      } else {
        if (debugEnabled) {
          console.debug(
            `A11yHelper.getFocusSource debug: 'event.target' / 'event.currentTarget' are not focusable.`
          );
          console.debug(`A11yHelper.getFocusSource debug: 'event.target': `, event.target);
          console.debug(`A11yHelper.getFocusSource debug: 'event.currentTarget': `, event.currentTarget);
        }
      }
      if (targetEl) {
        if (targetEl?.nodeType !== Node.ELEMENT_NODE && typeof targetEl?.focus !== "function") {
          throw new TypeError(`A11yHelper.getFocusSource error: 'targetEl' is not an HTMLElement or SVGElement.`);
        }
      }
    }
    const result = { debug };
    if (CrossWindow.isPointerEvent(event)) {
      if (event?.button !== 2 && event.type === "contextmenu") {
        const rectTarget = targetEl ?? event.target;
        const rect = rectTarget.getBoundingClientRect();
        result.source = "keyboard";
        result.x = x ?? rect.left + rect.width / 2;
        result.y = y ?? rect.top + rect.height / 2;
        result.focusEl = targetEl ? [targetEl] : [];
        if (focusEl) {
          result.focusEl.push(focusEl);
        }
      } else {
        result.source = "pointer";
        result.x = x ?? event.pageX;
        result.y = y ?? event.pageY;
        result.focusEl = targetEl ? [targetEl] : [];
        if (focusEl) {
          result.focusEl.push(focusEl);
        }
      }
    } else {
      const rectTarget = targetEl ?? event?.target;
      if (rectTarget) {
        const rect = rectTarget.getBoundingClientRect();
        result.source = "keyboard";
        result.x = x ?? rect.left + rect.width / 2;
        result.y = y ?? rect.top + rect.height / 2;
        result.focusEl = targetEl ? [targetEl] : [];
      }
      if (focusEl) {
        result.focusEl.push(focusEl);
      }
    }
    if (debugEnabled) {
      console.debug(`A11yHelper.getFocusSource debug: generated 'focusSource' with event: `, result);
    }
    return result;
  }
  /**
   * Returns first focusable element within a specified element.
   *
   * @param {Element | Document} [element=document] - Optional element to start query.
   *
   * @param {FocusableElementOptions} [options] - Optional parameters.
   *
   * @returns {FocusableElement} Last focusable child element.
   */
  static getLastFocusableElement(element2 = document, options) {
    const focusableElements = this.getFocusableElements(element2, options);
    return focusableElements.length > 0 ? focusableElements[focusableElements.length - 1] : void 0;
  }
  /**
   * Tests if the given element is focusable.
   *
   * @param {unknown} el - Element to test.
   *
   * @param {object} [options] - Optional parameters.
   *
   * @param {boolean} [options.anchorHref=true] - When true anchors must have an HREF.
   *
   * @param {Iterable<string>} [options.ignoreClasses] - Iterable list of classes to ignore elements.
   *
   * @returns {boolean} Element is focusable.
   */
  static isFocusable(el, { anchorHref = true, ignoreClasses } = {}) {
    if (el === void 0 || el === null || el?.hidden || !el?.isConnected || el?.nodeType !== Node.ELEMENT_NODE || typeof el?.focus !== "function") {
      return false;
    }
    if (typeof anchorHref !== "boolean") {
      throw new TypeError(`'anchorHref' is not a boolean.`);
    }
    if (ignoreClasses !== void 0 && !isIterable(ignoreClasses)) {
      throw new TypeError(`'ignoreClasses' is not an iterable list.`);
    }
    const contenteditableAttr = el.getAttribute("contenteditable");
    const contenteditableFocusable = typeof contenteditableAttr === "string" && (contenteditableAttr === "" || contenteditableAttr === "true");
    const tabindexAttr = globalThis.parseInt(el.getAttribute("tabindex"));
    const tabindexFocusable = Number.isInteger(tabindexAttr) && tabindexAttr >= 0;
    if (contenteditableFocusable || tabindexFocusable || CrossWindow.isFocusableHTMLElement(el)) {
      if (anchorHref && !tabindexFocusable && CrossWindow.isHTMLAnchorElement(el) && typeof el.getAttribute("href") !== "string") {
        return false;
      }
      return el.style.display !== "none" && el.style.visibility !== "hidden" && !el.hasAttribute("disabled") && !el.hasAttribute("inert") && el.getAttribute("aria-hidden") !== "true";
    }
    return false;
  }
  /**
   * Convenience method to check if the given data is a valid focus source.
   *
   * @param {Element | string}   data - Either an HTMLElement, SVGElement, or selector string.
   *
   * @returns {boolean} Is valid focus source.
   */
  static isFocusSource(data) {
    return typeof data === "string" || data?.nodeType === Node.ELEMENT_NODE && typeof data?.focus === "function";
  }
  /**
   * Tests if the given `element` is a Element node and has a `focus` method.
   *
   * @param {Element}  element - Element to test for focus method.
   *
   * @returns {boolean} Whether the element has a focus method.
   */
  static isFocusTarget(element2) {
    return element2 !== void 0 && element2 !== null && element2?.nodeType === Node.ELEMENT_NODE && typeof element2?.focus === "function";
  }
  /**
   * Perform a parent traversal from the current active element attempting to match the given element to test whether
   * current active element is within that element.
   *
   * @param {Element}  element - An element to match in parent traversal from the active element.
   *
   * @returns {boolean} Whether there is focus within the given element.
   */
  static isFocusWithin(element2) {
    if (!isObject(element2) || element2?.hidden || !element2?.isConnected) {
      return false;
    }
    let active2 = CrossWindow.getActiveElement(element2);
    if (!active2) {
      return false;
    }
    while (active2) {
      if (active2 === element2) {
        return true;
      }
      active2 = active2.parentElement;
    }
    return false;
  }
  /**
   * Traverses the given element's parent elements to check if any parent has `offsetWidth` and `offsetHeight` of 0,
   * indicating that a parent element is hidden. If a parent element is hidden, the given element is also considered
   * hidden. This is a reasonably efficient check and can be enabled as a filter step in conjunction with focusable
   * element detection methods like {@link A11yHelper.getFocusableElements}.
   *
   * @param {Element}  element - The starting element to check.
   *
   * @param {Element}  [stopElement] - The stopping parent element for traversal. If not defined, `document.body` is
   *        used as the stopping element.
   *
   * @returns {boolean} `true` if a parent element of the given element is hidden; otherwise, `false`.
   */
  static isParentHidden(element2, stopElement) {
    if (!CrossWindow.isElement(element2)) {
      throw new TypeError(`'element' is not an Element.`);
    }
    stopElement = stopElement ?? CrossWindow.getDocument(element2)?.body;
    if (!CrossWindow.isElement(stopElement)) {
      throw new TypeError(`'stopElement' must be an Element.`);
    }
    let current = element2.parentElement;
    while (current) {
      if (current === stopElement) {
        break;
      }
      if (current.offsetWidth === 0 && current.offsetHeight === 0) {
        return true;
      }
      current = current.parentElement;
    }
    return false;
  }
}
class AppShellContextInternal {
  static {
    __name(this, "AppShellContextInternal");
  }
  /** @type {InternalAppStores} */
  #stores;
  constructor() {
    this.#stores = {
      elementContent: writable(void 0),
      elementRoot: writable(void 0)
    };
    Object.freeze(this.#stores);
    Object.seal(this);
  }
  /**
   * @returns {InternalAppStores} The internal context stores for elementContent / elementRoot
   */
  get stores() {
    return this.#stores;
  }
}
class TJSSvelteUtil {
  static {
    __name(this, "TJSSvelteUtil");
  }
  /**
   * Provides basic duck typing to determine if the provided function is a constructor function for a Svelte component.
   *
   * @param {unknown}  comp - Data to check as a Svelte component.
   *
   * @returns {boolean} Whether basic duck typing succeeds.
   */
  static isComponent(comp) {
    if (comp === null || comp === void 0 || typeof comp !== "function") {
      return false;
    }
    const prototypeName = comp?.prototype?.constructor?.name;
    if (typeof prototypeName === "string" && (prototypeName.startsWith("Proxy<") || prototypeName === "ProxyComponent")) {
      return true;
    }
    return typeof window !== "undefined" ? typeof comp.prototype.$destroy === "function" && typeof comp.prototype.$on === "function" : (
      // client-side
      typeof comp.render === "function"
    );
  }
  /**
   * Provides basic duck typing to determine if the provided object is a HMR ProxyComponent instance or class.
   *
   * @param {unknown}  comp - Data to check as a HMR proxy component.
   *
   * @returns {boolean} Whether basic duck typing succeeds.
   */
  static isHMRProxy(comp) {
    const instanceName = comp?.constructor?.name;
    if (typeof instanceName === "string" && (instanceName.startsWith("Proxy<") || instanceName === "ProxyComponent")) {
      return true;
    }
    const prototypeName = comp?.prototype?.constructor?.name;
    return typeof prototypeName === "string" && (prototypeName.startsWith("Proxy<") || prototypeName === "ProxyComponent");
  }
  /**
   * Runs outro transition then destroys Svelte component.
   *
   * Workaround for https://github.com/sveltejs/svelte/issues/4056
   *
   * @param {*}  instance - A Svelte component.
   *
   * @returns {Promise} Promise returned after outro transition completed and component destroyed.
   */
  static async outroAndDestroy(instance2) {
    if (instance2 === void 0 || instance2 === null) {
      return Promise.resolve();
    }
    return new Promise((resolve) => {
      if (instance2?.$$?.fragment && instance2?.$$?.fragment?.o) {
        group_outros();
        transition_out(instance2.$$.fragment, 0, 0, () => {
          instance2?.$destroy?.();
          resolve();
        });
        check_outros();
      } else {
        instance2?.$destroy?.();
        resolve();
      }
    });
  }
}
Object.seal(TJSSvelteUtil);
class TJSSvelteConfigUtil {
  static {
    __name(this, "TJSSvelteConfigUtil");
  }
  /**
   * Validates `config` argument whether it is a valid {@link TJSSvelteConfig}.
   *
   * @param {unknown}  config - The potential config object to validate.
   *
   * @param {object}   [options] - Options.
   *
   * @param {boolean}  [options.raiseException=false] - If validation fails raise an exception.
   *
   * @returns {config is import('./types').TJSSvelteConfig} Is the config a valid TJSSvelteConfig.
   *
   * @throws {TypeError}  Any validation error when `raiseException` is enabled.
   */
  static isConfig(config, { raiseException = false } = {}) {
    if (!isObject(config)) {
      if (raiseException) {
        throw new TypeError(`TJSSvelteConfigUtil.isConfig error: 'config' is not an object.`);
      }
      return false;
    }
    if (!TJSSvelteUtil.isComponent(config.class)) {
      if (raiseException) {
        throw new TypeError(
          `TJSSvelteConfigUtil.isConfig error: 'config.class' is not a Svelte component constructor.`
        );
      }
      return false;
    }
    return true;
  }
  /**
   * Parses a TyphonJS Svelte config object ensuring that classes specified are Svelte components and props are set
   * correctly.
   *
   * @param {import('./types').TJSSvelteConfig}   config - Svelte config object.
   *
   * @param {any}       [thisArg] - `This` reference to set for invoking any props function.
   *
   * @returns {import('./types').TJSSvelteConfig} The processed Svelte config object.
   */
  static parseConfig(config, thisArg = void 0) {
    if (!isObject(config)) {
      throw new TypeError(
        `TJSSvelteConfigUtil.parseConfig - 'config' is not an object:
${JSON.stringify(config)}.`
      );
    }
    if (!TJSSvelteUtil.isComponent(config.class)) {
      throw new TypeError(
        `TJSSvelteConfigUtil.parseConfig - 'class' is not a Svelte component constructor for config:
${JSON.stringify(config)}.`
      );
    }
    if (config.hydrate !== void 0 && typeof config.hydrate !== "boolean") {
      throw new TypeError(
        `TJSSvelteConfigUtil.parseConfig - 'hydrate' is not a boolean for config:
${JSON.stringify(config)}.`
      );
    }
    if (config.intro !== void 0 && typeof config.intro !== "boolean") {
      throw new TypeError(
        `TJSSvelteConfigUtil.parseConfig - 'intro' is not a boolean for config:
${JSON.stringify(config)}.`
      );
    }
    if (config.target !== void 0 && typeof config.target !== "string" && !CrossWindow.isElement(config.target) && !CrossWindow.isShadowRoot(config.target) && !CrossWindow.isDocumentFragment(config.target)) {
      throw new TypeError(
        `TJSSvelteConfigUtil.parseConfig - 'target' is not a Element, ShadowRoot, or DocumentFragment for config:
${JSON.stringify(config)}.`
      );
    }
    if (config.anchor !== void 0 && typeof config.anchor !== "string" && !CrossWindow.isElement(config.anchor) && !CrossWindow.isShadowRoot(config.anchor) && !CrossWindow.isDocumentFragment(config.anchor)) {
      throw new TypeError(`TJSSvelteConfigUtil.parseConfig - 'anchor' is not a string, Element for config:
${JSON.stringify(config)}.`);
    }
    if (config.context !== void 0 && typeof config.context !== "function" && !CrossWindow.isMap(config.context) && !isObject(config.context)) {
      throw new TypeError(
        `TJSSvelteConfigUtil.parseConfig - 'context' is not a Map, function or object for config:
${JSON.stringify(config)}.`
      );
    }
    if (config.selectorTarget !== void 0 && typeof config.selectorTarget !== "string") {
      throw new TypeError(
        `TJSSvelteConfigUtil.parseConfig - 'selectorTarget' is not a string for config:
${JSON.stringify(config)}.`
      );
    }
    if (config.options !== void 0 && !isObject(config.options)) {
      throw new TypeError(
        `TJSSvelteConfigUtil.parseConfig - 'options' is not an object for config:
${JSON.stringify(config)}.`
      );
    }
    if (isObject(config.options)) {
      if (config.options.injectApp !== void 0 && typeof config.options.injectApp !== "boolean") {
        throw new TypeError(`TJSSvelteConfigUtil.parseConfig - 'options.injectApp' is not a boolean for config:
${JSON.stringify(config)}.`);
      }
      if (config.options.injectEventbus !== void 0 && typeof config.options.injectEventbus !== "boolean") {
        throw new TypeError(
          `TJSSvelteConfigUtil.parseConfig - 'options.injectEventbus' is not a boolean for config:
${JSON.stringify(config)}.`
        );
      }
      if (config.options.selectorElement !== void 0 && typeof config.options.selectorElement !== "string") {
        throw new TypeError(`TJSSvelteConfigUtil.parseConfig - 'selectorElement' is not a string for config:
${JSON.stringify(config)}.`);
      }
    }
    const svelteConfig = { ...config };
    delete svelteConfig.options;
    let externalContext = {};
    if (typeof svelteConfig.context === "function") {
      const contextFunc = svelteConfig.context;
      delete svelteConfig.context;
      const result = contextFunc.call(thisArg);
      if (isObject(result)) {
        externalContext = { ...result };
      } else {
        throw new Error(
          `TJSSvelteConfigUtil.parseConfig - 'context' is a function that did not return an object for config:
${JSON.stringify(config)}`
        );
      }
    } else if (CrossWindow.isMap(svelteConfig.context)) {
      externalContext = Object.fromEntries(svelteConfig.context);
      delete svelteConfig.context;
    } else if (isObject(svelteConfig.context)) {
      externalContext = svelteConfig.context;
      delete svelteConfig.context;
    }
    svelteConfig.props = this.#processProps(svelteConfig.props, thisArg, config);
    if (Array.isArray(svelteConfig.children)) {
      const children2 = [];
      for (let cntr = 0; cntr < svelteConfig.children.length; cntr++) {
        const child = svelteConfig.children[cntr];
        if (!TJSSvelteUtil.isComponent(child.class)) {
          throw new Error(`TJSSvelteConfigUtil.parseConfig - 'class' is not a Svelte component for child[${cntr}] for config:
${JSON.stringify(config)}`);
        }
        child.props = this.#processProps(child.props, thisArg, config);
        children2.push(child);
      }
      if (children2.length > 0) {
        externalContext.children = children2;
      }
      delete svelteConfig.children;
    } else if (isObject(svelteConfig.children)) {
      if (!TJSSvelteUtil.isComponent(svelteConfig.children.class)) {
        throw new Error(
          `TJSSvelteConfigUtil.parseConfig - 'class' is not a Svelte component for children object for config:
${JSON.stringify(config)}`
        );
      }
      svelteConfig.children.props = this.#processProps(svelteConfig.children.props, thisArg, config);
      externalContext.children = [svelteConfig.children];
      delete svelteConfig.children;
    }
    if (!CrossWindow.isMap(svelteConfig.context)) {
      svelteConfig.context = /* @__PURE__ */ new Map();
    }
    svelteConfig.context.set("#external", externalContext);
    return svelteConfig;
  }
  // Internal implementation ----------------------------------------------------------------------------------------
  /**
   * Processes Svelte props. Potentially props can be a function to invoke with `thisArg`.
   *
   * @param {{ [key: string]: any } | Function}   props - Svelte props.
   *
   * @param {*}                 thisArg - `This` reference to set for invoking any props function.
   *
   * @param {object}            config - Svelte config
   *
   * @returns {{ [key: string]: any } | undefined}     Svelte props.
   */
  static #processProps(props, thisArg, config) {
    if (typeof props === "function") {
      const result = props.call(thisArg);
      if (isObject(result)) {
        return result;
      } else {
        throw new Error(
          `TJSSvelteConfigUtil.parseConfig - 'props' is a function that did not return an object for config:
${JSON.stringify(config)}`
        );
      }
    } else if (isObject(props)) {
      return props;
    } else if (props !== void 0) {
      throw new Error(`TJSSvelteConfigUtil.parseConfig - 'props' is not a function or an object for config:
${JSON.stringify(config)}`);
    }
    return {};
  }
}
Object.seal(TJSSvelteConfigUtil);
function localize(stringId, data) {
  const result = !isObject(data) ? globalThis.game.i18n.localize(stringId) : globalThis.game.i18n.format(stringId, data);
  return result !== void 0 ? result : "";
}
__name(localize, "localize");
function clamp(value = 0, min = 0, max = 0) {
  return Math.min(Math.max(value, min), max);
}
__name(clamp, "clamp");
function degToRad(deg) {
  return deg * (Math.PI / 180);
}
__name(degToRad, "degToRad");
function radToDeg(rad) {
  return rad * (180 / Math.PI);
}
__name(radToDeg, "radToDeg");
function writableDerived(origins, derive, reflect, initial) {
  var childDerivedSetter, originValues, blockNextDerive = false;
  var reflectOldValues = reflect.length >= 2;
  var wrappedDerive = /* @__PURE__ */ __name((got, set, update3) => {
    childDerivedSetter = set;
    if (reflectOldValues) {
      originValues = got;
    }
    if (!blockNextDerive) {
      let returned = derive(got, set, update3);
      if (derive.length < 2) {
        set(returned);
      } else {
        return returned;
      }
    }
    blockNextDerive = false;
  }, "wrappedDerive");
  var childDerived = derived(origins, wrappedDerive, initial);
  var singleOrigin = !Array.isArray(origins);
  function doReflect(reflecting) {
    var setWith = reflect(reflecting, originValues);
    if (singleOrigin) {
      blockNextDerive = true;
      origins.set(setWith);
    } else {
      setWith.forEach((value, i) => {
        blockNextDerive = true;
        origins[i].set(value);
      });
    }
    blockNextDerive = false;
  }
  __name(doReflect, "doReflect");
  var tryingSet = false;
  function update2(fn) {
    var isUpdated, mutatedBySubscriptions, oldValue, newValue;
    if (tryingSet) {
      newValue = fn(get_store_value(childDerived));
      childDerivedSetter(newValue);
      return;
    }
    var unsubscribe = childDerived.subscribe((value) => {
      if (!tryingSet) {
        oldValue = value;
      } else if (!isUpdated) {
        isUpdated = true;
      } else {
        mutatedBySubscriptions = true;
      }
    });
    newValue = fn(oldValue);
    tryingSet = true;
    childDerivedSetter(newValue);
    unsubscribe();
    tryingSet = false;
    if (mutatedBySubscriptions) {
      newValue = get_store_value(childDerived);
    }
    if (isUpdated) {
      doReflect(newValue);
    }
  }
  __name(update2, "update");
  return {
    subscribe: childDerived.subscribe,
    set(value) {
      update2(() => value);
    },
    update: update2
  };
}
__name(writableDerived, "writableDerived");
function propertyStore(origin, propName) {
  if (!Array.isArray(propName)) {
    return writableDerived(
      origin,
      (object) => object[propName],
      (reflecting, object) => {
        object[propName] = reflecting;
        return object;
      }
    );
  } else {
    let props = propName.concat();
    return writableDerived(
      origin,
      (value) => {
        for (let i = 0; i < props.length; ++i) {
          value = value[props[i]];
        }
        return value;
      },
      (reflecting, object) => {
        let target = object;
        for (let i = 0; i < props.length - 1; ++i) {
          target = target[props[i]];
        }
        target[props[props.length - 1]] = reflecting;
        return object;
      }
    );
  }
}
__name(propertyStore, "propertyStore");
// @license MIT (https://github.com/toji/gl-matrix/blob/master/LICENSE.md)
var GLM_EPSILON = 1e-6;
var Mat4 = class _Mat4 extends Float32Array {
  static {
    __name(this, "_Mat4");
  }
  static #IDENTITY_4X4 = new Float32Array([
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1
  ]);
  /**
   * Temporary variable to prevent repeated allocations in the algorithms within Mat4.
   * These are declared as TypedArrays to aid in tree-shaking.
   */
  static #TMP_VEC3 = new Float32Array(3);
  /**
   * Create a {@link Mat4}.
   *
   * @category Constructor
   */
  constructor(...values) {
    switch (values.length) {
      case 16:
        super(values);
        break;
      case 2:
        super(values[0], values[1], 16);
        break;
      case 1:
        const v = values[0];
        if (typeof v === "number") {
          super([
            v,
            v,
            v,
            v,
            v,
            v,
            v,
            v,
            v,
            v,
            v,
            v,
            v,
            v,
            v,
            v
          ]);
        } else {
          super(v, 0, 16);
        }
        break;
      default:
        super(_Mat4.#IDENTITY_4X4);
        break;
    }
  }
  // ============
  // Accessors
  // ============
  /**
   * A string representation of `this`
   * Equivalent to `Mat4.str(this);`
   *
   * @category Accessors
   */
  get str() {
    return _Mat4.str(this);
  }
  // ===================
  // Instance methods
  // ===================
  /**
   * Copy the values from another {@link Mat4} into `this`.
   * @category Methods
   *
   * @param a the source vector
   * @returns `this`
   */
  copy(a) {
    this.set(a);
    return this;
  }
  /**
   * Set `this` to the identity matrix
   * Equivalent to Mat4.identity(this)
   * @category Methods
   *
   * @returns `this`
   */
  identity() {
    this.set(_Mat4.#IDENTITY_4X4);
    return this;
  }
  /**
   * Multiplies this {@link Mat4} against another one
   * Equivalent to `Mat4.multiply(this, this, b);`
   * @category Methods
   *
   * @param b - The second operand
   * @returns `this`
   */
  multiply(b) {
    return _Mat4.multiply(this, this, b);
  }
  /**
   * Alias for {@link Mat4.multiply}
   * @category Methods
   */
  mul(b) {
    return this;
  }
  // eslint-disable-line @typescript-eslint/no-unused-vars
  /**
   * Transpose this {@link Mat4}
   * Equivalent to `Mat4.transpose(this, this);`
   * @category Methods
   *
   * @returns `this`
   */
  transpose() {
    return _Mat4.transpose(this, this);
  }
  /**
   * Inverts this {@link Mat4}
   * Equivalent to `Mat4.invert(this, this);`
   * @category Methods
   *
   * @returns `this`
   */
  invert() {
    return _Mat4.invert(this, this);
  }
  /**
   * Translate this {@link Mat4} by the given vector
   * Equivalent to `Mat4.translate(this, this, v);`
   * @category Methods
   *
   * @param v - The {@link Vec3} to translate by
   * @returns `this`
   */
  translate(v) {
    return _Mat4.translate(this, this, v);
  }
  /**
   * Rotates this {@link Mat4} by the given angle around the given axis
   * Equivalent to `Mat4.rotate(this, this, rad, axis);`
   * @category Methods
   *
   * @param rad - the angle to rotate the matrix by
   * @param axis - the axis to rotate around
   * @returns `this`
   */
  rotate(rad, axis) {
    return _Mat4.rotate(this, this, rad, axis);
  }
  /**
   * Scales this {@link Mat4} by the dimensions in the given vec3 not using vectorization
   * Equivalent to `Mat4.scale(this, this, v);`
   * @category Methods
   *
   * @param v - The {@link Vec3} to scale the matrix by
   * @returns `this`
   */
  scale(v) {
    return _Mat4.scale(this, this, v);
  }
  /**
   * Rotates this {@link Mat4} by the given angle around the X axis
   * Equivalent to `Mat4.rotateX(this, this, rad);`
   * @category Methods
   *
   * @param rad - the angle to rotate the matrix by
   * @returns `this`
   */
  rotateX(rad) {
    return _Mat4.rotateX(this, this, rad);
  }
  /**
   * Rotates this {@link Mat4} by the given angle around the Y axis
   * Equivalent to `Mat4.rotateY(this, this, rad);`
   * @category Methods
   *
   * @param rad - the angle to rotate the matrix by
   * @returns `this`
   */
  rotateY(rad) {
    return _Mat4.rotateY(this, this, rad);
  }
  /**
   * Rotates this {@link Mat4} by the given angle around the Z axis
   * Equivalent to `Mat4.rotateZ(this, this, rad);`
   * @category Methods
   *
   * @param rad - the angle to rotate the matrix by
   * @returns `this`
   */
  rotateZ(rad) {
    return _Mat4.rotateZ(this, this, rad);
  }
  /**
   * Generates a perspective projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
   * which matches WebGL/OpenGL's clip volume.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   * Equivalent to `Mat4.perspectiveNO(this, fovy, aspect, near, far);`
   * @category Methods
   *
   * @param fovy - Vertical field of view in radians
   * @param aspect - Aspect ratio. typically viewport width/height
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum, can be null or Infinity
   * @returns `this`
   */
  perspectiveNO(fovy, aspect, near, far) {
    return _Mat4.perspectiveNO(this, fovy, aspect, near, far);
  }
  /**
   * Generates a perspective projection matrix suitable for WebGPU with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
   * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   * Equivalent to `Mat4.perspectiveZO(this, fovy, aspect, near, far);`
   * @category Methods
   *
   * @param fovy - Vertical field of view in radians
   * @param aspect - Aspect ratio. typically viewport width/height
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum, can be null or Infinity
   * @returns `this`
   */
  perspectiveZO(fovy, aspect, near, far) {
    return _Mat4.perspectiveZO(this, fovy, aspect, near, far);
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
   * which matches WebGL/OpenGL's clip volume.
   * Equivalent to `Mat4.orthoNO(this, left, right, bottom, top, near, far);`
   * @category Methods
   *
   * @param left - Left bound of the frustum
   * @param right - Right bound of the frustum
   * @param bottom - Bottom bound of the frustum
   * @param top - Top bound of the frustum
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum
   * @returns `this`
   */
  orthoNO(left, right, bottom, top, near, far) {
    return _Mat4.orthoNO(this, left, right, bottom, top, near, far);
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
   * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
   * Equivalent to `Mat4.orthoZO(this, left, right, bottom, top, near, far);`
   * @category Methods
   *
   * @param left - Left bound of the frustum
   * @param right - Right bound of the frustum
   * @param bottom - Bottom bound of the frustum
   * @param top - Top bound of the frustum
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum
   * @returns `this`
   */
  orthoZO(left, right, bottom, top, near, far) {
    return _Mat4.orthoZO(this, left, right, bottom, top, near, far);
  }
  // ===================
  // Static accessors
  // ===================
  /**
   * @category Static
   *
   * @returns The number of bytes in a {@link Mat4}.
   */
  static get BYTE_LENGTH() {
    return 16 * Float32Array.BYTES_PER_ELEMENT;
  }
  // ===================
  // Static methods
  // ===================
  /**
   * Creates a new, identity {@link Mat4}
   * @category Static
   *
   * @returns A new {@link Mat4}
   */
  static create() {
    return new _Mat4();
  }
  /**
   * Creates a new {@link Mat4} initialized with values from an existing matrix
   * @category Static
   *
   * @param a - Matrix to clone
   * @returns A new {@link Mat4}
   */
  static clone(a) {
    return new _Mat4(a);
  }
  /**
   * Copy the values from one {@link Mat4} to another
   * @category Static
   *
   * @param out - The receiving Matrix
   * @param a - Matrix to copy
   * @returns `out`
   */
  static copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  /**
   * Create a new mat4 with the given values
   * @category Static
   *
   * @param values - Matrix components
   * @returns A new {@link Mat4}
   */
  static fromValues(...values) {
    return new _Mat4(...values);
  }
  /**
   * Set the components of a mat4 to the given values
   * @category Static
   *
   * @param out - The receiving matrix
   * @param values - Matrix components
   * @returns `out`
   */
  static set(out, ...values) {
    out[0] = values[0];
    out[1] = values[1];
    out[2] = values[2];
    out[3] = values[3];
    out[4] = values[4];
    out[5] = values[5];
    out[6] = values[6];
    out[7] = values[7];
    out[8] = values[8];
    out[9] = values[9];
    out[10] = values[10];
    out[11] = values[11];
    out[12] = values[12];
    out[13] = values[13];
    out[14] = values[14];
    out[15] = values[15];
    return out;
  }
  /**
   * Set a {@link Mat4} to the identity matrix
   * @category Static
   *
   * @param out - The receiving Matrix
   * @returns `out`
   */
  static identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Transpose the values of a {@link Mat4}
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the source matrix
   * @returns `out`
   */
  static transpose(out, a) {
    if (out === a) {
      const a01 = a[1], a02 = a[2], a03 = a[3];
      const a12 = a[6], a13 = a[7];
      const a23 = a[11];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a01;
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a02;
      out[9] = a12;
      out[11] = a[14];
      out[12] = a03;
      out[13] = a13;
      out[14] = a23;
    } else {
      out[0] = a[0];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a[1];
      out[5] = a[5];
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a[2];
      out[9] = a[6];
      out[10] = a[10];
      out[11] = a[14];
      out[12] = a[3];
      out[13] = a[7];
      out[14] = a[11];
      out[15] = a[15];
    }
    return out;
  }
  /**
   * Inverts a {@link Mat4}
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the source matrix
   * @returns `out` or `null` if the matrix is not invertible
   */
  static invert(out, a) {
    const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    const a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    const b00 = a00 * a11 - a01 * a10;
    const b01 = a00 * a12 - a02 * a10;
    const b02 = a00 * a13 - a03 * a10;
    const b03 = a01 * a12 - a02 * a11;
    const b04 = a01 * a13 - a03 * a11;
    const b05 = a02 * a13 - a03 * a12;
    const b06 = a20 * a31 - a21 * a30;
    const b07 = a20 * a32 - a22 * a30;
    const b08 = a20 * a33 - a23 * a30;
    const b09 = a21 * a32 - a22 * a31;
    const b10 = a21 * a33 - a23 * a31;
    const b11 = a22 * a33 - a23 * a32;
    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
  }
  /**
   * Calculates the adjugate of a {@link Mat4}
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the source matrix
   * @returns `out`
   */
  static adjoint(out, a) {
    const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    const a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    const b00 = a00 * a11 - a01 * a10;
    const b01 = a00 * a12 - a02 * a10;
    const b02 = a00 * a13 - a03 * a10;
    const b03 = a01 * a12 - a02 * a11;
    const b04 = a01 * a13 - a03 * a11;
    const b05 = a02 * a13 - a03 * a12;
    const b06 = a20 * a31 - a21 * a30;
    const b07 = a20 * a32 - a22 * a30;
    const b08 = a20 * a33 - a23 * a30;
    const b09 = a21 * a32 - a22 * a31;
    const b10 = a21 * a33 - a23 * a31;
    const b11 = a22 * a33 - a23 * a32;
    out[0] = a11 * b11 - a12 * b10 + a13 * b09;
    out[1] = a02 * b10 - a01 * b11 - a03 * b09;
    out[2] = a31 * b05 - a32 * b04 + a33 * b03;
    out[3] = a22 * b04 - a21 * b05 - a23 * b03;
    out[4] = a12 * b08 - a10 * b11 - a13 * b07;
    out[5] = a00 * b11 - a02 * b08 + a03 * b07;
    out[6] = a32 * b02 - a30 * b05 - a33 * b01;
    out[7] = a20 * b05 - a22 * b02 + a23 * b01;
    out[8] = a10 * b10 - a11 * b08 + a13 * b06;
    out[9] = a01 * b08 - a00 * b10 - a03 * b06;
    out[10] = a30 * b04 - a31 * b02 + a33 * b00;
    out[11] = a21 * b02 - a20 * b04 - a23 * b00;
    out[12] = a11 * b07 - a10 * b09 - a12 * b06;
    out[13] = a00 * b09 - a01 * b07 + a02 * b06;
    out[14] = a31 * b01 - a30 * b03 - a32 * b00;
    out[15] = a20 * b03 - a21 * b01 + a22 * b00;
    return out;
  }
  /**
   * Calculates the determinant of a {@link Mat4}
   * @category Static
   *
   * @param a - the source matrix
   * @returns determinant of a
   */
  static determinant(a) {
    const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    const a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    const b0 = a00 * a11 - a01 * a10;
    const b1 = a00 * a12 - a02 * a10;
    const b2 = a01 * a12 - a02 * a11;
    const b3 = a20 * a31 - a21 * a30;
    const b4 = a20 * a32 - a22 * a30;
    const b5 = a21 * a32 - a22 * a31;
    const b6 = a00 * b5 - a01 * b4 + a02 * b3;
    const b7 = a10 * b5 - a11 * b4 + a12 * b3;
    const b8 = a20 * b2 - a21 * b1 + a22 * b0;
    const b9 = a30 * b2 - a31 * b1 + a32 * b0;
    return a13 * b6 - a03 * b7 + a33 * b8 - a23 * b9;
  }
  /**
   * Multiplies two {@link Mat4}s
   * @category Static
   *
   * @param out - The receiving Matrix
   * @param a - The first operand
   * @param b - The second operand
   * @returns `out`
   */
  static multiply(out, a, b) {
    const a00 = a[0];
    const a01 = a[1];
    const a02 = a[2];
    const a03 = a[3];
    const a10 = a[4];
    const a11 = a[5];
    const a12 = a[6];
    const a13 = a[7];
    const a20 = a[8];
    const a21 = a[9];
    const a22 = a[10];
    const a23 = a[11];
    const a30 = a[12];
    const a31 = a[13];
    const a32 = a[14];
    const a33 = a[15];
    let b0 = b[0];
    let b1 = b[1];
    let b2 = b[2];
    let b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
  }
  /**
   * Alias for {@link Mat4.multiply}
   * @category Static
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static mul(out, a, b) {
    return out;
  }
  /**
   * Translate a {@link Mat4} by the given vector
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to translate
   * @param v - vector to translate by
   * @returns `out`
   */
  static translate(out, a, v) {
    const x = v[0];
    const y = v[1];
    const z = v[2];
    if (a === out) {
      out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
      out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
      out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
      out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
      const a00 = a[0];
      const a01 = a[1];
      const a02 = a[2];
      const a03 = a[3];
      const a10 = a[4];
      const a11 = a[5];
      const a12 = a[6];
      const a13 = a[7];
      const a20 = a[8];
      const a21 = a[9];
      const a22 = a[10];
      const a23 = a[11];
      out[0] = a00;
      out[1] = a01;
      out[2] = a02;
      out[3] = a03;
      out[4] = a10;
      out[5] = a11;
      out[6] = a12;
      out[7] = a13;
      out[8] = a20;
      out[9] = a21;
      out[10] = a22;
      out[11] = a23;
      out[12] = a00 * x + a10 * y + a20 * z + a[12];
      out[13] = a01 * x + a11 * y + a21 * z + a[13];
      out[14] = a02 * x + a12 * y + a22 * z + a[14];
      out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }
    return out;
  }
  /**
   * Scales the {@link Mat4} by the dimensions in the given {@link Vec3} not using vectorization
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to scale
   * @param v - the {@link Vec3} to scale the matrix by
   * @returns `out`
   **/
  static scale(out, a, v) {
    const x = v[0];
    const y = v[1];
    const z = v[2];
    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  /**
   * Rotates a {@link Mat4} by the given angle around the given axis
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to rotate
   * @param rad - the angle to rotate the matrix by
   * @param axis - the axis to rotate around
   * @returns `out` or `null` if axis has a length of 0
   */
  static rotate(out, a, rad, axis) {
    let x = axis[0];
    let y = axis[1];
    let z = axis[2];
    let len = Math.sqrt(x * x + y * y + z * z);
    if (len < GLM_EPSILON) {
      return null;
    }
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    const s = Math.sin(rad);
    const c = Math.cos(rad);
    const t = 1 - c;
    const a00 = a[0];
    const a01 = a[1];
    const a02 = a[2];
    const a03 = a[3];
    const a10 = a[4];
    const a11 = a[5];
    const a12 = a[6];
    const a13 = a[7];
    const a20 = a[8];
    const a21 = a[9];
    const a22 = a[10];
    const a23 = a[11];
    const b00 = x * x * t + c;
    const b01 = y * x * t + z * s;
    const b02 = z * x * t - y * s;
    const b10 = x * y * t - z * s;
    const b11 = y * y * t + c;
    const b12 = z * y * t + x * s;
    const b20 = x * z * t + y * s;
    const b21 = y * z * t - x * s;
    const b22 = z * z * t + c;
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;
    if (a !== out) {
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    return out;
  }
  /**
   * Rotates a matrix by the given angle around the X axis
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to rotate
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static rotateX(out, a, rad) {
    const s = Math.sin(rad);
    const c = Math.cos(rad);
    const a10 = a[4];
    const a11 = a[5];
    const a12 = a[6];
    const a13 = a[7];
    const a20 = a[8];
    const a21 = a[9];
    const a22 = a[10];
    const a23 = a[11];
    if (a !== out) {
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      out[3] = a[3];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
  }
  /**
   * Rotates a matrix by the given angle around the Y axis
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to rotate
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static rotateY(out, a, rad) {
    const s = Math.sin(rad);
    const c = Math.cos(rad);
    const a00 = a[0];
    const a01 = a[1];
    const a02 = a[2];
    const a03 = a[3];
    const a20 = a[8];
    const a21 = a[9];
    const a22 = a[10];
    const a23 = a[11];
    if (a !== out) {
      out[4] = a[4];
      out[5] = a[5];
      out[6] = a[6];
      out[7] = a[7];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
  }
  /**
   * Rotates a matrix by the given angle around the Z axis
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to rotate
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static rotateZ(out, a, rad) {
    const s = Math.sin(rad);
    const c = Math.cos(rad);
    const a00 = a[0];
    const a01 = a[1];
    const a02 = a[2];
    const a03 = a[3];
    const a10 = a[4];
    const a11 = a[5];
    const a12 = a[6];
    const a13 = a[7];
    if (a !== out) {
      out[8] = a[8];
      out[9] = a[9];
      out[10] = a[10];
      out[11] = a[11];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
  }
  /**
   * Creates a {@link Mat4} from a vector translation
   * This is equivalent to (but much faster than):
   * ```js
   *   mat4.identity(dest);
   *   mat4.translate(dest, dest, vec);
   * ```
   * @category Static
   *
   * @param out - {@link Mat4} receiving operation result
   * @param v - Translation vector
   * @returns `out`
   */
  static fromTranslation(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  /**
   * Creates a {@link Mat4} from a vector scaling
   * This is equivalent to (but much faster than):
   * ```js
   *   mat4.identity(dest);
   *   mat4.scale(dest, dest, vec);
   * ```
   * @category Static
   *
   * @param out - {@link Mat4} receiving operation result
   * @param v - Scaling vector
   * @returns `out`
   */
  static fromScaling(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a {@link Mat4} from a given angle around a given axis
   * This is equivalent to (but much faster than):
   * ```js
   *   mat4.identity(dest);
   *   mat4.rotate(dest, dest, rad, axis);
   * ```
   * @category Static
   *
   * @param out - {@link Mat4} receiving operation result
   * @param rad - the angle to rotate the matrix by
   * @param axis - the axis to rotate around
   * @returns `out` or `null` if `axis` has a length of 0
   */
  static fromRotation(out, rad, axis) {
    let x = axis[0];
    let y = axis[1];
    let z = axis[2];
    let len = Math.sqrt(x * x + y * y + z * z);
    if (len < GLM_EPSILON) {
      return null;
    }
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    const s = Math.sin(rad);
    const c = Math.cos(rad);
    const t = 1 - c;
    out[0] = x * x * t + c;
    out[1] = y * x * t + z * s;
    out[2] = z * x * t - y * s;
    out[3] = 0;
    out[4] = x * y * t - z * s;
    out[5] = y * y * t + c;
    out[6] = z * y * t + x * s;
    out[7] = 0;
    out[8] = x * z * t + y * s;
    out[9] = y * z * t - x * s;
    out[10] = z * z * t + c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from the given angle around the X axis
   * This is equivalent to (but much faster than):
   * ```js
   *   mat4.identity(dest);
   *   mat4.rotateX(dest, dest, rad);
   * ```
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static fromXRotation(out, rad) {
    const s = Math.sin(rad);
    const c = Math.cos(rad);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = c;
    out[6] = s;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from the given angle around the Y axis
   * This is equivalent to (but much faster than):
   * ```js
   *   mat4.identity(dest);
   *   mat4.rotateY(dest, dest, rad);
   * ```
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static fromYRotation(out, rad) {
    const s = Math.sin(rad);
    const c = Math.cos(rad);
    out[0] = c;
    out[1] = 0;
    out[2] = -s;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from the given angle around the Z axis
   * This is equivalent to (but much faster than):
   * ```js
   *   mat4.identity(dest);
   *   mat4.rotateZ(dest, dest, rad);
   * ```
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static fromZRotation(out, rad) {
    const s = Math.sin(rad);
    const c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from a quaternion rotation and vector translation
   * This is equivalent to (but much faster than):
   * ```js
   *   mat4.identity(dest);
   *   mat4.translate(dest, vec);
   *   let quatMat = mat4.create();
   *   quat4.toMat4(quat, quatMat);
   *   mat4.multiply(dest, quatMat);
   * ```
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param q - Rotation quaternion
   * @param v - Translation vector
   * @returns `out`
   */
  static fromRotationTranslation(out, q, v) {
    const x = q[0];
    const y = q[1];
    const z = q[2];
    const w = q[3];
    const x2 = x + x;
    const y2 = y + y;
    const z2 = z + z;
    const xx = x * x2;
    const xy = x * y2;
    const xz = x * z2;
    const yy = y * y2;
    const yz = y * z2;
    const zz = z * z2;
    const wx = w * x2;
    const wy = w * y2;
    const wz = w * z2;
    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  /**
   * Sets a {@link Mat4} from a {@link Quat2}.
   * @category Static
   *
   * @param out - Matrix
   * @param a - Dual Quaternion
   * @returns `out`
   */
  static fromQuat2(out, a) {
    const bx = -a[0];
    const by = -a[1];
    const bz = -a[2];
    const bw = a[3];
    const ax = a[4];
    const ay = a[5];
    const az = a[6];
    const aw = a[7];
    const magnitude = bx * bx + by * by + bz * bz + bw * bw;
    if (magnitude > 0) {
      _Mat4.#TMP_VEC3[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
      _Mat4.#TMP_VEC3[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
      _Mat4.#TMP_VEC3[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
    } else {
      _Mat4.#TMP_VEC3[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
      _Mat4.#TMP_VEC3[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
      _Mat4.#TMP_VEC3[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
    }
    _Mat4.fromRotationTranslation(out, a, _Mat4.#TMP_VEC3);
    return out;
  }
  /**
   * Calculates a {@link Mat4} normal matrix (transpose inverse) from a {@link Mat4}
   * @category Static
   *
   * @param out - Matrix receiving operation result
   * @param a - Mat4 to derive the normal matrix from
   * @returns `out` or `null` if the matrix is not invertible
   */
  static normalFromMat4(out, a) {
    const a00 = a[0];
    const a01 = a[1];
    const a02 = a[2];
    const a03 = a[3];
    const a10 = a[4];
    const a11 = a[5];
    const a12 = a[6];
    const a13 = a[7];
    const a20 = a[8];
    const a21 = a[9];
    const a22 = a[10];
    const a23 = a[11];
    const a30 = a[12];
    const a31 = a[13];
    const a32 = a[14];
    const a33 = a[15];
    const b00 = a00 * a11 - a01 * a10;
    const b01 = a00 * a12 - a02 * a10;
    const b02 = a00 * a13 - a03 * a10;
    const b03 = a01 * a12 - a02 * a11;
    const b04 = a01 * a13 - a03 * a11;
    const b05 = a02 * a13 - a03 * a12;
    const b06 = a20 * a31 - a21 * a30;
    const b07 = a20 * a32 - a22 * a30;
    const b08 = a20 * a33 - a23 * a30;
    const b09 = a21 * a32 - a22 * a31;
    const b10 = a21 * a33 - a23 * a31;
    const b11 = a22 * a33 - a23 * a32;
    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[3] = 0;
    out[4] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[7] = 0;
    out[8] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[9] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Calculates a {@link Mat4} normal matrix (transpose inverse) from a {@link Mat4}
   * This version omits the calculation of the constant factor (1/determinant), so
   * any normals transformed with it will need to be renormalized.
   * From https://stackoverflow.com/a/27616419/25968
   * @category Static
   *
   * @param out - Matrix receiving operation result
   * @param a - Mat4 to derive the normal matrix from
   * @returns `out`
   */
  static normalFromMat4Fast(out, a) {
    const ax = a[0];
    const ay = a[1];
    const az = a[2];
    const bx = a[4];
    const by = a[5];
    const bz = a[6];
    const cx = a[8];
    const cy = a[9];
    const cz = a[10];
    out[0] = by * cz - cz * cy;
    out[1] = bz * cx - cx * cz;
    out[2] = bx * cy - cy * cx;
    out[3] = 0;
    out[4] = cy * az - cz * ay;
    out[5] = cz * ax - cx * az;
    out[6] = cx * ay - cy * ax;
    out[7] = 0;
    out[8] = ay * bz - az * by;
    out[9] = az * bx - ax * bz;
    out[10] = ax * by - ay * bx;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Returns the translation vector component of a transformation
   * matrix. If a matrix is built with fromRotationTranslation,
   * the returned vector will be the same as the translation vector
   * originally supplied.
   * @category Static
   *
   * @param  {vec3} out Vector to receive translation component
   * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
   * @return {vec3} out
   */
  static getTranslation(out, mat) {
    out[0] = mat[12];
    out[1] = mat[13];
    out[2] = mat[14];
    return out;
  }
  /**
   * Returns the scaling factor component of a transformation
   * matrix. If a matrix is built with fromRotationTranslationScale
   * with a normalized Quaternion parameter, the returned vector will be
   * the same as the scaling vector
   * originally supplied.
   * @category Static
   *
   * @param  {vec3} out Vector to receive scaling factor component
   * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
   * @return {vec3} out
   */
  static getScaling(out, mat) {
    const m11 = mat[0];
    const m12 = mat[1];
    const m13 = mat[2];
    const m21 = mat[4];
    const m22 = mat[5];
    const m23 = mat[6];
    const m31 = mat[8];
    const m32 = mat[9];
    const m33 = mat[10];
    out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
    out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
    out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
    return out;
  }
  /**
   * Returns a quaternion representing the rotational component
   * of a transformation matrix. If a matrix is built with
   * fromRotationTranslation, the returned quaternion will be the
   * same as the quaternion originally supplied.
   * @category Static
   *
   * @param out - Quaternion to receive the rotation component
   * @param mat - Matrix to be decomposed (input)
   * @return `out`
   */
  static getRotation(out, mat) {
    _Mat4.getScaling(_Mat4.#TMP_VEC3, mat);
    const is1 = 1 / _Mat4.#TMP_VEC3[0];
    const is2 = 1 / _Mat4.#TMP_VEC3[1];
    const is3 = 1 / _Mat4.#TMP_VEC3[2];
    const sm11 = mat[0] * is1;
    const sm12 = mat[1] * is2;
    const sm13 = mat[2] * is3;
    const sm21 = mat[4] * is1;
    const sm22 = mat[5] * is2;
    const sm23 = mat[6] * is3;
    const sm31 = mat[8] * is1;
    const sm32 = mat[9] * is2;
    const sm33 = mat[10] * is3;
    const trace = sm11 + sm22 + sm33;
    let S = 0;
    if (trace > 0) {
      S = Math.sqrt(trace + 1) * 2;
      out[3] = 0.25 * S;
      out[0] = (sm23 - sm32) / S;
      out[1] = (sm31 - sm13) / S;
      out[2] = (sm12 - sm21) / S;
    } else if (sm11 > sm22 && sm11 > sm33) {
      S = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
      out[3] = (sm23 - sm32) / S;
      out[0] = 0.25 * S;
      out[1] = (sm12 + sm21) / S;
      out[2] = (sm31 + sm13) / S;
    } else if (sm22 > sm33) {
      S = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
      out[3] = (sm31 - sm13) / S;
      out[0] = (sm12 + sm21) / S;
      out[1] = 0.25 * S;
      out[2] = (sm23 + sm32) / S;
    } else {
      S = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
      out[3] = (sm12 - sm21) / S;
      out[0] = (sm31 + sm13) / S;
      out[1] = (sm23 + sm32) / S;
      out[2] = 0.25 * S;
    }
    return out;
  }
  /**
   * Decomposes a transformation matrix into its rotation, translation
   * and scale components. Returns only the rotation component
   * @category Static
   *
   * @param out_r - Quaternion to receive the rotation component
   * @param out_t - Vector to receive the translation vector
   * @param out_s - Vector to receive the scaling factor
   * @param mat - Matrix to be decomposed (input)
   * @returns `out_r`
   */
  static decompose(out_r, out_t, out_s, mat) {
    out_t[0] = mat[12];
    out_t[1] = mat[13];
    out_t[2] = mat[14];
    const m11 = mat[0];
    const m12 = mat[1];
    const m13 = mat[2];
    const m21 = mat[4];
    const m22 = mat[5];
    const m23 = mat[6];
    const m31 = mat[8];
    const m32 = mat[9];
    const m33 = mat[10];
    out_s[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
    out_s[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
    out_s[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
    const is1 = 1 / out_s[0];
    const is2 = 1 / out_s[1];
    const is3 = 1 / out_s[2];
    const sm11 = m11 * is1;
    const sm12 = m12 * is2;
    const sm13 = m13 * is3;
    const sm21 = m21 * is1;
    const sm22 = m22 * is2;
    const sm23 = m23 * is3;
    const sm31 = m31 * is1;
    const sm32 = m32 * is2;
    const sm33 = m33 * is3;
    const trace = sm11 + sm22 + sm33;
    let S = 0;
    if (trace > 0) {
      S = Math.sqrt(trace + 1) * 2;
      out_r[3] = 0.25 * S;
      out_r[0] = (sm23 - sm32) / S;
      out_r[1] = (sm31 - sm13) / S;
      out_r[2] = (sm12 - sm21) / S;
    } else if (sm11 > sm22 && sm11 > sm33) {
      S = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
      out_r[3] = (sm23 - sm32) / S;
      out_r[0] = 0.25 * S;
      out_r[1] = (sm12 + sm21) / S;
      out_r[2] = (sm31 + sm13) / S;
    } else if (sm22 > sm33) {
      S = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
      out_r[3] = (sm31 - sm13) / S;
      out_r[0] = (sm12 + sm21) / S;
      out_r[1] = 0.25 * S;
      out_r[2] = (sm23 + sm32) / S;
    } else {
      S = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
      out_r[3] = (sm12 - sm21) / S;
      out_r[0] = (sm31 + sm13) / S;
      out_r[1] = (sm23 + sm32) / S;
      out_r[2] = 0.25 * S;
    }
    return out_r;
  }
  /**
   * Creates a matrix from a quaternion rotation, vector translation and vector scale
   * This is equivalent to (but much faster than):
   * ```js
   *   mat4.identity(dest);
   *   mat4.translate(dest, vec);
   *   let quatMat = mat4.create();
   *   quat4.toMat4(quat, quatMat);
   *   mat4.multiply(dest, quatMat);
   *   mat4.scale(dest, scale);
   * ```
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param q - Rotation quaternion
   * @param v - Translation vector
   * @param s - Scaling vector
   * @returns `out`
   */
  static fromRotationTranslationScale(out, q, v, s) {
    const x = q[0];
    const y = q[1];
    const z = q[2];
    const w = q[3];
    const x2 = x + x;
    const y2 = y + y;
    const z2 = z + z;
    const xx = x * x2;
    const xy = x * y2;
    const xz = x * z2;
    const yy = y * y2;
    const yz = y * z2;
    const zz = z * z2;
    const wx = w * x2;
    const wy = w * y2;
    const wz = w * z2;
    const sx = s[0];
    const sy = s[1];
    const sz = s[2];
    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the
   * given origin. This is equivalent to (but much faster than):
   * ```js
   *   mat4.identity(dest);
   *   mat4.translate(dest, vec);
   *   mat4.translate(dest, origin);
   *   let quatMat = mat4.create();
   *   quat4.toMat4(quat, quatMat);
   *   mat4.multiply(dest, quatMat);
   *   mat4.scale(dest, scale)
   *   mat4.translate(dest, negativeOrigin);
   * ```
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param q - Rotation quaternion
   * @param v - Translation vector
   * @param s - Scaling vector
   * @param o - The origin vector around which to scale and rotate
   * @returns `out`
   */
  static fromRotationTranslationScaleOrigin(out, q, v, s, o) {
    const x = q[0];
    const y = q[1];
    const z = q[2];
    const w = q[3];
    const x2 = x + x;
    const y2 = y + y;
    const z2 = z + z;
    const xx = x * x2;
    const xy = x * y2;
    const xz = x * z2;
    const yy = y * y2;
    const yz = y * z2;
    const zz = z * z2;
    const wx = w * x2;
    const wy = w * y2;
    const wz = w * z2;
    const sx = s[0];
    const sy = s[1];
    const sz = s[2];
    const ox = o[0];
    const oy = o[1];
    const oz = o[2];
    const out0 = (1 - (yy + zz)) * sx;
    const out1 = (xy + wz) * sx;
    const out2 = (xz - wy) * sx;
    const out4 = (xy - wz) * sy;
    const out5 = (1 - (xx + zz)) * sy;
    const out6 = (yz + wx) * sy;
    const out8 = (xz + wy) * sz;
    const out9 = (yz - wx) * sz;
    const out10 = (1 - (xx + yy)) * sz;
    out[0] = out0;
    out[1] = out1;
    out[2] = out2;
    out[3] = 0;
    out[4] = out4;
    out[5] = out5;
    out[6] = out6;
    out[7] = 0;
    out[8] = out8;
    out[9] = out9;
    out[10] = out10;
    out[11] = 0;
    out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
    out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
    out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
    out[15] = 1;
    return out;
  }
  /**
   * Calculates a 4x4 matrix from the given quaternion
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param q - Quaternion to create matrix from
   * @returns `out`
   */
  static fromQuat(out, q) {
    const x = q[0];
    const y = q[1];
    const z = q[2];
    const w = q[3];
    const x2 = x + x;
    const y2 = y + y;
    const z2 = z + z;
    const xx = x * x2;
    const yx = y * x2;
    const yy = y * y2;
    const zx = z * x2;
    const zy = z * y2;
    const zz = z * z2;
    const wx = w * x2;
    const wy = w * y2;
    const wz = w * z2;
    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;
    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;
    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Generates a frustum matrix with the given bounds
   * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
   * which matches WebGL/OpenGL's clip volume.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param left - Left bound of the frustum
   * @param right - Right bound of the frustum
   * @param bottom - Bottom bound of the frustum
   * @param top - Top bound of the frustum
   * @param near - Near bound of the frustum
   * @param far -  Far bound of the frustum, can be null or Infinity
   * @returns `out`
   */
  static frustumNO(out, left, right, bottom, top, near, far = Infinity) {
    const rl = 1 / (right - left);
    const tb = 1 / (top - bottom);
    out[0] = near * 2 * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = near * 2 * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
      const nf = 1 / (near - far);
      out[10] = (far + near) * nf;
      out[14] = 2 * far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -2 * near;
    }
    return out;
  }
  /**
   * Alias for {@link Mat4.frustumNO}
   * @category Static
   * @deprecated Use {@link Mat4.frustumNO} or {@link Mat4.frustumZO} explicitly
   */
  static frustum(out, left, right, bottom, top, near, far = Infinity) {
    return out;
  }
  // eslint-disable-line @typescript-eslint/no-unused-vars
  /**
   * Generates a frustum matrix with the given bounds
   * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
   * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param left - Left bound of the frustum
   * @param right - Right bound of the frustum
   * @param bottom - Bottom bound of the frustum
   * @param top - Top bound of the frustum
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum, can be null or Infinity
   * @returns `out`
   */
  static frustumZO(out, left, right, bottom, top, near, far = Infinity) {
    const rl = 1 / (right - left);
    const tb = 1 / (top - bottom);
    out[0] = near * 2 * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = near * 2 * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
      const nf = 1 / (near - far);
      out[10] = far * nf;
      out[14] = far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -near;
    }
    return out;
  }
  /**
   * Generates a perspective projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
   * which matches WebGL/OpenGL's clip volume.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param fovy - Vertical field of view in radians
   * @param aspect - Aspect ratio. typically viewport width/height
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum, can be null or Infinity
   * @returns `out`
   */
  static perspectiveNO(out, fovy, aspect, near, far = Infinity) {
    const f = 1 / Math.tan(fovy / 2);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
      const nf = 1 / (near - far);
      out[10] = (far + near) * nf;
      out[14] = 2 * far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -2 * near;
    }
    return out;
  }
  /**
   * Alias for {@link Mat4.perspectiveNO}
   * @category Static
   * @deprecated Use {@link Mat4.perspectiveNO} or {@link Mat4.perspectiveZO} explicitly
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static perspective(out, fovy, aspect, near, far = Infinity) {
    return out;
  }
  /**
   * Generates a perspective projection matrix suitable for WebGPU with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
   * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param fovy - Vertical field of view in radians
   * @param aspect - Aspect ratio. typically viewport width/height
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum, can be null or Infinity
   * @returns `out`
   */
  static perspectiveZO(out, fovy, aspect, near, far = Infinity) {
    const f = 1 / Math.tan(fovy / 2);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
      const nf = 1 / (near - far);
      out[10] = far * nf;
      out[14] = far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -near;
    }
    return out;
  }
  /**
   * Generates a perspective projection matrix with the given field of view. This is primarily useful for generating
   * projection matrices to be used with the still experimental WebVR API.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param fov - Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum
   * @returns `out`
   * @deprecated
   */
  static perspectiveFromFieldOfView(out, fov, near, far) {
    const upTan = Math.tan(fov.upDegrees * Math.PI / 180);
    const downTan = Math.tan(fov.downDegrees * Math.PI / 180);
    const leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
    const rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
    const xScale = 2 / (leftTan + rightTan);
    const yScale = 2 / (upTan + downTan);
    out[0] = xScale;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = yScale;
    out[6] = 0;
    out[7] = 0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = (upTan - downTan) * yScale * 0.5;
    out[10] = far / (near - far);
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near / (near - far);
    out[15] = 0;
    return out;
  }
  /**
   * Generates an orthogonal projection matrix with the given bounds. The near / far clip planes correspond to a
   * normalized device coordinate Z range of [-1, 1], which matches WebGL / OpenGLs clip volume.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param left - Left bound of the frustum
   * @param right - Right bound of the frustum
   * @param bottom - Bottom bound of the frustum
   * @param top - Top bound of the frustum
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum
   * @returns `out`
   */
  static orthoNO(out, left, right, bottom, top, near, far) {
    const lr = 1 / (left - right);
    const bt = 1 / (bottom - top);
    const nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  }
  /**
   * Alias for {@link Mat4.orthoNO}
   * @category Static
   * @deprecated Use {@link Mat4.orthoNO} or {@link Mat4.orthoZO} explicitly
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static ortho(out, left, right, bottom, top, near, far) {
    return out;
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds. The near / far clip planes correspond to a
   * normalized device coordinate Z range of [0, 1], which matches WebGPU / Vulkan / DirectX / Metal's clip volume.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param left - Left bound of the frustum
   * @param right - Right bound of the frustum
   * @param bottom - Bottom bound of the frustum
   * @param top - Top bound of the frustum
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum
   * @returns `out`
   */
  static orthoZO(out, left, right, bottom, top, near, far) {
    const lr = 1 / (left - right);
    const bt = 1 / (bottom - top);
    const nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = near * nf;
    out[15] = 1;
    return out;
  }
  /**
   * Generates a look-at matrix with the given eye position, focal point, and up axis. If you want a matrix that
   * actually makes an object look at another object, you should use targetTo instead.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param eye - Position of the viewer
   * @param center - Point the viewer is looking at
   * @param up - vec3 pointing up
   * @returns `out`
   */
  static lookAt(out, eye, center, up) {
    const eyex = eye[0];
    const eyey = eye[1];
    const eyez = eye[2];
    const upx = up[0];
    const upy = up[1];
    const upz = up[2];
    const centerx = center[0];
    const centery = center[1];
    const centerz = center[2];
    if (Math.abs(eyex - centerx) < GLM_EPSILON && Math.abs(eyey - centery) < GLM_EPSILON && Math.abs(eyez - centerz) < GLM_EPSILON) {
      return _Mat4.identity(out);
    }
    let z0 = eyex - centerx;
    let z1 = eyey - centery;
    let z2 = eyez - centerz;
    let len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;
    let x0 = upy * z2 - upz * z1;
    let x1 = upz * z0 - upx * z2;
    let x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
      x0 = 0;
      x1 = 0;
      x2 = 0;
    } else {
      len = 1 / len;
      x0 *= len;
      x1 *= len;
      x2 *= len;
    }
    let y0 = z1 * x2 - z2 * x1;
    let y1 = z2 * x0 - z0 * x2;
    let y2 = z0 * x1 - z1 * x0;
    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
      y0 = 0;
      y1 = 0;
      y2 = 0;
    } else {
      len = 1 / len;
      y0 *= len;
      y1 *= len;
      y2 *= len;
    }
    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
  }
  /**
   * Generates a matrix that makes something look at something else.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param eye - Position of the viewer
   * @param target - Point the viewer is looking at
   * @param up - vec3 pointing up
   * @returns `out`
   */
  static targetTo(out, eye, target, up) {
    const eyex = eye[0];
    const eyey = eye[1];
    const eyez = eye[2];
    const upx = up[0];
    const upy = up[1];
    const upz = up[2];
    let z0 = eyex - target[0];
    let z1 = eyey - target[1];
    let z2 = eyez - target[2];
    let len = z0 * z0 + z1 * z1 + z2 * z2;
    if (len > 0) {
      len = 1 / Math.sqrt(len);
      z0 *= len;
      z1 *= len;
      z2 *= len;
    }
    let x0 = upy * z2 - upz * z1;
    let x1 = upz * z0 - upx * z2;
    let x2 = upx * z1 - upy * z0;
    len = x0 * x0 + x1 * x1 + x2 * x2;
    if (len > 0) {
      len = 1 / Math.sqrt(len);
      x0 *= len;
      x1 *= len;
      x2 *= len;
    }
    out[0] = x0;
    out[1] = x1;
    out[2] = x2;
    out[3] = 0;
    out[4] = z1 * x2 - z2 * x1;
    out[5] = z2 * x0 - z0 * x2;
    out[6] = z0 * x1 - z1 * x0;
    out[7] = 0;
    out[8] = z0;
    out[9] = z1;
    out[10] = z2;
    out[11] = 0;
    out[12] = eyex;
    out[13] = eyey;
    out[14] = eyez;
    out[15] = 1;
    return out;
  }
  /**
   * Returns Frobenius norm of a {@link Mat4}
   * @category Static
   *
   * @param a - the matrix to calculate Frobenius norm of
   * @returns Frobenius norm
   */
  static frob(a) {
    return Math.sqrt(
      a[0] * a[0] + a[1] * a[1] + a[2] * a[2] + a[3] * a[3] + a[4] * a[4] + a[5] * a[5] + a[6] * a[6] + a[7] * a[7] + a[8] * a[8] + a[9] * a[9] + a[10] * a[10] + a[11] * a[11] + a[12] * a[12] + a[13] * a[13] + a[14] * a[14] + a[15] * a[15]
    );
  }
  /**
   * Adds two {@link Mat4}'s
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    out[9] = a[9] + b[9];
    out[10] = a[10] + b[10];
    out[11] = a[11] + b[11];
    out[12] = a[12] + b[12];
    out[13] = a[13] + b[13];
    out[14] = a[14] + b[14];
    out[15] = a[15] + b[15];
    return out;
  }
  /**
   * Subtracts matrix b from matrix a
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    out[9] = a[9] - b[9];
    out[10] = a[10] - b[10];
    out[11] = a[11] - b[11];
    out[12] = a[12] - b[12];
    out[13] = a[13] - b[13];
    out[14] = a[14] - b[14];
    out[15] = a[15] - b[15];
    return out;
  }
  /**
   * Alias for {@link Mat4.subtract}
   * @category Static
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static sub(out, a, b) {
    return out;
  }
  /**
   * Multiply each element of the matrix by a scalar.
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to scale
   * @param b - amount to scale the matrix's elements by
   * @returns `out`
   */
  static multiplyScalar(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    out[9] = a[9] * b;
    out[10] = a[10] * b;
    out[11] = a[11] * b;
    out[12] = a[12] * b;
    out[13] = a[13] * b;
    out[14] = a[14] * b;
    out[15] = a[15] * b;
    return out;
  }
  /**
   * Adds two mat4's after multiplying each element of the second operand by a scalar value.
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param scale - the amount to scale b's elements by before adding
   * @returns `out`
   */
  static multiplyScalarAndAdd(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    out[3] = a[3] + b[3] * scale;
    out[4] = a[4] + b[4] * scale;
    out[5] = a[5] + b[5] * scale;
    out[6] = a[6] + b[6] * scale;
    out[7] = a[7] + b[7] * scale;
    out[8] = a[8] + b[8] * scale;
    out[9] = a[9] + b[9] * scale;
    out[10] = a[10] + b[10] * scale;
    out[11] = a[11] + b[11] * scale;
    out[12] = a[12] + b[12] * scale;
    out[13] = a[13] + b[13] * scale;
    out[14] = a[14] + b[14] * scale;
    out[15] = a[15] + b[15] * scale;
    return out;
  }
  /**
   * Returns whether two {@link Mat4}s have exactly the same elements in the same position (when compared with ===).
   * @category Static
   *
   * @param a - The first matrix.
   * @param b - The second matrix.
   * @returns True if the matrices are equal, false otherwise.
   */
  static exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
  }
  /**
   * Returns whether two {@link Mat4}s have approximately the same elements in the same position.
   * @category Static
   *
   * @param a - The first matrix.
   * @param b - The second matrix.
   * @returns True if the matrices are equal, false otherwise.
   */
  static equals(a, b) {
    const a0 = a[0];
    const a1 = a[1];
    const a2 = a[2];
    const a3 = a[3];
    const a4 = a[4];
    const a5 = a[5];
    const a6 = a[6];
    const a7 = a[7];
    const a8 = a[8];
    const a9 = a[9];
    const a10 = a[10];
    const a11 = a[11];
    const a12 = a[12];
    const a13 = a[13];
    const a14 = a[14];
    const a15 = a[15];
    const b0 = b[0];
    const b1 = b[1];
    const b2 = b[2];
    const b3 = b[3];
    const b4 = b[4];
    const b5 = b[5];
    const b6 = b[6];
    const b7 = b[7];
    const b8 = b[8];
    const b9 = b[9];
    const b10 = b[10];
    const b11 = b[11];
    const b12 = b[12];
    const b13 = b[13];
    const b14 = b[14];
    const b15 = b[15];
    return Math.abs(a0 - b0) <= GLM_EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= GLM_EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= GLM_EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= GLM_EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= GLM_EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= GLM_EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= GLM_EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= GLM_EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= GLM_EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= GLM_EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= GLM_EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= GLM_EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= GLM_EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= GLM_EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= GLM_EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= GLM_EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
  }
  /**
   * Returns a string representation of a {@link Mat4}
   * @category Static
   *
   * @param a - matrix to represent as a string
   * @returns string representation of the matrix
   */
  static str(a) {
    return `Mat4(${a.join(", ")})`;
  }
};
Mat4.prototype.mul = Mat4.prototype.multiply;
Mat4.sub = Mat4.subtract;
Mat4.mul = Mat4.multiply;
Mat4.frustum = Mat4.frustumNO;
Mat4.perspective = Mat4.perspectiveNO;
Mat4.ortho = Mat4.orthoNO;
var Vec3 = class _Vec3 extends Float32Array {
  static {
    __name(this, "_Vec3");
  }
  /**
   * Create a {@link Vec3}.
   *
   * @category Constructor
   */
  constructor(...values) {
    switch (values.length) {
      case 3:
        super(values);
        break;
      case 2:
        super(values[0], values[1], 3);
        break;
      case 1: {
        const v = values[0];
        if (typeof v === "number") {
          super([v, v, v]);
        } else {
          super(v, 0, 3);
        }
        break;
      }
      default:
        super(3);
        break;
    }
  }
  // ============
  // Accessors
  // ============
  // Getters and setters to make component access read better.
  // These are likely to be a little bit slower than direct array access.
  /**
   * The x component of the vector. Equivalent to `this[0];`
   * @category Vector Components
   */
  get x() {
    return this[0];
  }
  set x(value) {
    this[0] = value;
  }
  /**
   * The y component of the vector. Equivalent to `this[1];`
   * @category Vector Components
   */
  get y() {
    return this[1];
  }
  set y(value) {
    this[1] = value;
  }
  /**
   * The z component of the vector. Equivalent to `this[2];`
   * @category Vector Components
   */
  get z() {
    return this[2];
  }
  set z(value) {
    this[2] = value;
  }
  // Alternate set of getters and setters in case this is being used to define
  // a color.
  /**
   * The r component of the vector. Equivalent to `this[0];`
   * @category Color Components
   */
  get r() {
    return this[0];
  }
  set r(value) {
    this[0] = value;
  }
  /**
   * The g component of the vector. Equivalent to `this[1];`
   * @category Color Components
   */
  get g() {
    return this[1];
  }
  set g(value) {
    this[1] = value;
  }
  /**
   * The b component of the vector. Equivalent to `this[2];`
   * @category Color Components
   */
  get b() {
    return this[2];
  }
  set b(value) {
    this[2] = value;
  }
  /**
   * The magnitude (length) of this.
   * Equivalent to `Vec3.magnitude(this);`
   *
   * Magnitude is used because the `length` attribute is already defined by
   * TypedArrays to mean the number of elements in the array.
   *
   * @category Accessors
   */
  get magnitude() {
    const x = this[0];
    const y = this[1];
    const z = this[2];
    return Math.sqrt(x * x + y * y + z * z);
  }
  /**
   * Alias for {@link Vec3.magnitude}
   *
   * @category Accessors
   */
  get mag() {
    return this.magnitude;
  }
  /**
   * The squared magnitude (length) of `this`.
   * Equivalent to `Vec3.squaredMagnitude(this);`
   *
   * @category Accessors
   */
  get squaredMagnitude() {
    const x = this[0];
    const y = this[1];
    const z = this[2];
    return x * x + y * y + z * z;
  }
  /**
   * Alias for {@link Vec3.squaredMagnitude}
   *
   * @category Accessors
   */
  get sqrMag() {
    return this.squaredMagnitude;
  }
  /**
   * A string representation of `this`
   * Equivalent to `Vec3.str(this);`
   *
   * @category Accessors
   */
  get str() {
    return _Vec3.str(this);
  }
  // ===================
  // Instances methods
  // ===================
  /**
   * Copy the values from another {@link Vec3} into `this`.
   * @category Methods
   *
   * @param a the source vector
   * @returns `this`
   */
  copy(a) {
    this.set(a);
    return this;
  }
  /**
   * Adds a {@link Vec3} to `this`.
   * Equivalent to `Vec3.add(this, this, b);`
   * @category Methods
   *
   * @param b - The vector to add to `this`
   * @returns `this`
   */
  add(b) {
    this[0] += b[0];
    this[1] += b[1];
    this[2] += b[2];
    return this;
  }
  /**
   * Subtracts a {@link Vec3} from `this`.
   * Equivalent to `Vec3.subtract(this, this, b);`
   * @category Methods
   *
   * @param b - The vector to subtract from `this`
   * @returns `this`
   */
  subtract(b) {
    this[0] -= b[0];
    this[1] -= b[1];
    this[2] -= b[2];
    return this;
  }
  /**
   * Alias for {@link Vec3.subtract}
   * @category Methods
   */
  sub(b) {
    return this;
  }
  // eslint-disable-line @typescript-eslint/no-unused-vars
  /**
   * Multiplies `this` by a {@link Vec3}.
   * Equivalent to `Vec3.multiply(this, this, b);`
   * @category Methods
   *
   * @param b - The vector to multiply `this` by
   * @returns `this`
   */
  multiply(b) {
    this[0] *= b[0];
    this[1] *= b[1];
    this[2] *= b[2];
    return this;
  }
  /**
   * Alias for {@link Vec3.multiply}
   * @category Methods
   */
  mul(b) {
    return this;
  }
  // eslint-disable-line @typescript-eslint/no-unused-vars
  /**
   * Divides `this` by a {@link Vec3}.
   * Equivalent to `Vec3.divide(this, this, b);`
   * @category Methods
   *
   * @param b - The vector to divide `this` by
   * @returns `this`
   */
  divide(b) {
    this[0] /= b[0];
    this[1] /= b[1];
    this[2] /= b[2];
    return this;
  }
  /**
   * Alias for {@link Vec3.divide}
   * @category Methods
   */
  div(b) {
    return this;
  }
  // eslint-disable-line @typescript-eslint/no-unused-vars
  /**
   * Scales `this` by a scalar number.
   * Equivalent to `Vec3.scale(this, this, b);`
   * @category Methods
   *
   * @param b - Amount to scale `this` by
   * @returns `this`
   */
  scale(b) {
    this[0] *= b;
    this[1] *= b;
    this[2] *= b;
    return this;
  }
  /**
   * Calculates `this` scaled by a scalar value then adds the result to `this`.
   * Equivalent to `Vec3.scaleAndAdd(this, this, b, scale);`
   * @category Methods
   *
   * @param b - The vector to add to `this`
   * @param scale - The amount to scale `b` by before adding
   * @returns `this`
   */
  scaleAndAdd(b, scale) {
    this[0] += b[0] * scale;
    this[1] += b[1] * scale;
    this[2] += b[2] * scale;
    return this;
  }
  /**
   * Calculates the Euclidean distance between another {@link Vec3} and `this`.
   * Equivalent to `Vec3.distance(this, b);`
   * @category Methods
   *
   * @param b - The vector to calculate the distance to
   * @returns Distance between `this` and `b`
   */
  distance(b) {
    return _Vec3.distance(this, b);
  }
  /**
   * Alias for {@link Vec3.distance}
   * @category Methods
   */
  dist(b) {
    return 0;
  }
  // eslint-disable-line @typescript-eslint/no-unused-vars
  /**
   * Calculates the squared Euclidean distance between another {@link Vec3} and `this`.
   * Equivalent to `Vec3.squaredDistance(this, b);`
   * @category Methods
   *
   * @param b The vector to calculate the squared distance to
   * @returns Squared distance between `this` and `b`
   */
  squaredDistance(b) {
    return _Vec3.squaredDistance(this, b);
  }
  /**
   * Alias for {@link Vec3.squaredDistance}
   * @category Methods
   */
  sqrDist(b) {
    return 0;
  }
  // eslint-disable-line @typescript-eslint/no-unused-vars
  /**
   * Negates the components of `this`.
   * Equivalent to `Vec3.negate(this, this);`
   * @category Methods
   *
   * @returns `this`
   */
  negate() {
    this[0] *= -1;
    this[1] *= -1;
    this[2] *= -1;
    return this;
  }
  /**
   * Inverts the components of `this`.
   * Equivalent to `Vec3.inverse(this, this);`
   * @category Methods
   *
   * @returns `this`
   */
  invert() {
    this[0] = 1 / this[0];
    this[1] = 1 / this[1];
    this[2] = 1 / this[2];
    return this;
  }
  /**
   * Sets each component of `this` to its absolute value.
   * Equivalent to `Vec3.abs(this, this);`
   * @category Methods
   *
   * @returns `this`
   */
  abs() {
    this[0] = Math.abs(this[0]);
    this[1] = Math.abs(this[1]);
    this[2] = Math.abs(this[2]);
    return this;
  }
  /**
   * Calculates the dot product of this and another {@link Vec3}.
   * Equivalent to `Vec3.dot(this, b);`
   * @category Methods
   *
   * @param b - The second operand
   * @returns Dot product of `this` and `b`
   */
  dot(b) {
    return this[0] * b[0] + this[1] * b[1] + this[2] * b[2];
  }
  /**
   * Normalize `this`.
   * Equivalent to `Vec3.normalize(this, this);`
   * @category Methods
   *
   * @returns `this`
   */
  normalize() {
    return _Vec3.normalize(this, this);
  }
  // ===================
  // Static accessors
  // ===================
  /**
   * @category Static
   *
   * @returns The number of bytes in a {@link Vec3}.
   */
  static get BYTE_LENGTH() {
    return 3 * Float32Array.BYTES_PER_ELEMENT;
  }
  // ===================
  // Static methods
  // ===================
  /**
   * Creates a new, empty vec3
   * @category Static
   *
   * @returns a new 3D vector
   */
  static create() {
    return new _Vec3();
  }
  /**
   * Creates a new vec3 initialized with values from an existing vector
   * @category Static
   *
   * @param a - vector to clone
   * @returns a new 3D vector
   */
  static clone(a) {
    return new _Vec3(a);
  }
  /**
   * Calculates the magnitude (length) of a {@link Vec3}
   * @category Static
   *
   * @param a - Vector to calculate magnitude of
   * @returns Magnitude of a
   */
  static magnitude(a) {
    const x = a[0];
    const y = a[1];
    const z = a[2];
    return Math.sqrt(x * x + y * y + z * z);
  }
  /**
   * Alias for {@link Vec3.magnitude}
   * @category Static
   */
  static mag(a) {
    return 0;
  }
  // eslint-disable-line @typescript-eslint/no-unused-vars
  /**
   * Alias for {@link Vec3.magnitude}
   * @category Static
   * @deprecated Use {@link Vec3.magnitude} to avoid conflicts with builtin `length` methods/attribs
   *
   * @param a - vector to calculate length of
   * @returns length of a
   */
  // Length conflicts with Function.length
  static length(a) {
    return 0;
  }
  // eslint-disable-line @typescript-eslint/no-unused-vars
  /**
   * Alias for {@link Vec3.magnitude}
   * @category Static
   * @deprecated Use {@link Vec3.mag}
   */
  static len(a) {
    return 0;
  }
  // eslint-disable-line @typescript-eslint/no-unused-vars
  /**
   * Creates a new vec3 initialized with the given values
   * @category Static
   *
   * @param x - X component
   * @param y - Y component
   * @param z - Z component
   * @returns a new 3D vector
   */
  static fromValues(x, y, z) {
    return new _Vec3(x, y, z);
  }
  /**
   * Copy the values from one vec3 to another
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the source vector
   * @returns `out`
   */
  static copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
  }
  /**
   * Set the components of a vec3 to the given values
   * @category Static
   *
   * @param out - the receiving vector
   * @param x - X component
   * @param y - Y component
   * @param z - Z component
   * @returns `out`
   */
  static set(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
  }
  /**
   * Adds two {@link Vec3}s
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - The first operand
   * @param b - The second operand
   * @returns `out`
   */
  static add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
  }
  /**
   * Subtracts vector b from vector a
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
  }
  /**
   * Alias for {@link Vec3.subtract}
   * @category Static
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static sub(out, a, b) {
    return [0, 0, 0];
  }
  /**
   * Multiplies two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static multiply(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
  }
  /**
   * Alias for {@link Vec3.multiply}
   * @category Static
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static mul(out, a, b) {
    return [0, 0, 0];
  }
  /**
   * Divides two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static divide(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
  }
  /**
   * Alias for {@link Vec3.divide}
   * @category Static
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static div(out, a, b) {
    return [0, 0, 0];
  }
  /**
   * Math.ceil the components of a vec3
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to ceil
   * @returns `out`
   */
  static ceil(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    return out;
  }
  /**
   * Math.floor the components of a vec3
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to floor
   * @returns `out`
   */
  static floor(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    return out;
  }
  /**
   * Returns the minimum of two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static min(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
  }
  /**
   * Returns the maximum of two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static max(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
  }
  /**
   * symmetric round the components of a vec3
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to round
   * @returns `out`
   */
  /*
    static round(out: Vec3Like, a: Readonly<Vec3Like>): Vec3Like {
    out[0] = glMatrix.round(a[0]);
    out[1] = glMatrix.round(a[1]);
    out[2] = glMatrix.round(a[2]);
    return out;
  }*/
  /**
   * Scales a vec3 by a scalar number
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the vector to scale
   * @param scale - amount to scale the vector by
   * @returns `out`
   */
  static scale(out, a, scale) {
    out[0] = a[0] * scale;
    out[1] = a[1] * scale;
    out[2] = a[2] * scale;
    return out;
  }
  /**
   * Adds two vec3's after scaling the second operand by a scalar value
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param scale - the amount to scale b by before adding
   * @returns `out`
   */
  static scaleAndAdd(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    return out;
  }
  /**
   * Calculates the Euclidean distance between two vec3's
   * @category Static
   *
   * @param a - the first operand
   * @param b - the second operand
   * @returns distance between a and b
   */
  static distance(a, b) {
    const x = b[0] - a[0];
    const y = b[1] - a[1];
    const z = b[2] - a[2];
    return Math.sqrt(x * x + y * y + z * z);
  }
  /**
   * Alias for {@link Vec3.distance}
   * @category Static
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static dist(a, b) {
    return 0;
  }
  /**
   * Calculates the squared Euclidean distance between two vec3's
   * @category Static
   *
   * @param a - the first operand
   * @param b - the second operand
   * @returns squared distance between a and b
   */
  static squaredDistance(a, b) {
    const x = b[0] - a[0];
    const y = b[1] - a[1];
    const z = b[2] - a[2];
    return x * x + y * y + z * z;
  }
  /**
   * Alias for {@link Vec3.squaredDistance}
   * @category Static
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static sqrDist(a, b) {
    return 0;
  }
  /**
   * Calculates the squared length of a vec3
   * @category Static
   *
   * @param a - vector to calculate squared length of
   * @returns squared length of a
   */
  static squaredLength(a) {
    const x = a[0];
    const y = a[1];
    const z = a[2];
    return x * x + y * y + z * z;
  }
  /**
   * Alias for {@link Vec3.squaredLength}
   * @category Static
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static sqrLen(a, b) {
    return 0;
  }
  /**
   * Negates the components of a vec3
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to negate
   * @returns `out`
   */
  static negate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
  }
  /**
   * Returns the inverse of the components of a vec3
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to invert
   * @returns `out`
   */
  static inverse(out, a) {
    out[0] = 1 / a[0];
    out[1] = 1 / a[1];
    out[2] = 1 / a[2];
    return out;
  }
  /**
   * Returns the absolute value of the components of a {@link Vec3}
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - Vector to compute the absolute values of
   * @returns `out`
   */
  static abs(out, a) {
    out[0] = Math.abs(a[0]);
    out[1] = Math.abs(a[1]);
    out[2] = Math.abs(a[2]);
    return out;
  }
  /**
   * Normalize a vec3
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to normalize
   * @returns `out`
   */
  static normalize(out, a) {
    const x = a[0];
    const y = a[1];
    const z = a[2];
    let len = x * x + y * y + z * z;
    if (len > 0) {
      len = 1 / Math.sqrt(len);
    }
    out[0] = a[0] * len;
    out[1] = a[1] * len;
    out[2] = a[2] * len;
    return out;
  }
  /**
   * Calculates the dot product of two vec3's
   * @category Static
   *
   * @param a - the first operand
   * @param b - the second operand
   * @returns dot product of a and b
   */
  static dot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  /**
   * Computes the cross product of two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static cross(out, a, b) {
    const ax = a[0], ay = a[1], az = a[2];
    const bx = b[0], by = b[1], bz = b[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
  }
  /**
   * Performs a linear interpolation between two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param t - interpolation amount, in the range [0-1], between the two inputs
   * @returns `out`
   */
  static lerp(out, a, b, t) {
    const ax = a[0];
    const ay = a[1];
    const az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
  }
  /**
   * Performs a spherical linear interpolation between two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param t - interpolation amount, in the range [0-1], between the two inputs
   * @returns `out`
   */
  static slerp(out, a, b, t) {
    const angle = Math.acos(Math.min(Math.max(_Vec3.dot(a, b), -1), 1));
    const sinTotal = Math.sin(angle);
    const ratioA = Math.sin((1 - t) * angle) / sinTotal;
    const ratioB = Math.sin(t * angle) / sinTotal;
    out[0] = ratioA * a[0] + ratioB * b[0];
    out[1] = ratioA * a[1] + ratioB * b[1];
    out[2] = ratioA * a[2] + ratioB * b[2];
    return out;
  }
  /**
   * Performs a hermite interpolation with two control points
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param c - the third operand
   * @param d - the fourth operand
   * @param t - interpolation amount, in the range [0-1], between the two inputs
   * @returns `out`
   */
  static hermite(out, a, b, c, d, t) {
    const factorTimes2 = t * t;
    const factor1 = factorTimes2 * (2 * t - 3) + 1;
    const factor2 = factorTimes2 * (t - 2) + t;
    const factor3 = factorTimes2 * (t - 1);
    const factor4 = factorTimes2 * (3 - 2 * t);
    out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
    out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
    out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
    return out;
  }
  /**
   * Performs a bezier interpolation with two control points
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param c - the third operand
   * @param d - the fourth operand
   * @param t - interpolation amount, in the range [0-1], between the two inputs
   * @returns `out`
   */
  static bezier(out, a, b, c, d, t) {
    const inverseFactor = 1 - t;
    const inverseFactorTimesTwo = inverseFactor * inverseFactor;
    const factorTimes2 = t * t;
    const factor1 = inverseFactorTimesTwo * inverseFactor;
    const factor2 = 3 * t * inverseFactorTimesTwo;
    const factor3 = 3 * factorTimes2 * inverseFactor;
    const factor4 = factorTimes2 * t;
    out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
    out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
    out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
    return out;
  }
  /**
   * Generates a random vector with the given scale
   * @category Static
   *
   * @param out - the receiving vector
   * @param {Number} [scale] Length of the resulting vector. If omitted, a unit vector will be returned
   * @returns `out`
   */
  /*
      static random(out: Vec3Like, scale) {
      scale = scale === undefined ? 1.0 : scale;
  
      let r = glMatrix.RANDOM() * 2.0 * Math.PI;
      let z = glMatrix.RANDOM() * 2.0 - 1.0;
      let zScale = Math.sqrt(1.0 - z * z) * scale;
  
      out[0] = Math.cos(r) * zScale;
      out[1] = Math.sin(r) * zScale;
      out[2] = z * scale;
      return out;
    }*/
  /**
   * Transforms the vec3 with a mat4.
   * 4th vector component is implicitly '1'
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the vector to transform
   * @param m - matrix to transform with
   * @returns `out`
   */
  static transformMat4(out, a, m) {
    const x = a[0], y = a[1], z = a[2];
    const w = m[3] * x + m[7] * y + m[11] * z + m[15] || 1;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
  }
  /**
   * Transforms the vec3 with a mat3.
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the vector to transform
   * @param m - the 3x3 matrix to transform with
   * @returns `out`
   */
  static transformMat3(out, a, m) {
    const x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
  }
  /**
   * Transforms the vec3 with a quat
   * Can also be used for dual quaternions. (Multiply it with the real part)
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the vector to transform
   * @param q - quaternion to transform with
   * @returns `out`
   */
  static transformQuat(out, a, q) {
    const qx = q[0];
    const qy = q[1];
    const qz = q[2];
    const w2 = q[3] * 2;
    const x = a[0];
    const y = a[1];
    const z = a[2];
    const uvx = qy * z - qz * y;
    const uvy = qz * x - qx * z;
    const uvz = qx * y - qy * x;
    const uuvx = (qy * uvz - qz * uvy) * 2;
    const uuvy = (qz * uvx - qx * uvz) * 2;
    const uuvz = (qx * uvy - qy * uvx) * 2;
    out[0] = x + uvx * w2 + uuvx;
    out[1] = y + uvy * w2 + uuvy;
    out[2] = z + uvz * w2 + uuvz;
    return out;
  }
  /**
   * Rotate a 3D vector around the x-axis
   * @category Static
   *
   * @param out - The receiving vec3
   * @param a - The vec3 point to rotate
   * @param b - The origin of the rotation
   * @param rad - The angle of rotation in radians
   * @returns `out`
   */
  static rotateX(out, a, b, rad) {
    const by = b[1];
    const bz = b[2];
    const py = a[1] - by;
    const pz = a[2] - bz;
    out[0] = a[0];
    out[1] = py * Math.cos(rad) - pz * Math.sin(rad) + by;
    out[2] = py * Math.sin(rad) + pz * Math.cos(rad) + bz;
    return out;
  }
  /**
   * Rotate a 3D vector around the y-axis
   * @category Static
   *
   * @param out - The receiving vec3
   * @param a - The vec3 point to rotate
   * @param b - The origin of the rotation
   * @param rad - The angle of rotation in radians
   * @returns `out`
   */
  static rotateY(out, a, b, rad) {
    const bx = b[0];
    const bz = b[2];
    const px = a[0] - bx;
    const pz = a[2] - bz;
    out[0] = pz * Math.sin(rad) + px * Math.cos(rad) + bx;
    out[1] = a[1];
    out[2] = pz * Math.cos(rad) - px * Math.sin(rad) + bz;
    return out;
  }
  /**
   * Rotate a 3D vector around the z-axis
   * @category Static
   *
   * @param out - The receiving vec3
   * @param a - The vec3 point to rotate
   * @param b - The origin of the rotation
   * @param rad - The angle of rotation in radians
   * @returns `out`
   */
  static rotateZ(out, a, b, rad) {
    const bx = b[0];
    const by = b[1];
    const px = a[0] - bx;
    const py = a[1] - by;
    out[0] = px * Math.cos(rad) - py * Math.sin(rad) + bx;
    out[1] = px * Math.sin(rad) + py * Math.cos(rad) + by;
    out[2] = b[2];
    return out;
  }
  /**
   * Get the angle between two 3D vectors
   * @category Static
   *
   * @param a - The first operand
   * @param b - The second operand
   * @returns The angle in radians
   */
  static angle(a, b) {
    const ax = a[0];
    const ay = a[1];
    const az = a[2];
    const bx = b[0];
    const by = b[1];
    const bz = b[2];
    const mag = Math.sqrt((ax * ax + ay * ay + az * az) * (bx * bx + by * by + bz * bz));
    const cosine = mag && _Vec3.dot(a, b) / mag;
    return Math.acos(Math.min(Math.max(cosine, -1), 1));
  }
  /**
   * Set the components of a vec3 to zero
   * @category Static
   *
   * @param out - the receiving vector
   * @returns `out`
   */
  static zero(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
  }
  /**
   * Returns a string representation of a vector
   * @category Static
   *
   * @param a - vector to represent as a string
   * @returns string representation of the vector
   */
  static str(a) {
    return `Vec3(${a.join(", ")})`;
  }
  /**
   * Returns whether the vectors have exactly the same elements in the same position (when compared with ===)
   * @category Static
   *
   * @param a - The first vector.
   * @param b - The second vector.
   * @returns True if the vectors are equal, false otherwise.
   */
  static exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
  }
  /**
   * Returns whether the vectors have approximately the same elements in the same position.
   * @category Static
   *
   * @param a - The first vector.
   * @param b - The second vector.
   * @returns True if the vectors are equal, false otherwise.
   */
  static equals(a, b) {
    const a0 = a[0];
    const a1 = a[1];
    const a2 = a[2];
    const b0 = b[0];
    const b1 = b[1];
    const b2 = b[2];
    return Math.abs(a0 - b0) <= GLM_EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= GLM_EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= GLM_EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2));
  }
};
Vec3.prototype.sub = Vec3.prototype.subtract;
Vec3.prototype.mul = Vec3.prototype.multiply;
Vec3.prototype.div = Vec3.prototype.divide;
Vec3.prototype.dist = Vec3.prototype.distance;
Vec3.prototype.sqrDist = Vec3.prototype.squaredDistance;
Vec3.sub = Vec3.subtract;
Vec3.mul = Vec3.multiply;
Vec3.div = Vec3.divide;
Vec3.dist = Vec3.distance;
Vec3.sqrDist = Vec3.squaredDistance;
Vec3.sqrLen = Vec3.squaredLength;
Vec3.mag = Vec3.magnitude;
Vec3.length = Vec3.magnitude;
Vec3.len = Vec3.magnitude;
async function nextAnimationFrame(cntr = 1) {
  if (!Number.isInteger(cntr) || cntr < 1) {
    throw new TypeError(`nextAnimationFrame error: 'cntr' must be a positive integer greater than 0.`);
  }
  let currentTime;
  for (; --cntr >= 0; ) {
    currentTime = await new Promise((resolve) => requestAnimationFrame(resolve));
  }
  return currentTime;
}
__name(nextAnimationFrame, "nextAnimationFrame");
function draggable(node, {
  position,
  enabled = true,
  button = 0,
  storeDragging = void 0,
  tween = false,
  tweenOptions = { duration: 1, ease: "cubicOut" },
  hasTargetClassList,
  ignoreTargetClassList
}) {
  if (hasTargetClassList !== void 0 && !isIterable(hasTargetClassList)) {
    throw new TypeError(`'hasTargetClassList' is not iterable.`);
  }
  if (ignoreTargetClassList !== void 0 && !isIterable(ignoreTargetClassList)) {
    throw new TypeError(`'ignoreTargetClassList' is not iterable.`);
  }
  const positionData = { left: 0, top: 0 };
  let actualPosition = position?.position ?? position;
  let initialPosition = null;
  let initialDragPoint = {};
  let dragging = false;
  let quickTo = actualPosition.animate.quickTo(["top", "left"], tweenOptions);
  const handlers = {
    dragDown: [
      "pointerdown",
      /** @type {EventListener} */
      onDragPointerDown,
      false
    ],
    dragMove: [
      "pointermove",
      /** @type {EventListener} */
      onDragPointerChange,
      false
    ],
    dragUp: [
      "pointerup",
      /** @type {EventListener} */
      onDragPointerUp,
      false
    ]
  };
  function activateListeners() {
    node.addEventListener(...handlers.dragDown);
    node.classList.add("draggable");
  }
  __name(activateListeners, "activateListeners");
  function removeListeners() {
    if (typeof storeDragging?.set === "function") {
      storeDragging.set(false);
    }
    node.removeEventListener(...handlers.dragDown);
    node.removeEventListener(...handlers.dragMove);
    node.removeEventListener(...handlers.dragUp);
    node.classList.remove("draggable");
  }
  __name(removeListeners, "removeListeners");
  if (enabled) {
    activateListeners();
  }
  function onDragPointerDown(event) {
    if (event.button !== button || !event.isPrimary) {
      return;
    }
    if (!actualPosition.enabled) {
      return;
    }
    if (ignoreTargetClassList !== void 0 && A11yHelper.isFocusTarget(event.target)) {
      for (const targetClass of ignoreTargetClassList) {
        if (event.target.classList.contains(targetClass)) {
          return;
        }
      }
    }
    if (hasTargetClassList !== void 0 && A11yHelper.isFocusTarget(event.target)) {
      let foundTarget = false;
      for (const targetClass of hasTargetClassList) {
        if (event.target.classList.contains(targetClass)) {
          foundTarget = true;
          break;
        }
      }
      if (!foundTarget) {
        return;
      }
    }
    event.preventDefault();
    dragging = false;
    initialPosition = actualPosition.get();
    initialDragPoint = { x: event.clientX, y: event.clientY };
    node.addEventListener(...handlers.dragMove);
    node.addEventListener(...handlers.dragUp);
    node.setPointerCapture(event.pointerId);
  }
  __name(onDragPointerDown, "onDragPointerDown");
  function onDragPointerChange(event) {
    if ((event.buttons & 1) === 0) {
      onDragPointerUp(event);
      return;
    }
    if (event.button !== -1 || !event.isPrimary) {
      return;
    }
    event.preventDefault();
    if (!dragging && typeof storeDragging?.set === "function") {
      dragging = true;
      storeDragging.set(true);
    }
    const newLeft = initialPosition.left + (event.clientX - initialDragPoint.x);
    const newTop = initialPosition.top + (event.clientY - initialDragPoint.y);
    if (tween) {
      quickTo(newTop, newLeft);
    } else {
      positionData.left = newLeft;
      positionData.top = newTop;
      actualPosition.set(positionData);
    }
  }
  __name(onDragPointerChange, "onDragPointerChange");
  function onDragPointerUp(event) {
    event.preventDefault();
    dragging = false;
    if (typeof storeDragging?.set === "function") {
      storeDragging.set(false);
    }
    node.removeEventListener(...handlers.dragMove);
    node.removeEventListener(...handlers.dragUp);
  }
  __name(onDragPointerUp, "onDragPointerUp");
  return {
    // The default of enabled being true won't automatically add listeners twice.
    update: (options) => {
      if (options.position !== void 0) {
        const newPosition = options.position?.position ?? options.position;
        if (newPosition !== actualPosition) {
          actualPosition = newPosition;
          quickTo = actualPosition.animate.quickTo(["top", "left"], tweenOptions);
        }
      }
      if (typeof options.enabled === "boolean") {
        enabled = options.enabled;
        if (enabled) {
          activateListeners();
        } else {
          removeListeners();
        }
      }
      if (typeof options.button === "number") {
        button = options.button;
      }
      if (typeof options.tween === "boolean") {
        tween = options.tween;
      }
      if (isObject(options.tweenOptions)) {
        tweenOptions = options.tweenOptions;
        quickTo.options(tweenOptions);
      }
      if (options.hasTargetClassList !== void 0) {
        if (!isIterable(options.hasTargetClassList)) {
          throw new TypeError(`'hasTargetClassList' is not iterable.`);
        } else {
          hasTargetClassList = options.hasTargetClassList;
        }
      }
      if (options.ignoreTargetClassList !== void 0) {
        if (!isIterable(options.ignoreTargetClassList)) {
          throw new TypeError(`'ignoreTargetClassList' is not iterable.`);
        } else {
          ignoreTargetClassList = options.ignoreTargetClassList;
        }
      }
    },
    destroy: () => removeListeners()
  };
}
__name(draggable, "draggable");
class DraggableOptionsStore {
  static {
    __name(this, "DraggableOptionsStore");
  }
  /** @type {boolean} */
  #initialTween;
  /**
   * @type {import('../animation/types').AnimationAPI.QuickTweenOptions}
   */
  #initialTweenOptions;
  /** @type {boolean} */
  #tween;
  /**
   * @type {import('../animation/types').AnimationAPI.QuickTweenOptions}
   */
  #tweenOptions = { duration: 1, ease: "cubicOut" };
  /**
   * Stores the subscribers.
   *
   * @type {import('svelte/store').Subscriber<import('./types').Action.DraggableOptionsStore>[]}
   */
  #subscriptions = [];
  /**
   * @param {object} [opts] - Optional parameters.
   *
   * @param {boolean}  [opts.tween = false] - Tween enabled.
   *
   * @param {import('../animation/types').AnimationAPI.QuickTweenOptions}   [opts.tweenOptions] - Quick tween options.
   */
  constructor({ tween = false, tweenOptions } = {}) {
    Object.defineProperty(this, "tween", {
      get: () => {
        return this.#tween;
      },
      set: (newTween) => {
        if (typeof newTween !== "boolean") {
          throw new TypeError(`'tween' is not a boolean.`);
        }
        this.#tween = newTween;
        this.#updateSubscribers();
      },
      enumerable: true
    });
    Object.defineProperty(this, "tweenOptions", {
      get: () => {
        return this.#tweenOptions;
      },
      set: (newTweenOptions) => {
        if (!isObject(newTweenOptions)) {
          throw new TypeError(`'tweenOptions' is not an object.`);
        }
        if (newTweenOptions.duration !== void 0) {
          if (!Number.isFinite(newTweenOptions.duration)) {
            throw new TypeError(`'tweenOptions.duration' is not a finite number.`);
          }
          if (newTweenOptions.duration < 0) {
            this.#tweenOptions.duration = 0;
          } else {
            this.#tweenOptions.duration = newTweenOptions.duration;
          }
        }
        if (newTweenOptions.ease !== void 0) {
          const easeFn = getEasingFunc(newTweenOptions.ease);
          if (typeof easeFn !== "function") {
            throw new TypeError(`'tweenOptions.ease' is not a function or Svelte easing function name.`);
          }
          this.#tweenOptions.ease = newTweenOptions.ease;
        }
        this.#updateSubscribers();
      },
      enumerable: true
    });
    if (tween !== void 0) {
      this.tween = tween;
    }
    if (tweenOptions !== void 0) {
      this.tweenOptions = tweenOptions;
    }
    this.#initialTween = this.#tween;
    this.#initialTweenOptions = Object.assign({}, this.#tweenOptions);
  }
  /**
   * @returns {number} Get tween duration.
   */
  get tweenDuration() {
    return this.#tweenOptions.duration;
  }
  /**
   * @returns {import('#runtime/svelte/easing').EasingReference} Get easing function or easing function name.
   */
  get tweenEase() {
    return this.#tweenOptions.ease;
  }
  /**
   * @param {number}   duration - Set tween duration.
   */
  set tweenDuration(duration) {
    if (!Number.isFinite(duration)) {
      throw new TypeError(`'duration' is not a finite number.`);
    }
    if (duration < 0) {
      duration = 0;
    }
    this.#tweenOptions.duration = duration;
    this.#updateSubscribers();
  }
  /**
   * @param {import('#runtime/svelte/easing').EasingReference} ease - Set easing function by name or direct function.
   */
  set tweenEase(ease) {
    const easeFn = getEasingFunc(ease);
    if (typeof easeFn !== "function") {
      throw new TypeError(`'ease' is not a function or Svelte easing function name.`);
    }
    this.#tweenOptions.ease = ease;
    this.#updateSubscribers();
  }
  /**
   * Resets all options data to initial values.
   */
  reset() {
    this.#tween = this.#initialTween;
    this.#tweenOptions = Object.assign({}, this.#initialTweenOptions);
    this.#updateSubscribers();
  }
  /**
   * Resets tween enabled state to initial value.
   */
  resetTween() {
    this.#tween = this.#initialTween;
    this.#updateSubscribers();
  }
  /**
   * Resets tween options to initial values.
   */
  resetTweenOptions() {
    this.#tweenOptions = Object.assign({}, this.#initialTweenOptions);
    this.#updateSubscribers();
  }
  /**
   * Store subscribe method.
   *
   * @param {import('svelte/store').Subscriber<import('./types').Action.DraggableOptionsStore>} handler - Callback
   *        function that is invoked on update / changes. Receives the DraggableOptionsStore instance.
   *
   * @returns {import('svelte/store').Unsubscriber} Unsubscribe function.
   */
  subscribe(handler) {
    this.#subscriptions.push(handler);
    handler(this);
    return () => {
      const index = this.#subscriptions.findIndex((sub) => sub === handler);
      if (index >= 0) {
        this.#subscriptions.splice(index, 1);
      }
    };
  }
  #updateSubscribers() {
    const subscriptions = this.#subscriptions;
    if (subscriptions.length > 0) {
      for (let cntr = 0; cntr < subscriptions.length; cntr++) {
        subscriptions[cntr](this);
      }
    }
  }
}
draggable.options = (options) => new DraggableOptionsStore(options);
class AnimationControl {
  static {
    __name(this, "AnimationControl");
  }
  /** @type {import('./types-local').AnimationData} */
  #animationData;
  /** @type {Promise<import('#runtime/util/animate').BasicAnimationState>} */
  #finishedPromise;
  /** @type {boolean} */
  #willFinish;
  /**
   * Defines a static empty / void animation control.
   *
   * @type {AnimationControl}
   */
  static #voidControl = new AnimationControl(null);
  /**
   * Provides a static void / undefined AnimationControl that is automatically resolved.
   *
   * @returns {AnimationControl} Void AnimationControl
   */
  static get voidControl() {
    return this.#voidControl;
  }
  /**
   * @param {import('./types-local').AnimationData | null}  [animationData] - Animation data from {@link AnimationAPI}.
   *
   * @param {boolean}        [willFinish] - Promise that tracks animation finished state.
   */
  constructor(animationData, willFinish = false) {
    this.#animationData = animationData;
    this.#willFinish = willFinish;
    if (isObject(animationData)) {
      animationData.control = this;
    }
  }
  /**
   * Get a promise that resolves when animation is finished.
   *
   * @returns {Promise<import('#runtime/util/animate').BasicAnimationState>} Animation finished Promise.
   */
  get finished() {
    if (!CrossWindow.isPromise(this.#finishedPromise)) {
      this.#finishedPromise = this.#willFinish ? new Promise((resolve) => this.#animationData.resolve = resolve) : Promise.resolve({ cancelled: false });
    }
    return this.#finishedPromise;
  }
  /**
   * Returns whether this animation is currently active / animating.
   *
   * Note: a delayed animation may not be started / active yet. Use {@link AnimationControl.isFinished} to determine
   * if an animation is actually finished.
   *
   * @returns {boolean} Animation active state.
   */
  get isActive() {
    return this.#animationData.active;
  }
  /**
   * Returns whether this animation is completely finished.
   *
   * @returns {boolean} Animation finished state.
   */
  get isFinished() {
    return this.#animationData.finished;
  }
  /**
   * Cancels the animation.
   */
  cancel() {
    const animationData = this.#animationData;
    if (animationData === null || animationData === void 0) {
      return;
    }
    animationData.cancelled = true;
  }
}
class AnimationManager {
  static {
    __name(this, "AnimationManager");
  }
  /**
   * Cancels all animations except `quickTo` animations.
   *
   * @type {import('./types-local').AnimationCancelFunction}
   */
  static cancelFn = (data) => data.quickTo !== true;
  /**
   * Cancels all animations.
   *
   * @type {import('./types-local').AnimationCancelFunction}
   */
  static cancelAllFn = () => true;
  /**
   * Defines the options used for {@link TJSPosition.set}.
   *
   * @type {Readonly<{immediateElementUpdate: boolean}>}
   */
  static #tjsPositionSetOptions = Object.freeze({ immediateElementUpdate: true });
  /**
   * @type {import('./types-local').AnimationData[]}
   */
  static #activeList = [];
  /**
   * Provides the `this` context for {@link AnimationManager.animate} to be scheduled on rAF.
   *
   * @type {Function}
   */
  static #animateBound = (timeFrame) => this.animate(timeFrame);
  /**
   * @type {import('./types-local').AnimationData[]}
   */
  static #pendingList = [];
  /**
   * Tracks whether a requestAnimationFrame callback is pending via {@link AnimationManager.add};
   *
   * @type {boolean}
   */
  static #rafPending = false;
  /**
   * Time of last `rAF` callback.
   *
   * @type {number}
   */
  static #timeFrame;
  /**
   * Time of `performance.now()` at last `rAF` callback.
   *
   * @type {number}
   */
  static #timeNow;
  /**
   * @returns {number} Time of last `rAF` callback.
   */
  static get timeFrame() {
    return this.#timeFrame;
  }
  /**
   * @returns {number} Time of `performance.now()` at last `rAF` callback.
   */
  static get timeNow() {
    return this.#timeNow;
  }
  /**
   * Add animation data.
   *
   * @param {import('./types-local').AnimationData}   data -
   */
  static add(data) {
    if (data.cancelled) {
      this.#cleanupData(data);
      return;
    }
    AnimationManager.#pendingList.push(data);
    if (!AnimationManager.#rafPending) {
      AnimationManager.#rafPending = true;
      globalThis.requestAnimationFrame(this.#animateBound);
    }
  }
  /**
   * Manage all animation.
   *
   * @param {DOMHighResTimeStamp} timeFrame - rAF callback time.
   */
  static animate(timeFrame) {
    AnimationManager.#rafPending = false;
    AnimationManager.#timeNow = globalThis.performance.now();
    AnimationManager.#timeFrame = timeFrame;
    if (AnimationManager.#activeList.length === 0 && AnimationManager.#pendingList.length === 0) {
      return;
    }
    if (AnimationManager.#pendingList.length) {
      for (let cntr = AnimationManager.#pendingList.length; --cntr >= 0; ) {
        const data = AnimationManager.#pendingList[cntr];
        if (data.cancelled || data.el !== void 0 && !data.el.isConnected) {
          AnimationManager.#pendingList.splice(cntr, 1);
          this.#cleanupData(data);
        }
        if (data.active) {
          if (data.transformOrigin) {
            data.position.set({ transformOrigin: data.transformOrigin });
          }
          data.start = AnimationManager.#timeFrame;
          AnimationManager.#pendingList.splice(cntr, 1);
          AnimationManager.#activeList.push(data);
        }
      }
    }
    for (let cntr = AnimationManager.#activeList.length; --cntr >= 0; ) {
      const data = AnimationManager.#activeList[cntr];
      if (data.cancelled || data.el !== void 0 && !data.el.isConnected) {
        AnimationManager.#activeList.splice(cntr, 1);
        this.#cleanupData(data);
        continue;
      }
      data.current = timeFrame - data.start;
      if (data.current >= data.duration) {
        for (let dataCntr = data.keys.length; --dataCntr >= 0; ) {
          const key = data.keys[dataCntr];
          data.newData[key] = data.destination[key];
        }
        data.position.set(data.newData, AnimationManager.#tjsPositionSetOptions);
        AnimationManager.#activeList.splice(cntr, 1);
        this.#cleanupData(data);
        continue;
      }
      const easedTime = data.ease(data.current / data.duration);
      for (let dataCntr = data.keys.length; --dataCntr >= 0; ) {
        const key = data.keys[dataCntr];
        data.newData[key] = data.interpolate(data.initial[key], data.destination[key], easedTime);
      }
      data.position.set(data.newData, AnimationManager.#tjsPositionSetOptions);
    }
    globalThis.requestAnimationFrame(this.#animateBound);
  }
  /**
   * Cancels all animations for given TJSPosition instance.
   *
   * @param {import('../').TJSPosition} position - TJSPosition instance.
   *
   * @param {import('./types-local').AnimationCancelFunction} [cancelFn] - An optional function to control cancelling
   *        animations.
   */
  static cancel(position, cancelFn = AnimationManager.cancelFn) {
    for (let cntr = AnimationManager.#activeList.length; --cntr >= 0; ) {
      const data = AnimationManager.#activeList[cntr];
      if (data.position === position && cancelFn(data)) {
        AnimationManager.#activeList.splice(cntr, 1);
        data.cancelled = true;
        this.#cleanupData(data);
      }
    }
    for (let cntr = AnimationManager.#pendingList.length; --cntr >= 0; ) {
      const data = AnimationManager.#pendingList[cntr];
      if (data.position === position && cancelFn(data)) {
        AnimationManager.#pendingList.splice(cntr, 1);
        data.cancelled = true;
        this.#cleanupData(data);
      }
    }
  }
  /**
   * Cancels all active and delayed animations.
   */
  static cancelAll() {
    for (let cntr = AnimationManager.#activeList.length; --cntr >= 0; ) {
      const data = AnimationManager.#activeList[cntr];
      data.cancelled = true;
      this.#cleanupData(data);
    }
    for (let cntr = AnimationManager.#pendingList.length; --cntr >= 0; ) {
      const data = AnimationManager.#pendingList[cntr];
      data.cancelled = true;
      this.#cleanupData(data);
    }
    AnimationManager.#activeList.length = 0;
    AnimationManager.#pendingList.length = 0;
  }
  /**
   * @param {import('./types-local').AnimationData}  data - Animation data to cleanup.
   */
  static #cleanupData(data) {
    data.active = false;
    data.finished = true;
    if (data.transformOriginInitial) {
      data.position.set({ transformOrigin: data.transformOriginInitial });
    }
    if (typeof data.cleanup === "function") {
      data.cleanup(data);
    }
    if (typeof data.resolve === "function") {
      data.resolve({ cancelled: data.cancelled });
    }
    if (!data.quickTo) {
      data.cleanup = void 0;
      data.control = void 0;
      data.destination = void 0;
      data.el = void 0;
      data.ease = void 0;
      data.initial = void 0;
      data.interpolate = void 0;
      data.keys = void 0;
      data.newData = void 0;
      data.position = void 0;
      data.resolve = void 0;
    }
  }
  /**
   * Gets all {@link AnimationControl} instances for a given TJSPosition instance.
   *
   * @param {import('../index.js').TJSPosition} position - TJSPosition instance.
   *
   * @returns {import('#runtime/util/animate').BasicAnimation[]} All scheduled AnimationControl instances for the
   *          given TJSPosition instance.
   */
  static getScheduled(position) {
    const results = [];
    for (let cntr = AnimationManager.#activeList.length; --cntr >= 0; ) {
      const data = AnimationManager.#activeList[cntr];
      if (data.position === position) {
        results.push(data.control);
      }
    }
    for (let cntr = AnimationManager.#pendingList.length; --cntr >= 0; ) {
      const data = AnimationManager.#pendingList[cntr];
      if (data.position === position) {
        results.push(data.control);
      }
    }
    return results;
  }
  /**
   * Returns the status of any scheduled or pending animations for the given {@link TJSPosition} instance.
   *
   * @param {import('../index.js').TJSPosition} position - TJSPosition instance.
   *
   * @param {import('./types').AnimationAPI.ScheduleOptions} [options] - Scheduling options.
   *
   * @returns {boolean} True if scheduled / false if not.
   */
  static isScheduled(position, { active: active2 = true, pending = true } = {}) {
    if (active2) {
      for (let cntr = AnimationManager.#activeList.length; --cntr >= 0; ) {
        if (AnimationManager.#activeList[cntr].position === position) {
          return true;
        }
      }
    }
    if (pending) {
      for (let cntr = AnimationManager.#pendingList.length; --cntr >= 0; ) {
        if (AnimationManager.#pendingList[cntr].position === position) {
          return true;
        }
      }
    }
    return false;
  }
}
class TJSPositionData {
  static {
    __name(this, "TJSPositionData");
  }
  /**
   * @param {object} [opts] - Options.
   *
   * @param {number | 'auto' | 'inherit' | null} [opts.height] -
   *
   * @param {number | null} [opts.left] -
   *
   * @param {number | null} [opts.maxHeight] -
   *
   * @param {number | null} [opts.maxWidth] -
   *
   * @param {number | null} [opts.minHeight] -
   *
   * @param {number | null} [opts.minWidth] -
   *
   * @param {number | null} [opts.rotateX] -
   *
   * @param {number | null} [opts.rotateY] -
   *
   * @param {number | null} [opts.rotateZ] -
   *
   * @param {number | null} [opts.scale] -
   *
   * @param {number | null} [opts.translateX] -
   *
   * @param {number | null} [opts.translateY] -
   *
   * @param {number | null} [opts.translateZ] -
   *
   * @param {number | null} [opts.top] -
   *
   * @param {import('../transform/types').TransformAPI.TransformOrigin | null} [opts.transformOrigin] -
   *
   * @param {number | 'auto' | 'inherit' | null} [opts.width] -
   *
   * @param {number | null} [opts.zIndex] -
   *
   * @param {number | null} [opts.rotation] - Alias for `rotateZ`.
   */
  constructor({
    height = void 0,
    left = void 0,
    maxHeight = void 0,
    maxWidth = void 0,
    minHeight = void 0,
    minWidth = void 0,
    rotateX = void 0,
    rotateY = void 0,
    rotateZ = void 0,
    scale = void 0,
    translateX = void 0,
    translateY = void 0,
    translateZ = void 0,
    top = void 0,
    transformOrigin = void 0,
    width = void 0,
    zIndex = void 0,
    rotation = void 0
  } = {}) {
    this.height = height;
    this.left = left;
    this.maxHeight = maxHeight;
    this.maxWidth = maxWidth;
    this.minHeight = minHeight;
    this.minWidth = minWidth;
    this.rotateX = rotateX;
    this.rotateY = rotateY;
    this.rotateZ = rotateZ;
    this.scale = scale;
    this.top = top;
    this.transformOrigin = transformOrigin;
    this.translateX = translateX;
    this.translateY = translateY;
    this.translateZ = translateZ;
    this.width = width;
    this.zIndex = zIndex;
    this.rotation = rotation;
  }
}
class TJSPositionDataUtil {
  static {
    __name(this, "TJSPositionDataUtil");
  }
  /**
   * Stores the TJSPositionData properties that can be animated.
   *
   * @type {ReadonlySet<string>}
   */
  static #animateKeys = Object.freeze(/* @__PURE__ */ new Set([
    // Main keys
    "left",
    "top",
    "maxWidth",
    "maxHeight",
    "minWidth",
    "minHeight",
    "width",
    "height",
    "rotateX",
    "rotateY",
    "rotateZ",
    "scale",
    "translateX",
    "translateY",
    "translateZ",
    "zIndex",
    // Aliases
    "rotation"
  ]));
  /**
   * Stores the TJSPositionData property aliases that can be animated.
   *
   * @type {Readonly<Map<string, string>>}
   */
  static #animateKeyAliases = Object.freeze(/* @__PURE__ */ new Map([["rotation", "rotateZ"]]));
  /**
   * Provides numeric defaults for all parameters. This is used by {@link TJSPosition.get} to optionally
   * provide numeric defaults.
   *
   * @type {{ [key: string]: number | null }}
   */
  static #numericDefaults = Object.freeze({
    // Other keys
    height: 0,
    left: 0,
    maxHeight: null,
    maxWidth: null,
    minHeight: null,
    minWidth: null,
    top: 0,
    transformOrigin: null,
    width: 0,
    zIndex: null,
    rotateX: 0,
    rotateY: 0,
    rotateZ: 0,
    scale: 1,
    translateX: 0,
    translateY: 0,
    translateZ: 0,
    rotation: 0
  });
  /**
   * Convenience to copy from source to target of two TJSPositionData like objects. If a target is not supplied a new
   * {@link TJSPositionData} instance is created.
   *
   * @param {Partial<import('./types').Data.TJSPositionData>}  source - The source instance to copy from.
   *
   * @param {import('./types').Data.TJSPositionData}  [target] - Target TJSPositionData like object; if one
   *        is not provided a new instance is created.
   *
   * @returns {import('./types').Data.TJSPositionData} The target instance with all TJSPositionData fields.
   */
  static copyData(source, target = new TJSPositionData()) {
    target.height = source.height ?? null;
    target.left = source.left ?? null;
    target.maxHeight = source.maxHeight ?? null;
    target.maxWidth = source.maxWidth ?? null;
    target.minHeight = source.minHeight ?? null;
    target.minWidth = source.minWidth ?? null;
    target.rotateX = source.rotateX ?? null;
    target.rotateY = source.rotateY ?? null;
    target.rotateZ = source.rotateZ ?? null;
    target.scale = source.scale ?? null;
    target.top = source.top ?? null;
    target.transformOrigin = source.transformOrigin ?? null;
    target.translateX = source.translateX ?? null;
    target.translateY = source.translateY ?? null;
    target.translateZ = source.translateZ ?? null;
    target.width = source.width ?? null;
    target.zIndex = source.zIndex ?? null;
    return target;
  }
  /**
   * Returns the non-aliased animation key.
   *
   * @param {import('../animation/types').AnimationAPI.AnimationKey} key - Animation key / possibly aliased key.
   *
   * @returns {import('../animation/types').AnimationAPI.AnimationKey} Actual non-aliased animation key.
   */
  static getAnimationKey(key) {
    return this.#animateKeyAliases.get(key) ?? key;
  }
  /**
   * Queries an object by the given key or otherwise returns any numeric default.
   *
   * @param {object}   data - An object to query for the given animation key.
   *
   * @param {import('../animation/types').AnimationAPI.AnimationKey}   key - Animation key.
   *
   * @param {boolean}  [aliased=false] - When use non-aliased key.
   *
   * @returns {*|number|null} Data at key or numeric default.
   */
  static getDataOrDefault(data, key, aliased = false) {
    if (aliased) {
      key = this.#animateKeyAliases.get(key) ?? key;
    }
    return data[key] ?? this.#numericDefaults[key];
  }
  /**
   * Tests if the given key is an animation key.
   *
   * @param {unknown}   key - A potential animation key.
   *
   * @returns {key is import('../animation/types').AnimationAPI.AnimationKey} Is animation key.
   */
  static isAnimationKey(key) {
    return this.#animateKeys.has(key);
  }
  /**
   * Sets numeric defaults for a {@link TJSPositionData} like object.
   *
   * @param {object}   data - A TJSPositionData like object.
   */
  static setNumericDefaults(data) {
    if (data.rotateX === null) {
      data.rotateX = 0;
    }
    if (data.rotateY === null) {
      data.rotateY = 0;
    }
    if (data.rotateZ === null) {
      data.rotateZ = 0;
    }
    if (data.translateX === null) {
      data.translateX = 0;
    }
    if (data.translateY === null) {
      data.translateY = 0;
    }
    if (data.translateZ === null) {
      data.translateZ = 0;
    }
    if (data.scale === null) {
      data.scale = 1;
    }
    if (data.rotation === null) {
      data.rotation = 0;
    }
  }
}
class ConvertStringData {
  static {
    __name(this, "ConvertStringData");
  }
  /**
   * Animation keys for different processing categories.
   *
   * @type {{numPx: Readonly<Set<string>>, percentParent: Readonly<Set<string>>}}
   */
  static #animKeyTypes = {
    // Animation keys that can be specified in `px` converted to a number.
    numPx: Object.freeze(/* @__PURE__ */ new Set([
      "left",
      "top",
      "maxWidth",
      "maxHeight",
      "minWidth",
      "minHeight",
      "width",
      "height",
      "translateX",
      "translateY",
      "translateZ"
    ])),
    // Animation keys that can be specified in percentage of parent element constraint.
    percentParent: Object.freeze(/* @__PURE__ */ new Set([
      "left",
      "top",
      "maxWidth",
      "maxHeight",
      "minWidth",
      "minHeight",
      "width",
      "height"
    ])),
    // Only rotation animation keys can be specified in `rad` / `turn` converted to a number.
    rotationRadTurn: Object.freeze(/* @__PURE__ */ new Set(["rotateX", "rotateY", "rotateZ", "rotation"]))
  };
  /**
   * Parses string data values. Relative values must start with leading values '+=', '-=', or '*=' followed by a
   * float / numeric value. IE `+=45` or for percentage '+=10%'. Also handles exact percent value such as `10` or
   * `10%`. Percentage values are based on the current value, parent element constraints, or constraints of the type
   * of value like rotation being bound by 360 degrees.
   *
   * TODO: In the future support more specific CSS unit types.
   *
   * @type {RegExp}
   */
  static #regexStringData = /^(?<operation>[-+*]=)?(?<value>-?\d*\.?\d+)(?<unit>%|%~|px|rad|turn)?$/;
  /**
   * Stores the results for match groups from `regexStringData`;
   *
   * @type {import('./types-local').StringMatch}
   */
  static #matchResults = Object.seal({
    operation: void 0,
    value: void 0,
    unit: void 0
  });
  /**
   * Converts any relative string values for animatable keys to actual updates performed against current data.
   *
   * @param {import('../data/types').Data.TJSPositionDataRelative}  data - position data.
   *
   * @param {import('../data/types').Data.TJSPositionData}   position - The source position data.
   *
   * @param {HTMLElement} el - Target positioned element.
   *
   * @returns {import('../data/types').Data.TJSPositionDataRelative} Converted data.
   */
  static process(data, position, el) {
    let parentClientHeight = void 0, parentClientWidth = void 0;
    for (const key in data) {
      if (TJSPositionDataUtil.isAnimationKey(key)) {
        const value = data[key];
        if (typeof value !== "string") {
          continue;
        }
        if (value === "auto" || value === "inherit") {
          continue;
        }
        const animKey = key;
        const regexResults = this.#regexStringData.exec(value);
        let handled = false;
        if (regexResults) {
          const results = this.#matchResults;
          results.operation = regexResults.groups.operation;
          results.value = parseFloat(regexResults.groups.value);
          results.unit = regexResults.groups.unit;
          const current = TJSPositionDataUtil.getDataOrDefault(position, key, true);
          switch (results.unit) {
            case "%": {
              if (this.#animKeyTypes.percentParent.has(key)) {
                if (!Number.isFinite(parentClientHeight) && el?.parentElement?.isConnected) {
                  parentClientHeight = el.parentElement.clientHeight;
                  parentClientWidth = el.parentElement.clientWidth;
                }
                if (parentClientHeight === void 0 || parentClientWidth === void 0) {
                  console.warn(
                    `TJSPosition - ConvertStringData warning: could not determine parent constraints for key '${key}' with value '${value}'.`
                  );
                  data[key] = void 0;
                  continue;
                }
              }
              handled = this.#handlePercent(
                animKey,
                current,
                data,
                position,
                el,
                results,
                parentClientHeight,
                parentClientWidth
              );
              break;
            }
            case "%~":
              handled = this.#handleRelativePercent(animKey, current, data, position, el, results);
              break;
            case "px":
              handled = this.#animKeyTypes.numPx.has(key) ? this.#applyResultsValue(animKey, current, data, results) : false;
              break;
            case "rad":
            case "turn":
              handled = this.#animKeyTypes.rotationRadTurn.has(key) ? this.#handleRotationRadTurn(animKey, current, data, position, el, results) : false;
              break;
            default:
              handled = this.#applyResultsValue(animKey, current, data, results);
              break;
          }
        }
        if (!regexResults || !handled) {
          console.warn(
            `TJSPosition - ConvertStringData warning: malformed key '${key}' with value '${value}'.`
          );
          data[key] = void 0;
        }
      }
    }
    return data;
  }
  // Internal implementation ----------------------------------------------------------------------------------------
  /**
   * Provides the common update to source data after `results.value` has been converted to the proper value
   * respectively.
   *
   * @param {import('../animation/types').AnimationAPI.AnimationKey} key - Animation key.
   *
   * @param {number}   current - Current value
   *
   * @param {import('../data/types').Data.TJSPositionDataRelative}  data - Source data to convert.
   *
   * @param {import('./types-local').StringMatch}  results - Match results.
   *
   * @returns {boolean} Adjustment successful.
   */
  static #applyResultsValue(key, current, data, results) {
    if (!results.operation) {
      data[key] = results.value;
      return true;
    }
    switch (results.operation) {
      case "-=":
        data[key] = current - results.value;
        break;
      case "+=":
        data[key] = current + results.value;
        break;
      case "*=":
        data[key] = current * results.value;
        break;
      default:
        return false;
    }
    return true;
  }
  /**
   * Handles the `%` unit type where values are adjusted against the parent element client width / height or in the
   * case of rotation the percentage of 360 degrees.
   *
   * @param {import('../animation/types').AnimationAPI.AnimationKey} key - Animation key.
   *
   * @param {number}   current - Current value
   *
   * @param {import('../data/types').Data.TJSPositionDataRelative}  data - Source data to convert.
   *
   * @param {import('../data/types').Data.TJSPositionData} position - Current position data.
   *
   * @param {HTMLElement} el - Positioned element.
   *
   * @param {import('./types-local').StringMatch}  results - Match results.
   *
   * @param {number}  parentClientHeight - Parent element client height.
   *
   * @param {number}  parentClientWidth - Parent element client width.
   *
   * @returns {boolean} Adjustment successful.
   */
  static #handlePercent(key, current, data, position, el, results, parentClientHeight, parentClientWidth) {
    switch (key) {
      case "left":
      case "maxWidth":
      case "minWidth":
      case "width":
      case "translateX":
        results.value = parentClientWidth * (results.value / 100);
        break;
      case "top":
      case "maxHeight":
      case "minHeight":
      case "height":
      case "translateY":
        results.value = parentClientHeight * (results.value / 100);
        break;
      case "rotateX":
      case "rotateY":
      case "rotateZ":
      case "rotation":
        results.value = 360 * (results.value / 100);
        break;
      default:
        return false;
    }
    return this.#applyResultsValue(key, current, data, results);
  }
  /**
   * Handles the `%~` unit type where values are adjusted against the current value for the given key.
   *
   * @param {import('../animation/types').AnimationAPI.AnimationKey} key - Animation key.
   *
   * @param {number}   current - Current value
   *
   * @param {import('../data/types').Data.TJSPositionDataRelative}  data - Source data to convert.
   *
   * @param {import('../data/types').Data.TJSPositionData} position - Current position data.
   *
   * @param {HTMLElement} el - Positioned element.
   *
   * @param {import('./types-local').StringMatch}  results - Match results.
   *
   * @returns {boolean} Adjustment successful.
   */
  static #handleRelativePercent(key, current, data, position, el, results) {
    results.value = results.value / 100;
    if (!results.operation) {
      data[key] = current * results.value;
      return true;
    }
    switch (results.operation) {
      case "-=":
        data[key] = current - current * results.value;
        break;
      case "+=":
        data[key] = current + current * results.value;
        break;
      case "*=":
        data[key] = current * (current * results.value);
        break;
      default:
        return false;
    }
    return true;
  }
  /**
   * Handles the `rad` / `turn` unit types for rotation animation keys.
   *
   * @param {import('../animation/types').AnimationAPI.AnimationKey} key - Animation key.
   *
   * @param {number}   current - Current value
   *
   * @param {import('../data/types').Data.TJSPositionDataRelative}  data - Source data to convert.
   *
   * @param {import('../data/types').Data.TJSPositionData} position - Current position data.
   *
   * @param {HTMLElement} el - Positioned element.
   *
   * @param {import('./types-local').StringMatch}  results - Match results.
   *
   * @returns {boolean} Adjustment successful.
   */
  static #handleRotationRadTurn(key, current, data, position, el, results) {
    switch (results.unit) {
      case "rad":
        results.value = radToDeg(results.value);
        break;
      case "turn":
        results.value = 360 * results.value;
        break;
    }
    return this.#applyResultsValue(key, current, data, results);
  }
}
class TJSTransformData {
  static {
    __name(this, "TJSTransformData");
  }
  constructor() {
    Object.seal(this);
  }
  /**
   * Stores the calculated bounding rectangle.
   *
   * @type {DOMRect}
   */
  #boundingRect = new DOMRect();
  /**
   * Stores the individual transformed corner points of the window in screen space clockwise from:
   * top left -> top right -> bottom right -> bottom left.
   *
   * @type {import('#runtime/math/gl-matrix').Vec3[]}
   */
  #corners = [Vec3.create(), Vec3.create(), Vec3.create(), Vec3.create()];
  /**
   * Stores the current gl-matrix Mat4 data.
   *
   * @type {import('#runtime/math/gl-matrix').Mat4}
   */
  #mat4 = Mat4.create();
  /**
   * Stores the pre & post origin translations to apply to matrix transforms.
   *
   * @type {import('#runtime/math/gl-matrix').Mat4[]}
   */
  #originTranslations = [Mat4.create(), Mat4.create()];
  /**
   * @returns {DOMRect} The bounding rectangle.
   */
  get boundingRect() {
    return this.#boundingRect;
  }
  /**
   * @returns {import('#runtime/math/gl-matrix').Vec3[]} The transformed corner points as Vec3 in screen space.
   */
  get corners() {
    return this.#corners;
  }
  /**
   * @returns {string} Returns the CSS style string for the transform matrix.
   */
  get css() {
    return `matrix3d(${this.mat4.join(",")})`;
  }
  /**
   * @returns {import('#runtime/math/gl-matrix').Mat4} The transform matrix.
   */
  get mat4() {
    return this.#mat4;
  }
  /**
   * @returns {import('#runtime/math/gl-matrix').Mat4[]} The pre / post translation matrices for origin translation.
   */
  get originTranslations() {
    return this.#originTranslations;
  }
}
class TJSTransforms {
  static {
    __name(this, "TJSTransforms");
  }
  /**
   * Stores transform data.
   *
   * @type {Partial<import('../data/types').Data.TJSPositionData>}
   */
  #data = {};
  /**
   * Stores the transform keys in the order added.
   *
   * @type {string[]}
   */
  #orderList = [];
  /**
   * Defines the keys of TJSPositionData that are transform keys.
   *
   * @type {string[]}
   */
  static #transformKeys = Object.freeze([
    "rotateX",
    "rotateY",
    "rotateZ",
    "scale",
    "translateX",
    "translateY",
    "translateZ"
  ]);
  /**
   * Defines bitwise keys for transforms used in {@link TJSTransforms.getMat4}.
   *
   * @type {object}
   */
  static #transformKeysBitwise = Object.freeze({
    rotateX: 1,
    rotateY: 2,
    rotateZ: 4,
    scale: 8,
    translateX: 16,
    translateY: 32,
    translateZ: 64
  });
  /**
   * Defines the default transform origin.
   *
   * @type {Readonly<import('./types').TransformAPI.TransformOrigin>}
   */
  static #transformOriginDefault = "top left";
  /**
   * Defines the valid transform origins.
   *
   * @type {Readonly<import('./types').TransformAPI.TransformOrigin[]>}
   */
  static #transformOrigins = Object.freeze([
    "top left",
    "top center",
    "top right",
    "center left",
    "center",
    "center right",
    "bottom left",
    "bottom center",
    "bottom right"
  ]);
  /**
   * Defines a valid Set of transform origins.
   *
   * @type {ReadonlySet<import('./types').TransformAPI.TransformOrigin>}
   */
  static #transformOriginsSet = Object.freeze(new Set(this.#transformOrigins));
  // Temporary variables --------------------------------------------------------------------------------------------
  /** @type {import('#runtime/math/gl-matrix').Mat4} */
  static #mat4Result = Mat4.create();
  /** @type {import('#runtime/math/gl-matrix').Mat4} */
  static #mat4Temp = Mat4.create();
  /** @type {import('#runtime/math/gl-matrix').Vec3} */
  static #vec3Temp = Vec3.create();
  /** @type {number[]} */
  static #vectorScale = [1, 1, 1];
  /** @type {number[]} */
  static #vectorTranslate = [0, 0, 0];
  /**
   * Returns a list of supported transform origins.
   *
   * @returns {Readonly<import('./types').TransformAPI.TransformOrigin[]>} The supported transform origin strings.
   */
  static get transformOrigins() {
    return this.#transformOrigins;
  }
  /**
   * Returns whether the given string is a {@link TransformAPI.TransformOrigin}.
   *
   * @param {unknown}  origin - A potential transform origin string.
   *
   * @returns {origin is import('./types').TransformAPI.TransformOrigin}
   */
  static isTransformOrigin(origin) {
    return this.#transformOriginsSet.has(origin);
  }
  /**
   * @returns {boolean} Whether there are active transforms in local data.
   */
  get isActive() {
    return this.#orderList.length > 0;
  }
  /**
   * @returns {number|undefined} Any local rotateX data.
   */
  get rotateX() {
    return this.#data.rotateX;
  }
  /**
   * @returns {number|undefined} Any local rotateY data.
   */
  get rotateY() {
    return this.#data.rotateY;
  }
  /**
   * @returns {number|undefined} Any local rotateZ data.
   */
  get rotateZ() {
    return this.#data.rotateZ;
  }
  /**
   * @returns {number|undefined} Any local rotateZ scale.
   */
  get scale() {
    return this.#data.scale;
  }
  /**
   * @returns {number|undefined} Any local translateZ data.
   */
  get translateX() {
    return this.#data.translateX;
  }
  /**
   * @returns {number|undefined} Any local translateZ data.
   */
  get translateY() {
    return this.#data.translateY;
  }
  /**
   * @returns {number|undefined} Any local translateZ data.
   */
  get translateZ() {
    return this.#data.translateZ;
  }
  /**
   * Sets the local rotateX data if the value is a finite number otherwise removes the local data.
   *
   * @param {number|null|undefined}   value - A value to set.
   */
  set rotateX(value) {
    if (Number.isFinite(value)) {
      if (this.#data.rotateX === void 0) {
        this.#orderList.push("rotateX");
      }
      this.#data.rotateX = value;
    } else {
      if (this.#data.rotateX !== void 0) {
        const index = this.#orderList.findIndex((entry) => entry === "rotateX");
        if (index >= 0) {
          this.#orderList.splice(index, 1);
        }
      }
      delete this.#data.rotateX;
    }
  }
  /**
   * Sets the local rotateY data if the value is a finite number otherwise removes the local data.
   *
   * @param {number|null|undefined}   value - A value to set.
   */
  set rotateY(value) {
    if (Number.isFinite(value)) {
      if (this.#data.rotateY === void 0) {
        this.#orderList.push("rotateY");
      }
      this.#data.rotateY = value;
    } else {
      if (this.#data.rotateY !== void 0) {
        const index = this.#orderList.findIndex((entry) => entry === "rotateY");
        if (index >= 0) {
          this.#orderList.splice(index, 1);
        }
      }
      delete this.#data.rotateY;
    }
  }
  /**
   * Sets the local rotateZ data if the value is a finite number otherwise removes the local data.
   *
   * @param {number|null|undefined}   value - A value to set.
   */
  set rotateZ(value) {
    if (Number.isFinite(value)) {
      if (this.#data.rotateZ === void 0) {
        this.#orderList.push("rotateZ");
      }
      this.#data.rotateZ = value;
    } else {
      if (this.#data.rotateZ !== void 0) {
        const index = this.#orderList.findIndex((entry) => entry === "rotateZ");
        if (index >= 0) {
          this.#orderList.splice(index, 1);
        }
      }
      delete this.#data.rotateZ;
    }
  }
  /**
   * Sets the local scale data if the value is a finite number otherwise removes the local data.
   *
   * @param {number|null|undefined}   value - A value to set.
   */
  set scale(value) {
    if (Number.isFinite(value)) {
      if (this.#data.scale === void 0) {
        this.#orderList.push("scale");
      }
      this.#data.scale = value;
    } else {
      if (this.#data.scale !== void 0) {
        const index = this.#orderList.findIndex((entry) => entry === "scale");
        if (index >= 0) {
          this.#orderList.splice(index, 1);
        }
      }
      delete this.#data.scale;
    }
  }
  /**
   * Sets the local translateX data if the value is a finite number otherwise removes the local data.
   *
   * @param {number|null|undefined}   value - A value to set.
   */
  set translateX(value) {
    if (Number.isFinite(value)) {
      if (this.#data.translateX === void 0) {
        this.#orderList.push("translateX");
      }
      this.#data.translateX = value;
    } else {
      if (this.#data.translateX !== void 0) {
        const index = this.#orderList.findIndex((entry) => entry === "translateX");
        if (index >= 0) {
          this.#orderList.splice(index, 1);
        }
      }
      delete this.#data.translateX;
    }
  }
  /**
   * Sets the local translateY data if the value is a finite number otherwise removes the local data.
   *
   * @param {number|null|undefined}   value - A value to set.
   */
  set translateY(value) {
    if (Number.isFinite(value)) {
      if (this.#data.translateY === void 0) {
        this.#orderList.push("translateY");
      }
      this.#data.translateY = value;
    } else {
      if (this.#data.translateY !== void 0) {
        const index = this.#orderList.findIndex((entry) => entry === "translateY");
        if (index >= 0) {
          this.#orderList.splice(index, 1);
        }
      }
      delete this.#data.translateY;
    }
  }
  /**
   * Sets the local translateZ data if the value is a finite number otherwise removes the local data.
   *
   * @param {number|null|undefined}   value - A value to set.
   */
  set translateZ(value) {
    if (Number.isFinite(value)) {
      if (this.#data.translateZ === void 0) {
        this.#orderList.push("translateZ");
      }
      this.#data.translateZ = value;
    } else {
      if (this.#data.translateZ !== void 0) {
        const index = this.#orderList.findIndex((entry) => entry === "translateZ");
        if (index >= 0) {
          this.#orderList.splice(index, 1);
        }
      }
      delete this.#data.translateZ;
    }
  }
  /**
   * Returns the matrix3d CSS transform for the given position / transform data.
   *
   * @param {object} [data] - Optional position data otherwise use local stored transform data.
   *
   * @returns {string} The CSS matrix3d string.
   */
  getCSS(data = this.#data) {
    return `matrix3d(${this.getMat4(data, TJSTransforms.#mat4Result).join(",")})`;
  }
  /**
   * Returns the matrix3d CSS transform for the given position / transform data.
   *
   * @param {object} [data] - Optional position data otherwise use local stored transform data.
   *
   * @returns {string} The CSS matrix3d string.
   */
  getCSSOrtho(data = this.#data) {
    return `matrix3d(${this.getMat4Ortho(data, TJSTransforms.#mat4Result).join(",")})`;
  }
  /**
   * Collects all data including a bounding rect, transform matrix, and points array of the given
   * {@link TJSPositionData} instance with the applied local transform data.
   *
   * @param {import('../data/types').Data.TJSPositionData} position - The position data to process.
   *
   * @param {import('./types').TransformAPI.TransformData} [output] - Optional TJSTransformData output instance.
   *
   * @param {object} [validationData] - Optional validation data for adjustment parameters.
   *
   * @returns {import('./types').TransformAPI.TransformData} The output TJSTransformData instance.
   */
  getData(position, output = new TJSTransformData(), validationData = {}) {
    const valWidth = validationData.width ?? 0;
    const valHeight = validationData.height ?? 0;
    const valOffsetTop = validationData.offsetTop ?? validationData.marginTop ?? 0;
    const valOffsetLeft = validationData.offsetLeft ?? validationData.marginLeft ?? 0;
    position.top += valOffsetTop;
    position.left += valOffsetLeft;
    const width = Number.isFinite(position.width) ? position.width : valWidth;
    const height = Number.isFinite(position.height) ? position.height : valHeight;
    const rect = output.corners;
    if (this.hasTransform(position)) {
      rect[0][0] = rect[0][1] = rect[0][2] = 0;
      rect[1][0] = width;
      rect[1][1] = rect[1][2] = 0;
      rect[2][0] = width;
      rect[2][1] = height;
      rect[2][2] = 0;
      rect[3][0] = 0;
      rect[3][1] = height;
      rect[3][2] = 0;
      const matrix = this.getMat4(position, output.mat4);
      const translate = TJSTransforms.#getOriginTranslation(position.transformOrigin, width, height, output.originTranslations);
      if (TJSTransforms.#transformOriginDefault === position.transformOrigin) {
        Vec3.transformMat4(rect[0], rect[0], matrix);
        Vec3.transformMat4(rect[1], rect[1], matrix);
        Vec3.transformMat4(rect[2], rect[2], matrix);
        Vec3.transformMat4(rect[3], rect[3], matrix);
      } else {
        Vec3.transformMat4(rect[0], rect[0], translate[0]);
        Vec3.transformMat4(rect[0], rect[0], matrix);
        Vec3.transformMat4(rect[0], rect[0], translate[1]);
        Vec3.transformMat4(rect[1], rect[1], translate[0]);
        Vec3.transformMat4(rect[1], rect[1], matrix);
        Vec3.transformMat4(rect[1], rect[1], translate[1]);
        Vec3.transformMat4(rect[2], rect[2], translate[0]);
        Vec3.transformMat4(rect[2], rect[2], matrix);
        Vec3.transformMat4(rect[2], rect[2], translate[1]);
        Vec3.transformMat4(rect[3], rect[3], translate[0]);
        Vec3.transformMat4(rect[3], rect[3], matrix);
        Vec3.transformMat4(rect[3], rect[3], translate[1]);
      }
      rect[0][0] = position.left + rect[0][0];
      rect[0][1] = position.top + rect[0][1];
      rect[1][0] = position.left + rect[1][0];
      rect[1][1] = position.top + rect[1][1];
      rect[2][0] = position.left + rect[2][0];
      rect[2][1] = position.top + rect[2][1];
      rect[3][0] = position.left + rect[3][0];
      rect[3][1] = position.top + rect[3][1];
    } else {
      rect[0][0] = position.left;
      rect[0][1] = position.top;
      rect[1][0] = position.left + width;
      rect[1][1] = position.top;
      rect[2][0] = position.left + width;
      rect[2][1] = position.top + height;
      rect[3][0] = position.left;
      rect[3][1] = position.top + height;
      Mat4.identity(output.mat4);
    }
    let maxX = Number.MIN_SAFE_INTEGER;
    let maxY = Number.MIN_SAFE_INTEGER;
    let minX = Number.MAX_SAFE_INTEGER;
    let minY = Number.MAX_SAFE_INTEGER;
    for (let cntr = 4; --cntr >= 0; ) {
      if (rect[cntr][0] > maxX) {
        maxX = rect[cntr][0];
      }
      if (rect[cntr][0] < minX) {
        minX = rect[cntr][0];
      }
      if (rect[cntr][1] > maxY) {
        maxY = rect[cntr][1];
      }
      if (rect[cntr][1] < minY) {
        minY = rect[cntr][1];
      }
    }
    const boundingRect = output.boundingRect;
    boundingRect.x = minX;
    boundingRect.y = minY;
    boundingRect.width = maxX - minX;
    boundingRect.height = maxY - minY;
    position.top -= valOffsetTop;
    position.left -= valOffsetLeft;
    return output;
  }
  /**
   * Creates a transform matrix based on local data applied in order it was added.
   *
   * If no data object is provided then the source is the local transform data. If another data object is supplied
   * then the stored local transform order is applied then all remaining transform keys are applied. This allows the
   * construction of a transform matrix in advance of setting local data and is useful in collision detection.
   *
   * @param {import('../data/types').Data.TJSPositionData}   [data] - TJSPositionData instance or local transform data.
   *
   * @param {import('#runtime/math/gl-matrix').Mat4}  [output] - The output mat4 instance.
   *
   * @returns {import('#runtime/math/gl-matrix').Mat4} Transform matrix.
   */
  getMat4(data = this.#data, output = Mat4.create()) {
    const matrix = Mat4.identity(output);
    let seenKeys = 0;
    const orderList = this.#orderList;
    for (let cntr = 0; cntr < orderList.length; cntr++) {
      const key = orderList[cntr];
      switch (key) {
        case "rotateX":
          seenKeys |= TJSTransforms.#transformKeysBitwise.rotateX;
          Mat4.multiply(matrix, matrix, Mat4.fromXRotation(TJSTransforms.#mat4Temp, degToRad(data[key])));
          break;
        case "rotateY":
          seenKeys |= TJSTransforms.#transformKeysBitwise.rotateY;
          Mat4.multiply(matrix, matrix, Mat4.fromYRotation(TJSTransforms.#mat4Temp, degToRad(data[key])));
          break;
        case "rotateZ":
          seenKeys |= TJSTransforms.#transformKeysBitwise.rotateZ;
          Mat4.multiply(matrix, matrix, Mat4.fromZRotation(TJSTransforms.#mat4Temp, degToRad(data[key])));
          break;
        case "scale":
          seenKeys |= TJSTransforms.#transformKeysBitwise.scale;
          TJSTransforms.#vectorScale[0] = TJSTransforms.#vectorScale[1] = data[key];
          Mat4.multiply(matrix, matrix, Mat4.fromScaling(TJSTransforms.#mat4Temp, TJSTransforms.#vectorScale));
          break;
        case "translateX":
          seenKeys |= TJSTransforms.#transformKeysBitwise.translateX;
          TJSTransforms.#vectorTranslate[0] = data.translateX;
          TJSTransforms.#vectorTranslate[1] = 0;
          TJSTransforms.#vectorTranslate[2] = 0;
          Mat4.multiply(matrix, matrix, Mat4.fromTranslation(TJSTransforms.#mat4Temp, TJSTransforms.#vectorTranslate));
          break;
        case "translateY":
          seenKeys |= TJSTransforms.#transformKeysBitwise.translateY;
          TJSTransforms.#vectorTranslate[0] = 0;
          TJSTransforms.#vectorTranslate[1] = data.translateY;
          TJSTransforms.#vectorTranslate[2] = 0;
          Mat4.multiply(matrix, matrix, Mat4.fromTranslation(TJSTransforms.#mat4Temp, TJSTransforms.#vectorTranslate));
          break;
        case "translateZ":
          seenKeys |= TJSTransforms.#transformKeysBitwise.translateZ;
          TJSTransforms.#vectorTranslate[0] = 0;
          TJSTransforms.#vectorTranslate[1] = 0;
          TJSTransforms.#vectorTranslate[2] = data.translateZ;
          Mat4.multiply(matrix, matrix, Mat4.fromTranslation(TJSTransforms.#mat4Temp, TJSTransforms.#vectorTranslate));
          break;
      }
    }
    if (data !== this.#data) {
      for (let cntr = 0; cntr < TJSTransforms.#transformKeys.length; cntr++) {
        const key = TJSTransforms.#transformKeys[cntr];
        if (data[key] === null || (seenKeys & TJSTransforms.#transformKeysBitwise[key]) > 0) {
          continue;
        }
        switch (key) {
          case "rotateX":
            Mat4.multiply(matrix, matrix, Mat4.fromXRotation(TJSTransforms.#mat4Temp, degToRad(data[key])));
            break;
          case "rotateY":
            Mat4.multiply(matrix, matrix, Mat4.fromYRotation(TJSTransforms.#mat4Temp, degToRad(data[key])));
            break;
          case "rotateZ":
            Mat4.multiply(matrix, matrix, Mat4.fromZRotation(TJSTransforms.#mat4Temp, degToRad(data[key])));
            break;
          case "scale":
            TJSTransforms.#vectorScale[0] = TJSTransforms.#vectorScale[1] = data[key];
            Mat4.multiply(matrix, matrix, Mat4.fromScaling(TJSTransforms.#mat4Temp, TJSTransforms.#vectorScale));
            break;
          case "translateX":
            TJSTransforms.#vectorTranslate[0] = data[key];
            TJSTransforms.#vectorTranslate[1] = 0;
            TJSTransforms.#vectorTranslate[2] = 0;
            Mat4.multiply(matrix, matrix, Mat4.fromTranslation(TJSTransforms.#mat4Temp, TJSTransforms.#vectorTranslate));
            break;
          case "translateY":
            TJSTransforms.#vectorTranslate[0] = 0;
            TJSTransforms.#vectorTranslate[1] = data[key];
            TJSTransforms.#vectorTranslate[2] = 0;
            Mat4.multiply(matrix, matrix, Mat4.fromTranslation(TJSTransforms.#mat4Temp, TJSTransforms.#vectorTranslate));
            break;
          case "translateZ":
            TJSTransforms.#vectorTranslate[0] = 0;
            TJSTransforms.#vectorTranslate[1] = 0;
            TJSTransforms.#vectorTranslate[2] = data[key];
            Mat4.multiply(matrix, matrix, Mat4.fromTranslation(TJSTransforms.#mat4Temp, TJSTransforms.#vectorTranslate));
            break;
        }
      }
    }
    return matrix;
  }
  /**
   * Provides an orthographic enhancement to convert left / top positional data to a translate operation.
   *
   * This transform matrix takes into account that the remaining operations are , but adds any left / top attributes from passed in data to
   * translate X / Y.
   *
   * If no data object is provided then the source is the local transform data. If another data object is supplied
   * then the stored local transform order is applied then all remaining transform keys are applied. This allows the
   * construction of a transform matrix in advance of setting local data and is useful in collision detection.
   *
   * @param {Partial<import('../data/types').Data.TJSPositionData>}   [data] - TJSPositionData instance or local
   *        transform data.
   *
   * @param {import('#runtime/math/gl-matrix').Mat4}  [output] - The output mat4 instance.
   *
   * @returns {import('#runtime/math/gl-matrix').Mat4} Transform matrix.
   */
  getMat4Ortho(data = this.#data, output = Mat4.create()) {
    const matrix = Mat4.identity(output);
    TJSTransforms.#vectorTranslate[0] = (data.left ?? 0) + (data.translateX ?? 0);
    TJSTransforms.#vectorTranslate[1] = (data.top ?? 0) + (data.translateY ?? 0);
    TJSTransforms.#vectorTranslate[2] = data.translateZ ?? 0;
    Mat4.multiply(matrix, matrix, Mat4.fromTranslation(TJSTransforms.#mat4Temp, TJSTransforms.#vectorTranslate));
    if (data.scale !== null) {
      TJSTransforms.#vectorScale[0] = TJSTransforms.#vectorScale[1] = data.scale;
      Mat4.multiply(matrix, matrix, Mat4.fromScaling(TJSTransforms.#mat4Temp, TJSTransforms.#vectorScale));
    }
    if (data.rotateX === null && data.rotateY === null && data.rotateZ === null) {
      return matrix;
    }
    let seenKeys = 0;
    const orderList = this.#orderList;
    for (let cntr = 0; cntr < orderList.length; cntr++) {
      const key = orderList[cntr];
      switch (key) {
        case "rotateX":
          seenKeys |= TJSTransforms.#transformKeysBitwise.rotateX;
          Mat4.multiply(matrix, matrix, Mat4.fromXRotation(TJSTransforms.#mat4Temp, degToRad(data[key])));
          break;
        case "rotateY":
          seenKeys |= TJSTransforms.#transformKeysBitwise.rotateY;
          Mat4.multiply(matrix, matrix, Mat4.fromYRotation(TJSTransforms.#mat4Temp, degToRad(data[key])));
          break;
        case "rotateZ":
          seenKeys |= TJSTransforms.#transformKeysBitwise.rotateZ;
          Mat4.multiply(matrix, matrix, Mat4.fromZRotation(TJSTransforms.#mat4Temp, degToRad(data[key])));
          break;
      }
    }
    if (data !== this.#data) {
      for (let cntr = 0; cntr < TJSTransforms.#transformKeys.length; cntr++) {
        const key = TJSTransforms.#transformKeys[cntr];
        if (data[key] === null || (seenKeys & TJSTransforms.#transformKeysBitwise[key]) > 0) {
          continue;
        }
        switch (key) {
          case "rotateX":
            Mat4.multiply(matrix, matrix, Mat4.fromXRotation(TJSTransforms.#mat4Temp, degToRad(data[key])));
            break;
          case "rotateY":
            Mat4.multiply(matrix, matrix, Mat4.fromYRotation(TJSTransforms.#mat4Temp, degToRad(data[key])));
            break;
          case "rotateZ":
            Mat4.multiply(matrix, matrix, Mat4.fromZRotation(TJSTransforms.#mat4Temp, degToRad(data[key])));
            break;
        }
      }
    }
    return matrix;
  }
  /**
   * Tests an object if it contains transform keys and the values are finite numbers.
   *
   * @param {import('../data/types').Data.TJSPositionData} data - An object to test for transform data.
   *
   * @returns {boolean} Whether the given TJSPositionData has transforms.
   */
  hasTransform(data) {
    for (const key of TJSTransforms.#transformKeys) {
      if (Number.isFinite(data[key])) {
        return true;
      }
    }
    return false;
  }
  /**
   * Resets internal data from the given object containing valid transform keys.
   *
   * @param {object}   data - An object with transform data.
   */
  reset(data) {
    for (const key in data) {
      if (TJSTransforms.#transformKeys.includes(key)) {
        if (Number.isFinite(data[key])) {
          this.#data[key] = data[key];
        } else {
          const index = this.#orderList.findIndex((entry) => entry === key);
          if (index >= 0) {
            this.#orderList.splice(index, 1);
          }
          delete this.#data[key];
        }
      }
    }
  }
  // Internal implementation ----------------------------------------------------------------------------------------
  /**
   * Returns the translations necessary to translate a matrix operation based on the `transformOrigin` parameter of the
   * given position instance. The first entry / index 0 is the pre-translation and last entry / index 1 is the post-
   * translation.
   *
   * This method is used internally, but may be useful if you need the origin translation matrices to transform
   * bespoke points based on any `transformOrigin` set in {@link TJSPositionData}.
   *
   * @param {string}   transformOrigin - The transform origin attribute from TJSPositionData.
   *
   * @param {number}   width - The TJSPositionData width or validation data width when 'auto'.
   *
   * @param {number}   height - The TJSPositionData height or validation data height when 'auto'.
   *
   * @param {import('#runtime/math/gl-matrix').Mat4[]}   output - Output Mat4 array.
   *
   * @returns {import('#runtime/math/gl-matrix').Mat4[]} Output Mat4 array.
   */
  static #getOriginTranslation(transformOrigin, width, height, output) {
    const vector = TJSTransforms.#vec3Temp;
    switch (transformOrigin) {
      case "top left":
        vector[0] = vector[1] = 0;
        Mat4.fromTranslation(output[0], vector);
        Mat4.fromTranslation(output[1], vector);
        break;
      case "top center":
        vector[0] = -width * 0.5;
        vector[1] = 0;
        Mat4.fromTranslation(output[0], vector);
        vector[0] = width * 0.5;
        Mat4.fromTranslation(output[1], vector);
        break;
      case "top right":
        vector[0] = -width;
        vector[1] = 0;
        Mat4.fromTranslation(output[0], vector);
        vector[0] = width;
        Mat4.fromTranslation(output[1], vector);
        break;
      case "center left":
        vector[0] = 0;
        vector[1] = -height * 0.5;
        Mat4.fromTranslation(output[0], vector);
        vector[1] = height * 0.5;
        Mat4.fromTranslation(output[1], vector);
        break;
      case null:
      case "center":
        vector[0] = -width * 0.5;
        vector[1] = -height * 0.5;
        Mat4.fromTranslation(output[0], vector);
        vector[0] = width * 0.5;
        vector[1] = height * 0.5;
        Mat4.fromTranslation(output[1], vector);
        break;
      case "center right":
        vector[0] = -width;
        vector[1] = -height * 0.5;
        Mat4.fromTranslation(output[0], vector);
        vector[0] = width;
        vector[1] = height * 0.5;
        Mat4.fromTranslation(output[1], vector);
        break;
      case "bottom left":
        vector[0] = 0;
        vector[1] = -height;
        Mat4.fromTranslation(output[0], vector);
        vector[1] = height;
        Mat4.fromTranslation(output[1], vector);
        break;
      case "bottom center":
        vector[0] = -width * 0.5;
        vector[1] = -height;
        Mat4.fromTranslation(output[0], vector);
        vector[0] = width * 0.5;
        vector[1] = height;
        Mat4.fromTranslation(output[1], vector);
        break;
      case "bottom right":
        vector[0] = -width;
        vector[1] = -height;
        Mat4.fromTranslation(output[0], vector);
        vector[0] = width;
        vector[1] = height;
        Mat4.fromTranslation(output[1], vector);
        break;
      default:
        Mat4.identity(output[0]);
        Mat4.identity(output[1]);
        break;
    }
    return output;
  }
}
class AnimationScheduler {
  static {
    __name(this, "AnimationScheduler");
  }
  /**
   * Used to copy data from a TJSPosition instance.
   *
   * @type {import('../data/types').Data.TJSPositionData}
   */
  static #data = {};
  static #getEaseOptions = Object.freeze({ default: false });
  /**
   * Adds / schedules an animation w/ the AnimationManager. This contains the final steps common to all tweens.
   *
   * @param {import('../').TJSPosition} position -
   *
   * @param {object}      initial -
   *
   * @param {object}      destination -
   *
   * @param {number}      duration -
   *
   * @param {HTMLElement} el -
   *
   * @param {number}      delay -
   *
   * @param {import('#runtime/svelte/easing').EasingFunction}    ease -
   *
   * @param {import('#runtime/math/interpolate').InterpolateFunction}    [interpolate=lerp] -
   *
   * @param {import('../transform/types').TransformAPI.TransformOrigin}  [transformOrigin] -
   *
   * @param {import('../transform/types').TransformAPI.TransformOrigin}  [transformOriginInitial] -
   *
   * @param {import('./types-local').AnimationCleanupFunction} [cleanup] -
   *
   * @returns {import('./AnimationControl').AnimationControl | null} An AnimationControl instance or null if none
   *          created.
   */
  static #addAnimation(position, initial, destination, duration, el, delay, ease, interpolate = lerp, transformOrigin, transformOriginInitial, cleanup) {
    TJSPositionDataUtil.setNumericDefaults(initial);
    TJSPositionDataUtil.setNumericDefaults(destination);
    for (const key in initial) {
      if (!Number.isFinite(initial[key])) {
        delete initial[key];
      }
    }
    const keys = Object.keys(initial);
    const newData = Object.assign({}, initial);
    if (keys.length === 0) {
      return null;
    }
    const animationData = {
      active: true,
      cleanup,
      cancelled: false,
      control: void 0,
      current: 0,
      destination,
      duration: duration * 1e3,
      // Internally the AnimationManager works in ms.
      ease,
      el,
      finished: false,
      initial,
      interpolate,
      keys,
      newData,
      position,
      resolve: void 0,
      start: void 0,
      transformOrigin,
      transformOriginInitial,
      quickTo: false
    };
    if (delay > 0) {
      animationData.active = false;
      setTimeout(() => animationData.active = true, delay * 1e3);
    }
    AnimationManager.add(animationData);
    return new AnimationControl(animationData, true);
  }
  /**
   * Provides a tween from given position data to the current position.
   *
   * @param {import('../').TJSPosition} position - The target position instance.
   *
   * @param {import('../data/types').Data.TJSPositionDataRelative} fromData - The starting position.
   *
   * @param {import('./types').AnimationAPI.TweenOptions} options - Tween options.
   *
   * @param {import('./types-local').AnimationCleanupFunction} [cleanup] - Custom animation cleanup function.
   *
   * @returns {import('./AnimationControl').AnimationControl | null} An AnimationControl instance or null if none
   *          created.
   */
  static from(position, fromData, options = {}, cleanup) {
    if (!isObject(fromData)) {
      throw new TypeError(`AnimationAPI.from error: 'fromData' is not an object.`);
    }
    const parent = position.parent;
    if (parent !== void 0 && typeof parent?.options?.positionable === "boolean" && !parent?.options?.positionable) {
      return null;
    }
    let { delay = 0, duration = 1, ease = "cubicOut", strategy, transformOrigin } = options;
    if (strategy !== void 0) {
      if (this.#handleStrategy(position, strategy) === null) {
        return null;
      }
    }
    const targetEl = A11yHelper.isFocusTarget(parent) ? parent : parent?.elementTarget;
    const el = A11yHelper.isFocusTarget(targetEl) && targetEl.isConnected ? targetEl : void 0;
    if (!Number.isFinite(delay) || delay < 0) {
      throw new TypeError(`AnimationScheduler.from error: 'delay' is not a positive number.`);
    }
    if (!Number.isFinite(duration) || duration < 0) {
      throw new TypeError(`AnimationScheduler.from error: 'duration' is not a positive number.`);
    }
    ease = getEasingFunc(ease, this.#getEaseOptions);
    if (typeof ease !== "function") {
      throw new TypeError(
        `AnimationScheduler.from error: 'ease' is not a function or valid Svelte easing function name.`
      );
    }
    const initial = {};
    const destination = {};
    position.get(this.#data);
    transformOrigin = TJSTransforms.isTransformOrigin(transformOrigin) ? transformOrigin : void 0;
    const transformOriginInitial = transformOrigin !== void 0 ? this.#data.transformOrigin : void 0;
    for (const key in fromData) {
      const animKey = TJSPositionDataUtil.getAnimationKey(key);
      if (this.#data[animKey] !== void 0 && fromData[key] !== this.#data[animKey]) {
        initial[key] = fromData[key];
        destination[key] = this.#data[animKey];
      }
    }
    ConvertStringData.process(initial, this.#data, el);
    return this.#addAnimation(
      position,
      initial,
      destination,
      duration,
      el,
      delay,
      ease,
      lerp,
      transformOrigin,
      transformOriginInitial,
      cleanup
    );
  }
  /**
   * Provides a tween from given position data to the given position.
   *
   * @param {import('../').TJSPosition} position - The target position instance.
   *
   * @param {import('../data/types').Data.TJSPositionDataRelative} fromData - The starting position.
   *
   * @param {import('../data/types').Data.TJSPositionDataRelative} toData - The ending position.
   *
   * @param {import('./types').AnimationAPI.TweenOptions} options - Tween options.
   *
   * @param {import('./types-local').AnimationCleanupFunction} [cleanup] - Custom animation cleanup function.
   *
   * @returns {import('./AnimationControl').AnimationControl | null} An AnimationControl instance or null if none
   *          created.
   */
  static fromTo(position, fromData, toData, options = {}, cleanup) {
    if (!isObject(fromData)) {
      throw new TypeError(`AnimationScheduler.fromTo error: 'fromData' is not an object.`);
    }
    if (!isObject(toData)) {
      throw new TypeError(`AnimationScheduler.fromTo error: 'toData' is not an object.`);
    }
    const parent = position.parent;
    if (parent !== void 0 && typeof parent?.options?.positionable === "boolean" && !parent?.options?.positionable) {
      return null;
    }
    let { delay = 0, duration = 1, ease = "cubicOut", strategy, transformOrigin } = options;
    if (strategy !== void 0) {
      if (this.#handleStrategy(position, strategy) === null) {
        return null;
      }
    }
    const targetEl = A11yHelper.isFocusTarget(parent) ? parent : parent?.elementTarget;
    const el = A11yHelper.isFocusTarget(targetEl) && targetEl.isConnected ? targetEl : void 0;
    if (!Number.isFinite(delay) || delay < 0) {
      throw new TypeError(`AnimationScheduler.fromTo error: 'delay' is not a positive number.`);
    }
    if (!Number.isFinite(duration) || duration < 0) {
      throw new TypeError(`AnimationScheduler.fromTo error: 'duration' is not a positive number.`);
    }
    ease = getEasingFunc(ease, this.#getEaseOptions);
    if (typeof ease !== "function") {
      throw new TypeError(
        `AnimationScheduler.fromTo error: 'ease' is not a function or valid Svelte easing function name.`
      );
    }
    const initial = {};
    const destination = {};
    position.get(this.#data);
    transformOrigin = TJSTransforms.isTransformOrigin(transformOrigin) ? transformOrigin : void 0;
    const transformOriginInitial = transformOrigin !== void 0 ? this.#data.transformOrigin : void 0;
    for (const key in fromData) {
      if (toData[key] === void 0) {
        console.warn(`AnimationScheduler.fromTo warning: skipping key ('${key}') from 'fromData' as it is missing in 'toData'.`);
        continue;
      }
      const animKey = TJSPositionDataUtil.getAnimationKey(key);
      if (this.#data[animKey] !== void 0) {
        initial[key] = fromData[key];
        destination[key] = toData[key];
      }
    }
    ConvertStringData.process(initial, this.#data, el);
    ConvertStringData.process(destination, this.#data, el);
    return this.#addAnimation(
      position,
      initial,
      destination,
      duration,
      el,
      delay,
      ease,
      lerp,
      transformOrigin,
      transformOriginInitial,
      cleanup
    );
  }
  /**
   * Provides a tween to given position data from the current position.
   *
   * @param {import('../').TJSPosition} position - The target position instance.
   *
   * @param {import('../data/types').Data.TJSPositionDataRelative} toData - The destination position.
   *
   * @param {import('./types').AnimationAPI.TweenOptions} options - Tween options.
   *
   * @param {import('./types-local').AnimationCleanupFunction} [cleanup] - Custom animation cleanup function.
   *
   * @returns {import('./AnimationControl').AnimationControl | null} An AnimationControl instance or null if none
   *          created.
   */
  static to(position, toData, options = {}, cleanup) {
    if (!isObject(toData)) {
      throw new TypeError(`AnimationScheduler.to error: 'toData' is not an object.`);
    }
    const parent = position.parent;
    if (parent !== void 0 && typeof parent?.options?.positionable === "boolean" && !parent?.options?.positionable) {
      return null;
    }
    let { delay = 0, duration = 1, ease = "cubicOut", strategy, transformOrigin } = options;
    if (strategy !== void 0) {
      if (this.#handleStrategy(position, strategy) === null) {
        return null;
      }
    }
    const targetEl = A11yHelper.isFocusTarget(parent) ? parent : parent?.elementTarget;
    const el = A11yHelper.isFocusTarget(targetEl) && targetEl.isConnected ? targetEl : void 0;
    if (!Number.isFinite(delay) || delay < 0) {
      throw new TypeError(`AnimationScheduler.to error: 'delay' is not a positive number.`);
    }
    if (!Number.isFinite(duration) || duration < 0) {
      throw new TypeError(`AnimationScheduler.to error: 'duration' is not a positive number.`);
    }
    ease = getEasingFunc(ease, this.#getEaseOptions);
    if (typeof ease !== "function") {
      throw new TypeError(
        `AnimationScheduler.to error: 'ease' is not a function or valid Svelte easing function name.`
      );
    }
    const initial = {};
    const destination = {};
    position.get(this.#data);
    transformOrigin = TJSTransforms.isTransformOrigin(transformOrigin) ? transformOrigin : void 0;
    const transformOriginInitial = transformOrigin !== void 0 ? this.#data.transformOrigin : void 0;
    for (const key in toData) {
      const animKey = TJSPositionDataUtil.getAnimationKey(key);
      if (this.#data[animKey] !== void 0 && toData[key] !== this.#data[animKey]) {
        destination[key] = toData[key];
        initial[key] = this.#data[animKey];
      }
    }
    ConvertStringData.process(destination, this.#data, el);
    return this.#addAnimation(
      position,
      initial,
      destination,
      duration,
      el,
      delay,
      ease,
      lerp,
      transformOrigin,
      transformOriginInitial,
      cleanup
    );
  }
  // Internal implementation ----------------------------------------------------------------------------------------
  /**
   * Handle any defined scheduling strategy allowing existing scheduled animations for the same position instance
   * to be controlled.
   *
   * @param {import('../').TJSPosition} position - The target position instance.
   *
   * @param {import('./types').AnimationAPI.TweenOptions.strategy} strategy - A scheduling strategy to apply.
   *
   * @returns {undefined | null} Returns null to abort scheduling current animation.
   */
  static #handleStrategy(position, strategy) {
    switch (strategy) {
      case "cancel":
        if (AnimationManager.isScheduled(position)) {
          AnimationManager.cancel(position);
        }
        break;
      case "cancelAll":
        if (AnimationManager.isScheduled(position)) {
          AnimationManager.cancel(position, AnimationManager.cancelAllFn);
        }
        break;
      case "exclusive":
        if (AnimationManager.isScheduled(position)) {
          return null;
        }
        break;
      default:
        console.warn(`AnimationScheduler error: 'strategy' is not 'cancel', 'cancelAll', or 'exclusive'.`);
        return null;
    }
  }
}
class AnimationAPI {
  static {
    __name(this, "AnimationAPI");
  }
  static #getEaseOptions = Object.freeze({ default: false });
  /** @type {import('../data/types').Data.TJSPositionData} */
  #data;
  /** @type {import('../').TJSPosition} */
  #position;
  /**
   * @param {import('../').TJSPosition}       position -
   *
   * @param {import('../data/types').Data.TJSPositionData}   data -
   */
  constructor(position, data) {
    this.#position = position;
    this.#data = data;
    Object.seal(this);
  }
  /**
   * Returns if there are scheduled animations whether active or pending for this TJSPosition instance.
   *
   * @returns {boolean} Are there scheduled animations.
   */
  get isScheduled() {
    return AnimationManager.isScheduled(this.#position);
  }
  /**
   * Cancels all animation instances for this TJSPosition instance.
   */
  cancel() {
    AnimationManager.cancel(this.#position, AnimationManager.cancelAllFn);
  }
  /**
   * Returns all currently scheduled AnimationControl instances for this TJSPosition instance.
   *
   * @returns {import('#runtime/util/animate').BasicAnimation[]} All currently scheduled animation controls for
   *          this TJSPosition instance.
   */
  getScheduled() {
    return AnimationManager.getScheduled(this.#position);
  }
  /**
   * Provides a tween from given position data to the current position.
   *
   * @param {import('../data/types').Data.TJSPositionDataRelative} fromData - The starting position.
   *
   * @param {import('./types').AnimationAPI.TweenOptions} [options] - Optional tween parameters.
   *
   * @returns {import('#runtime/util/animate').BasicAnimation}  A control object that can cancel animation and
   *          provides a `finished` Promise.
   */
  from(fromData, options) {
    const animationControl = AnimationScheduler.from(this.#position, fromData, options);
    return animationControl ? animationControl : AnimationControl.voidControl;
  }
  /**
   * Provides a tween from given position data to the given position.
   *
   * @param {import('../data/types').Data.TJSPositionDataRelative} fromData - The starting position.
   *
   * @param {import('../data/types').Data.TJSPositionDataRelative} toData - The ending position.
   *
   * @param {import('./types').AnimationAPI.TweenOptions} [options] - Optional tween parameters.
   *
   * @returns {import('#runtime/util/animate').BasicAnimation}  A control object that can cancel animation and
   *          provides a `finished` Promise.
   */
  fromTo(fromData, toData, options) {
    const animationControl = AnimationScheduler.fromTo(this.#position, fromData, toData, options);
    return animationControl ? animationControl : AnimationControl.voidControl;
  }
  /**
   * Provides a tween to given position data from the current position.
   *
   * @param {import('../data/types').Data.TJSPositionDataRelative} toData - The destination position.
   *
   * @param {import('./types').AnimationAPI.TweenOptions} [options] - Optional tween parameters.
   *
   * @returns {import('#runtime/util/animate').BasicAnimation}  A control object that can cancel animation and
   *          provides a `finished` Promise.
   */
  to(toData, options) {
    const animationControl = AnimationScheduler.to(this.#position, toData, options);
    return animationControl ? animationControl : AnimationControl.voidControl;
  }
  /**
   * Returns a function that provides an optimized way to constantly update a to-tween.
   *
   * @param {Iterable<import('./types').AnimationAPI.AnimationKey>}  keys - The keys for quickTo.
   *
   * @param {import('./types').AnimationAPI.QuickTweenOptions} [options] - Optional quick tween parameters.
   *
   * @returns {import('./types').AnimationAPI.QuickToCallback} quick-to tween function.
   */
  quickTo(keys, options = {}) {
    if (!isIterable(keys)) {
      throw new TypeError(`AnimationAPI.quickTo error: 'keys' is not an iterable list.`);
    }
    const parent = this.#position.parent;
    if (parent !== void 0 && typeof parent?.options?.positionable === "boolean" && !parent?.options?.positionable) {
      throw new Error(`AnimationAPI.quickTo error: 'parent' is not positionable.`);
    }
    let { duration = 1, ease = "cubicOut" } = options;
    if (!Number.isFinite(duration) || duration < 0) {
      throw new TypeError(`AnimationAPI.quickTo error: 'duration' is not a positive number.`);
    }
    ease = getEasingFunc(ease, AnimationAPI.#getEaseOptions);
    if (typeof ease !== "function") {
      throw new TypeError(
        `AnimationAPI.quickTo error: 'ease' is not a function or valid Svelte easing function name.`
      );
    }
    const initial = {};
    const destination = {};
    const data = this.#data;
    for (const key of keys) {
      if (typeof key !== "string") {
        throw new TypeError(`AnimationAPI.quickTo error: key ('${key}') is not a string.`);
      }
      if (!TJSPositionDataUtil.isAnimationKey(key)) {
        throw new Error(`AnimationAPI.quickTo error: key ('${key}') is not animatable.`);
      }
      const value = TJSPositionDataUtil.getDataOrDefault(data, key, true);
      if (value !== null) {
        destination[key] = value;
        initial[key] = value;
      }
    }
    const keysArray = [...keys];
    Object.freeze(keysArray);
    const newData = Object.assign({}, initial);
    const animationData = {
      active: true,
      cancelled: false,
      control: void 0,
      current: 0,
      destination,
      duration: duration * 1e3,
      // Internally the AnimationManager works in ms.
      ease,
      el: void 0,
      finished: true,
      // Note: start in finished state to add to AnimationManager on first callback.
      initial,
      interpolate: lerp,
      keys,
      newData,
      position: this.#position,
      resolve: void 0,
      start: void 0,
      quickTo: true
    };
    const quickToCB = (
      /** @type {import('./types').AnimationAPI.QuickToCallback} */
      /* @__PURE__ */ __name((...args) => {
        const argsLength = args.length;
        if (argsLength === 0) {
          return;
        }
        for (let cntr = keysArray.length; --cntr >= 0; ) {
          const key = keysArray[cntr];
          const animKey = TJSPositionDataUtil.getAnimationKey(key);
          if (data[animKey] !== void 0) {
            initial[key] = data[animKey];
          }
        }
        if (isObject(args[0])) {
          const objData = args[0];
          for (const key in objData) {
            if (destination[key] !== void 0) {
              destination[key] = objData[key];
            }
          }
        } else {
          for (let cntr = 0; cntr < argsLength && cntr < keysArray.length; cntr++) {
            const key = keysArray[cntr];
            if (destination[key] !== void 0) {
              destination[key] = args[cntr];
            }
          }
        }
        TJSPositionDataUtil.setNumericDefaults(initial);
        TJSPositionDataUtil.setNumericDefaults(destination);
        const targetEl = A11yHelper.isFocusTarget(parent) ? parent : parent?.elementTarget;
        animationData.el = A11yHelper.isFocusTarget(targetEl) && targetEl.isConnected ? targetEl : void 0;
        ConvertStringData.process(destination, data, animationData.el);
        if (animationData.finished) {
          animationData.cancelled = false;
          animationData.finished = false;
          animationData.active = true;
          animationData.current = 0;
          AnimationManager.add(animationData);
        } else {
          const now2 = globalThis.performance.now();
          animationData.cancelled = false;
          animationData.current = 0;
          animationData.start = now2 + (AnimationManager.timeNow - now2);
        }
      }, "quickToCB")
    );
    quickToCB.keys = keysArray;
    quickToCB.options = (optionsCB) => {
      let { duration: duration2, ease: ease2 } = optionsCB;
      if (duration2 !== void 0 && (!Number.isFinite(duration2) || duration2 < 0)) {
        throw new TypeError(`AnimationAPI.quickTo.options error: 'duration' is not a positive number.`);
      }
      ease2 = getEasingFunc(ease2, AnimationAPI.#getEaseOptions);
      if (ease2 !== void 0 && typeof ease2 !== "function") {
        throw new TypeError(
          `AnimationAPI.quickTo.options error: 'ease' is not a function or valid Svelte easing function name.`
        );
      }
      if (duration2 >= 0) {
        animationData.duration = duration2 * 1e3;
      }
      if (ease2) {
        animationData.ease = ease2;
      }
      return quickToCB;
    };
    return quickToCB;
  }
}
class AnimationGroupControl {
  static {
    __name(this, "AnimationGroupControl");
  }
  /** @type {Set<import('./AnimationControl').AnimationControl>} */
  #animationControls;
  /** @type {Promise<import('#runtime/util/animate').BasicAnimationState>} */
  #finishedPromise;
  /**
   * Defines a static empty / void animation control.
   *
   * @type {AnimationGroupControl}
   */
  static #voidControl = new AnimationGroupControl(null);
  /**
   * Provides a static void / undefined AnimationGroupControl that is automatically resolved.
   *
   * @returns {AnimationGroupControl} Void AnimationGroupControl
   */
  static get voidControl() {
    return this.#voidControl;
  }
  /**
   * @param {Set<import('./AnimationControl').AnimationControl>} animationControls - An array of AnimationControl
   *        instances.
   */
  constructor(animationControls) {
    this.#animationControls = animationControls;
  }
  /**
   * Get a promise that resolves when all animations are finished.
   *
   * @returns {Promise<import('#runtime/util/animate').BasicAnimationState>} Finished Promise for all animations.
   */
  get finished() {
    const animationControls = this.#animationControls;
    if (!CrossWindow.isPromise(this.#finishedPromise)) {
      if (animationControls === null || animationControls === void 0 || animationControls.size === 0) {
        this.#finishedPromise = /** @type {Promise<import('#runtime/util/animate').BasicAnimationState>} */
        Promise.resolve({ cancelled: false });
      } else {
        const promises = [];
        for (const animationControl of animationControls) {
          promises.push(animationControl.finished);
        }
        this.#finishedPromise = Promise.allSettled(promises).then((results) => {
          const anyCancelled = results.some((result) => result.status === "rejected" || result.status === "fulfilled" && result.value.cancelled);
          return { cancelled: anyCancelled };
        });
      }
    }
    return this.#finishedPromise;
  }
  /**
   * Returns whether there are active animation instances for this group.
   *
   * Note: a delayed animation may not be started / active yet. Use {@link AnimationGroupControl.isFinished} to
   * determine if all animations in the group are finished.
   *
   * @returns {boolean} Are there active animation instances.
   */
  get isActive() {
    const animationControls = this.#animationControls;
    if (animationControls === null || animationControls === void 0 || animationControls.size === 0) {
      return false;
    }
    for (const animationControl of animationControls) {
      if (animationControl.isActive) {
        return true;
      }
    }
    return false;
  }
  /**
   * Returns whether all animations in the group are finished.
   *
   * @returns {boolean} Are all animation instances finished.
   */
  get isFinished() {
    const animationControls = this.#animationControls;
    if (animationControls === null || animationControls === void 0 || animationControls.size === 0) {
      return true;
    }
    for (const animationControl of animationControls) {
      if (!animationControl.isFinished) {
        return false;
      }
    }
    return true;
  }
  /**
   * Cancels the all animations.
   */
  cancel() {
    const animationControls = this.#animationControls;
    if (animationControls === null || animationControls === void 0 || animationControls.size === 0) {
      return;
    }
    for (const animationControl of animationControls) {
      animationControl.cancel();
    }
  }
}
class AnimationGroupAPI {
  static {
    __name(this, "AnimationGroupAPI");
  }
  /**
   * Returns the TJSPosition instance for the possible given positionable by checking the instance by checking for
   * AnimationAPI.
   *
   * @param {import('../').TJSPosition | import('../types').TJSPositionTypes.Positionable} positionable - Possible
   *        position group entry.
   *
   * @returns {import('../').TJSPosition | null} Returns actual TJSPosition instance.
   */
  static #getPosition(positionable) {
    if (!isObject(positionable)) {
      return null;
    }
    if (positionable.animate instanceof AnimationAPI) {
      return positionable;
    }
    if (positionable.position?.animate instanceof AnimationAPI) {
      return positionable.position;
    }
    return null;
  }
  /**
   * Cancels any animation for given PositionGroup data.
   *
   * @param {import('../types').TJSPositionTypes.PositionGroup} positionGroup - The position group to cancel.
   */
  static cancel(positionGroup) {
    if (isIterable(positionGroup)) {
      let index = -1;
      for (const entry of positionGroup) {
        index++;
        const actualPosition = this.#getPosition(entry);
        if (!actualPosition) {
          console.warn(`AnimationGroupAPI.cancel warning: No TJSPosition instance found at index: ${index}.`);
          continue;
        }
        AnimationManager.cancel(actualPosition);
      }
    } else {
      const actualPosition = this.#getPosition(positionGroup);
      if (!actualPosition) {
        console.warn(`AnimationGroupAPI.cancel warning: No TJSPosition instance found.`);
        return;
      }
      AnimationManager.cancel(actualPosition);
    }
  }
  /**
   * Cancels all TJSPosition animation.
   */
  static cancelAll() {
    AnimationManager.cancelAll();
  }
  /**
   * Gets all animation controls for the given position group data.
   *
   * @param {import('../types').TJSPositionTypes.PositionGroup} positionGroup - A position group.
   *
   * @returns {{
   *    position: import('../').TJSPosition,
   *    entry: import('../types').TJSPositionTypes.Positionable | undefined,
   *    controls: import('#runtime/util/animate').BasicAnimation[]
   * }[]} Results array.
   */
  static getScheduled(positionGroup) {
    const results = [];
    if (isIterable(positionGroup)) {
      let index = -1;
      for (const entry of positionGroup) {
        index++;
        const actualPosition = this.#getPosition(entry);
        if (!actualPosition) {
          console.warn(`AnimationGroupAPI.getScheduled warning: No TJSPosition instance found at index: ${index}.`);
          continue;
        }
        const controls = AnimationManager.getScheduled(actualPosition);
        results.push({ position: actualPosition, entry: actualPosition !== entry ? entry : void 0, controls });
      }
    } else {
      const actualPosition = this.#getPosition(positionGroup);
      if (!actualPosition) {
        console.warn(`AnimationGroupAPI.getScheduled warning: No TJSPosition instance found.`);
        return results;
      }
      const controls = AnimationManager.getScheduled(actualPosition);
      results.push({
        position: actualPosition,
        entry: actualPosition !== positionGroup ? positionGroup : void 0,
        controls
      });
    }
    return results;
  }
  /**
   * Provides a type guard to test in the given key is an {@link AnimationAPI.AnimationKey}.
   *
   * @param {unknown}  key - A key value to test.
   *
   * @returns {key is import('./types').AnimationAPI.AnimationKey} Whether the given key is an animation key.
   */
  static isAnimationKey(key) {
    return TJSPositionDataUtil.isAnimationKey(key);
  }
  /**
   * Returns the status _for the entire position group_ specified if all position instances of the group are scheduled.
   *
   * @param {import('../types').TJSPositionTypes.PositionGroup} positionGroup - A position group.
   *
   * @param {import('./types').AnimationAPI.ScheduleOptions} [options] - Options.
   *
   * @returns {boolean} True if all are scheduled / false if just one position instance in the group is not scheduled.
   */
  static isScheduled(positionGroup, options) {
    if (isIterable(positionGroup)) {
      let index = -1;
      for (const entry of positionGroup) {
        index++;
        const actualPosition = this.#getPosition(entry);
        if (!actualPosition) {
          console.warn(`AnimationGroupAPI.isScheduled warning: No TJSPosition instance found at index: ${index}.`);
          continue;
        }
        if (!AnimationManager.isScheduled(actualPosition, options)) {
          return false;
        }
      }
    } else {
      const actualPosition = this.#getPosition(positionGroup);
      if (!actualPosition) {
        console.warn(`AnimationGroupAPI.isScheduled warning: No TJSPosition instance found.`);
        return false;
      }
      if (!AnimationManager.isScheduled(actualPosition, options)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Provides the `from` animation tween for one or more positionable instances as a group.
   *
   * @param {import('../types').TJSPositionTypes.PositionGroup} positionGroup - A position group.
   *
   * @param {(
   *    import('../data/types').Data.TJSPositionDataRelative |
   *    import('./types').AnimationAPI.GroupDataCallback
   * )} fromData - A position data object assigned to all positionable instances or a callback function invoked for
   *        unique data for each instance.
   *
   * @param {(
   *    import('./types').AnimationAPI.TweenOptions |
   *    import('./types').AnimationAPI.GroupTweenOptionsCallback
   * )} [options] - Tween options assigned to all positionable instances or a callback function invoked for unique
   *        options for each instance.
   *
   * @returns {import('#runtime/util/animate').BasicAnimation} Basic animation control.
   */
  static from(positionGroup, fromData, options) {
    if (!isObject(fromData) && typeof fromData !== "function") {
      throw new TypeError(`AnimationGroupAPI.from error: 'fromData' is not an object or function.`);
    }
    if (options !== void 0 && !isObject(options) && typeof options !== "function") {
      throw new TypeError(`AnimationGroupAPI.from error: 'options' is not an object or function.`);
    }
    const animationControls = /* @__PURE__ */ new Set();
    const cleanupFn = /* @__PURE__ */ __name((data) => animationControls.delete(data.control), "cleanupFn");
    let index = -1;
    let callbackOptions;
    const hasDataCallback = typeof fromData === "function";
    const hasOptionCallback = typeof options === "function";
    const hasCallback = hasDataCallback || hasOptionCallback;
    if (hasCallback) {
      callbackOptions = { index, position: void 0, entry: void 0 };
    }
    let actualFromData = fromData;
    let actualOptions = options;
    if (isIterable(positionGroup)) {
      for (const entry of positionGroup) {
        index++;
        const actualPosition = this.#getPosition(entry);
        if (!actualPosition) {
          console.warn(`AnimationGroupAPI.from warning: No TJSPosition instance found at index: ${index}.`);
          continue;
        }
        if (hasCallback) {
          callbackOptions.index = index;
          callbackOptions.position = actualPosition;
          callbackOptions.entry = actualPosition !== entry ? entry : void 0;
        }
        if (hasDataCallback) {
          actualFromData = fromData(callbackOptions);
          if (actualFromData === null || actualFromData === void 0) {
            continue;
          }
          if (!isObject(actualFromData)) {
            throw new TypeError(`AnimationGroupAPI.from error: 'fromData' callback function iteration(${index}) failed to return an object.`);
          }
        }
        if (hasOptionCallback) {
          actualOptions = options(callbackOptions);
          if (actualOptions === null || actualOptions === void 0) {
            continue;
          }
          if (!isObject(actualOptions)) {
            throw new TypeError(`AnimationGroupAPI.from error: 'options' callback function iteration(${index}) failed to return an object.`);
          }
        }
        const animationControl = AnimationScheduler.from(actualPosition, actualFromData, actualOptions, cleanupFn);
        if (animationControl) {
          animationControls.add(animationControl);
        }
      }
    } else {
      const actualPosition = this.#getPosition(positionGroup);
      if (!actualPosition) {
        console.warn(`AnimationGroupAPI.from warning: No TJSPosition instance found.`);
        return AnimationGroupControl.voidControl;
      }
      if (hasCallback) {
        callbackOptions.index = 0;
        callbackOptions.position = actualPosition;
        callbackOptions.entry = actualPosition !== positionGroup ? positionGroup : void 0;
      }
      if (hasDataCallback) {
        actualFromData = fromData(callbackOptions);
        if (actualFromData === null || actualFromData === void 0) {
          return AnimationGroupControl.voidControl;
        }
        if (!isObject(actualFromData)) {
          throw new TypeError(
            `AnimationGroupAPI.from error: 'fromData' callback function failed to return an object.`
          );
        }
      }
      if (hasOptionCallback) {
        actualOptions = options(callbackOptions);
        if (actualOptions === null || actualOptions === void 0) {
          return AnimationGroupControl.voidControl;
        }
        if (!isObject(actualOptions)) {
          throw new TypeError(
            `AnimationGroupAPI.from error: 'options' callback function failed to return an object.`
          );
        }
      }
      const animationControl = AnimationScheduler.from(actualPosition, actualFromData, actualOptions, cleanupFn);
      if (animationControl) {
        animationControls.add(animationControl);
      }
    }
    return new AnimationGroupControl(animationControls);
  }
  /**
   * Provides the `fromTo` animation tween for one or more positionable instances as a group.
   *
   * @param {import('../types').TJSPositionTypes.PositionGroup} positionGroup - A position group.
   *
   * @param {(
   *    import('../data/types').Data.TJSPositionDataRelative |
   *    import('./types').AnimationAPI.GroupDataCallback
   * )} fromData - A position data object assigned to all positionable instances or a callback function invoked for
   *        unique data for each instance.
   *
   * @param {(
   *    import('../data/types').Data.TJSPositionDataRelative |
   *    import('./types').AnimationAPI.GroupDataCallback
   * )} toData - A position data object assigned to all positionable instances or a callback function invoked for
   *        unique data for each instance.
   *
   * @param {(
   *    import('./types').AnimationAPI.TweenOptions |
   *    import('./types').AnimationAPI.GroupTweenOptionsCallback
   * )} [options] - Tween options assigned to all positionable instances or a callback function invoked for unique
   *        options for each instance.
   *
   * @returns {import('#runtime/util/animate').BasicAnimation} Basic animation control.
   */
  static fromTo(positionGroup, fromData, toData, options) {
    if (!isObject(fromData) && typeof fromData !== "function") {
      throw new TypeError(`AnimationGroupAPI.fromTo error: 'fromData' is not an object or function.`);
    }
    if (!isObject(toData) && typeof toData !== "function") {
      throw new TypeError(`AnimationGroupAPI.fromTo error: 'toData' is not an object or function.`);
    }
    if (options !== void 0 && !isObject(options) && typeof options !== "function") {
      throw new TypeError(`AnimationGroupAPI.fromTo error: 'options' is not an object or function.`);
    }
    const animationControls = /* @__PURE__ */ new Set();
    const cleanupFn = /* @__PURE__ */ __name((data) => animationControls.delete(data.control), "cleanupFn");
    let index = -1;
    let callbackOptions;
    const hasFromCallback = typeof fromData === "function";
    const hasToCallback = typeof toData === "function";
    const hasOptionCallback = typeof options === "function";
    const hasCallback = hasFromCallback || hasToCallback || hasOptionCallback;
    if (hasCallback) {
      callbackOptions = { index, position: void 0, entry: void 0 };
    }
    let actualFromData = fromData;
    let actualToData = toData;
    let actualOptions = options;
    if (isIterable(positionGroup)) {
      for (const entry of positionGroup) {
        index++;
        const actualPosition = this.#getPosition(entry);
        if (!actualPosition) {
          console.warn(`AnimationGroupAPI.fromTo warning: No TJSPosition instance found at index: ${index}.`);
          continue;
        }
        if (hasCallback) {
          callbackOptions.index = index;
          callbackOptions.position = actualPosition;
          callbackOptions.entry = actualPosition !== entry ? entry : void 0;
        }
        if (hasFromCallback) {
          actualFromData = fromData(callbackOptions);
          if (actualFromData === null || actualFromData === void 0) {
            continue;
          }
          if (!isObject(actualFromData)) {
            throw new TypeError(`AnimationGroupAPI.fromTo error: 'fromData' callback function iteration(${index}) failed to return an object.`);
          }
        }
        if (hasToCallback) {
          actualToData = toData(callbackOptions);
          if (actualToData === null || actualToData === void 0) {
            continue;
          }
          if (!isObject(actualToData)) {
            throw new TypeError(`AnimationGroupAPI.fromTo error: 'toData' callback function iteration(${index}) failed to return an object.`);
          }
        }
        if (hasOptionCallback) {
          actualOptions = options(callbackOptions);
          if (actualOptions === null || actualOptions === void 0) {
            continue;
          }
          if (!isObject(actualOptions)) {
            throw new TypeError(`AnimationGroupAPI.fromTo error: 'options' callback function iteration(${index}) failed to return an object.`);
          }
        }
        const animationControl = AnimationScheduler.fromTo(
          actualPosition,
          actualFromData,
          actualToData,
          actualOptions,
          cleanupFn
        );
        if (animationControl) {
          animationControls.add(animationControl);
        }
      }
    } else {
      const actualPosition = this.#getPosition(positionGroup);
      if (!actualPosition) {
        console.warn(`AnimationGroupAPI.fromTo warning: No TJSPosition instance found.`);
        return AnimationGroupControl.voidControl;
      }
      if (hasCallback) {
        callbackOptions.index = 0;
        callbackOptions.position = actualPosition;
        callbackOptions.entry = actualPosition !== positionGroup ? positionGroup : void 0;
      }
      if (hasFromCallback) {
        actualFromData = fromData(callbackOptions);
        if (actualFromData === null || actualFromData === void 0) {
          return AnimationGroupControl.voidControl;
        }
        if (!isObject(actualFromData)) {
          throw new TypeError(
            `AnimationGroupAPI.fromTo error: 'fromData' callback function failed to return an object.`
          );
        }
      }
      if (hasToCallback) {
        actualToData = toData(callbackOptions);
        if (actualToData === null || actualToData === void 0) {
          return AnimationGroupControl.voidControl;
        }
        if (!isObject(actualToData)) {
          throw new TypeError(
            `AnimationGroupAPI.fromTo error: 'toData' callback function failed to return an object.`
          );
        }
      }
      if (hasOptionCallback) {
        actualOptions = options(callbackOptions);
        if (actualOptions === null || actualOptions === void 0) {
          return AnimationGroupControl.voidControl;
        }
        if (!isObject(actualOptions)) {
          throw new TypeError(
            `AnimationGroupAPI.fromTo error: 'options' callback function failed to return an object.`
          );
        }
      }
      const animationControl = AnimationScheduler.fromTo(
        actualPosition,
        actualFromData,
        actualToData,
        actualOptions,
        cleanupFn
      );
      if (animationControl) {
        animationControls.add(animationControl);
      }
    }
    return new AnimationGroupControl(animationControls);
  }
  /**
   * Provides the `to` animation tween for one or more positionable instances as a group.
   *
   * @param {import('../types').TJSPositionTypes.PositionGroup} positionGroup - A position group.
   *
   * @param {(
   *    import('../data/types').Data.TJSPositionDataRelative |
   *    import('./types').AnimationAPI.GroupDataCallback
   * )} toData - A position data object assigned to all positionable instances or a callback function invoked for
   *        unique data for each instance.
   *
   * @param {(
   *    import('./types').AnimationAPI.TweenOptions |
   *    import('./types').AnimationAPI.GroupTweenOptionsCallback
   * )} [options] - Tween options assigned to all positionable instances or a callback function invoked for unique
   *        options for each instance.
   *
   * @returns {import('#runtime/util/animate').BasicAnimation} Basic animation control.
   */
  static to(positionGroup, toData, options) {
    if (!isObject(toData) && typeof toData !== "function") {
      throw new TypeError(`AnimationGroupAPI.to error: 'toData' is not an object or function.`);
    }
    if (options !== void 0 && !isObject(options) && typeof options !== "function") {
      throw new TypeError(`AnimationGroupAPI.to error: 'options' is not an object or function.`);
    }
    const animationControls = /* @__PURE__ */ new Set();
    const cleanupFn = /* @__PURE__ */ __name((data) => animationControls.delete(data.control), "cleanupFn");
    let index = -1;
    let callbackOptions;
    const hasDataCallback = typeof toData === "function";
    const hasOptionCallback = typeof options === "function";
    const hasCallback = hasDataCallback || hasOptionCallback;
    if (hasCallback) {
      callbackOptions = { index, position: void 0, entry: void 0 };
    }
    let actualToData = toData;
    let actualOptions = options;
    if (isIterable(positionGroup)) {
      for (const entry of positionGroup) {
        index++;
        const actualPosition = this.#getPosition(entry);
        if (!actualPosition) {
          console.warn(`AnimationGroupAPI.to warning: No TJSPosition instance found at index: ${index}.`);
          continue;
        }
        if (hasCallback) {
          callbackOptions.index = index;
          callbackOptions.position = actualPosition;
          callbackOptions.entry = actualPosition !== entry ? entry : void 0;
        }
        if (hasDataCallback) {
          actualToData = toData(callbackOptions);
          if (actualToData === null || actualToData === void 0) {
            continue;
          }
          if (!isObject(actualToData)) {
            throw new TypeError(`AnimationGroupAPI.to error: 'toData' callback function iteration(${index}) failed to return an object.`);
          }
        }
        if (hasOptionCallback) {
          actualOptions = options(callbackOptions);
          if (actualOptions === null || actualOptions === void 0) {
            continue;
          }
          if (!isObject(actualOptions)) {
            throw new TypeError(`AnimationGroupAPI.to error: 'options' callback function iteration(${index}) failed to return an object.`);
          }
        }
        const animationControl = AnimationScheduler.to(actualPosition, actualToData, actualOptions, cleanupFn);
        if (animationControl) {
          animationControls.add(animationControl);
        }
      }
    } else {
      const actualPosition = this.#getPosition(positionGroup);
      if (!actualPosition) {
        console.warn(`AnimationGroupAPI.to warning: No TJSPosition instance found.`);
        return AnimationGroupControl.voidControl;
      }
      if (hasCallback) {
        callbackOptions.index = 0;
        callbackOptions.position = actualPosition;
        callbackOptions.entry = actualPosition !== positionGroup ? positionGroup : void 0;
      }
      if (hasDataCallback) {
        actualToData = toData(callbackOptions);
        if (actualToData === null || actualToData === void 0) {
          return AnimationGroupControl.voidControl;
        }
        if (!isObject(actualToData)) {
          throw new TypeError(
            `AnimationGroupAPI.to error: 'toData' callback function failed to return an object.`
          );
        }
      }
      if (hasOptionCallback) {
        actualOptions = options(callbackOptions);
        if (actualOptions === null || actualOptions === void 0) {
          return AnimationGroupControl.voidControl;
        }
        if (!isObject(actualOptions)) {
          throw new TypeError(
            `AnimationGroupAPI.to error: 'options' callback function failed to return an object.`
          );
        }
      }
      const animationControl = AnimationScheduler.to(actualPosition, actualToData, actualOptions, cleanupFn);
      if (animationControl) {
        animationControls.add(animationControl);
      }
    }
    return new AnimationGroupControl(animationControls);
  }
  /**
   * Provides the `quickTo` animation tweening function for one or more positionable instances as a group.
   *
   * @param {import('../types').TJSPositionTypes.PositionGroup} positionGroup - A position group.
   *
   * @param {Iterable<import('./types').AnimationAPI.AnimationKey>}  keys - Animation keys to target.
   *
   * @param {(
   *    import('./types').AnimationAPI.QuickTweenOptions |
   *    import('./types').AnimationAPI.GroupQuickTweenOptionsCallback
   * )} [options] - Quick tween options assigned to all positionable instances or a callback function invoked for
   *        unique options for each instance.
   *
   * @returns {import('./types').AnimationAPI.GroupQuickToCallback | undefined} quick-to tween function.
   */
  static quickTo(positionGroup, keys, options) {
    if (!isIterable(keys)) {
      throw new TypeError(`AnimationGroupAPI.quickTo error: 'keys' is not an iterable list.`);
    }
    if (options !== void 0 && !isObject(options) && typeof options !== "function") {
      throw new TypeError(`AnimationGroupAPI.quickTo error: 'options' is not an object or function.`);
    }
    const quickToCallbacks = [];
    let index = -1;
    const hasOptionCallback = typeof options === "function";
    const callbackOptions = { index, position: void 0, entry: void 0 };
    let actualOptions = isObject(options) ? options : void 0;
    if (isIterable(positionGroup)) {
      for (const entry of positionGroup) {
        index++;
        const actualPosition = this.#getPosition(entry);
        if (!actualPosition) {
          console.warn(`AnimationGroupAPI.quickTo warning: No TJSPosition instance found at index: ${index}.`);
          continue;
        }
        callbackOptions.index = index;
        callbackOptions.position = actualPosition;
        callbackOptions.entry = actualPosition !== entry ? entry : void 0;
        if (hasOptionCallback) {
          actualOptions = options(callbackOptions);
          if (actualOptions === null || actualOptions === void 0) {
            continue;
          }
          if (!isObject(actualOptions)) {
            throw new TypeError(`AnimationGroupAPI.quickTo error: 'options' callback function iteration(${index}) failed to return an object.`);
          }
        }
        quickToCallbacks.push(actualPosition.animate.quickTo(keys, actualOptions));
      }
    } else {
      const actualPosition = this.#getPosition(positionGroup);
      if (!actualPosition) {
        console.warn(`AnimationGroupAPI.quickTo warning: No TJSPosition instance found.`);
        return;
      }
      callbackOptions.index = 0;
      callbackOptions.position = actualPosition;
      callbackOptions.entry = actualPosition !== positionGroup ? positionGroup : void 0;
      if (hasOptionCallback) {
        actualOptions = options(callbackOptions);
        if (actualOptions === null || actualOptions === void 0) {
          return;
        }
        if (!isObject(actualOptions)) {
          throw new TypeError(
            `AnimationGroupAPI.quickTo error: 'options' callback function failed to return an object.`
          );
        }
      }
      quickToCallbacks.push(actualPosition.animate.quickTo(keys, actualOptions));
    }
    const keysArray = [...keys];
    Object.freeze(keysArray);
    const quickToCB = /* @__PURE__ */ __name((...args) => {
      const argsLength = args.length;
      if (argsLength === 0) {
        return;
      }
      if (typeof args[0] === "function") {
        const dataCallback = args[0];
        index = -1;
        let cntr = 0;
        if (isIterable(positionGroup)) {
          for (const entry of positionGroup) {
            index++;
            const actualPosition = this.#getPosition(entry);
            if (!actualPosition) {
              continue;
            }
            callbackOptions.index = index;
            callbackOptions.position = actualPosition;
            callbackOptions.entry = actualPosition !== entry ? entry : void 0;
            const toData = dataCallback(callbackOptions);
            if (toData === null || toData === void 0) {
              continue;
            }
            const toDataIterable = isIterable(toData);
            if (!Number.isFinite(toData) && !toDataIterable && !isObject(toData)) {
              throw new TypeError(`AnimationGroupAPI.quickTo error: 'toData' callback function iteration(${index}) failed to return a finite number, iterable list, or object.`);
            }
            if (toDataIterable) {
              quickToCallbacks[cntr++](...toData);
            } else {
              quickToCallbacks[cntr++](toData);
            }
          }
        } else {
          const actualPosition = this.#getPosition(positionGroup);
          if (!actualPosition) {
            return;
          }
          callbackOptions.index = 0;
          callbackOptions.position = actualPosition;
          callbackOptions.entry = actualPosition !== positionGroup ? positionGroup : void 0;
          const toData = dataCallback(callbackOptions);
          if (toData === null || toData === void 0) {
            return;
          }
          const toDataIterable = isIterable(toData);
          if (!Number.isFinite(toData) && !toDataIterable && !isObject(toData)) {
            throw new TypeError(`AnimationGroupAPI.quickTo error: 'toData' callback function iteration(${index}) failed to return a finite number, iterable list, or object.`);
          }
          if (toDataIterable) {
            quickToCallbacks[cntr++](...toData);
          } else {
            quickToCallbacks[cntr++](toData);
          }
        }
      } else {
        for (let cntr = quickToCallbacks.length; --cntr >= 0; ) {
          quickToCallbacks[cntr](...args);
        }
      }
    }, "quickToCB");
    quickToCB.keys = keysArray;
    quickToCB.options = (options2) => {
      if (options2 !== void 0 && !isObject(options2)) {
        throw new TypeError(`AnimationGroupAPI.quickTo error: 'options' is not an object.`);
      }
      if (isObject(options2)) {
        for (let cntr = quickToCallbacks.length; --cntr >= 0; ) {
          quickToCallbacks[cntr].options(options2);
        }
      }
      return quickToCB;
    };
    return quickToCB;
  }
}
Object.seal(AnimationGroupAPI);
class PositionStateAPI {
  static {
    __name(this, "PositionStateAPI");
  }
  /** @type {import('../data/types').Data.TJSPositionData} */
  #data;
  /**
   * @type {Map<string, import('../data/types').Data.TJSPositionDataExtra>}
   */
  #dataSaved = /* @__PURE__ */ new Map();
  /** @type {import('../').TJSPosition} */
  #position;
  /** @type {import('../transform').TJSTransforms} */
  #transforms;
  constructor(position, data, transforms) {
    this.#position = position;
    this.#data = data;
    this.#transforms = transforms;
    Object.seal(this);
  }
  /**
   * Clears all saved position data except any default state.
   */
  clear() {
    for (const key of this.#dataSaved.keys()) {
      if (key !== "#defaultData") {
        this.#dataSaved.delete(key);
      }
    }
  }
  /**
   * Returns any stored save state by name.
   *
   * @param {object}   options - Options.
   *
   * @param {string}   options.name - Saved data name.
   *
   * @returns {import('../data/types').Data.TJSPositionDataExtra | undefined} Any saved position data.
   */
  get({ name }) {
    if (typeof name !== "string") {
      throw new TypeError(`TJSPosition - get error: 'name' is not a string.`);
    }
    return this.#dataSaved.get(name);
  }
  /**
   * Returns any associated default position data.
   *
   * @returns {import('../data/types').Data.TJSPositionDataExtra | undefined} Any saved default position data.
   */
  getDefault() {
    return this.#dataSaved.get("#defaultData");
  }
  /**
   * @returns {IterableIterator<string>} The saved position data names / keys.
   */
  keys() {
    return this.#dataSaved.keys();
  }
  /**
   * Removes and returns any position data by name.
   *
   * @param {object}   options - Options.
   *
   * @param {string}   options.name - Name to remove and retrieve.
   *
   * @returns {import('../data/types').Data.TJSPositionDataExtra | undefined} Any saved position data.
   */
  remove({ name }) {
    if (typeof name !== "string") {
      throw new TypeError(`TJSPosition - remove: 'name' is not a string.`);
    }
    const data = this.#dataSaved.get(name);
    this.#dataSaved.delete(name);
    return data;
  }
  /**
   * Resets position instance to default data and invokes set.
   *
   * @param {object}   [options] - Optional parameters.
   *
   * @param {boolean}  [options.keepZIndex=false] - When true keeps current z-index.
   *
   * @param {boolean}  [options.invokeSet=true] - When true invokes set method.
   *
   * @returns {boolean} Operation successful.
   */
  reset({ keepZIndex = false, invokeSet = true } = {}) {
    const defaultData = this.#dataSaved.get("#defaultData");
    if (!isObject(defaultData)) {
      return false;
    }
    if (this.#position.animate.isScheduled) {
      this.#position.animate.cancel();
    }
    const zIndex = this.#position.zIndex;
    const data = Object.assign({}, defaultData);
    if (keepZIndex) {
      data.zIndex = zIndex;
    }
    this.#transforms.reset(data);
    if (this.#position.parent?.reactive?.minimized) {
      this.#position.parent?.maximize?.({ animate: false, duration: 0 });
    }
    if (invokeSet) {
      setTimeout(() => this.#position.set(data), 0);
    }
    return true;
  }
  /**
   * Restores a saved positional state returning the data. Several optional parameters are available to control
   * whether the restore action occurs silently (no store / inline styles updates), animates to the stored data, or
   * simply sets the stored data. Restoring via {@link AnimationAPI.to} allows specification of the duration and
   * easing along with configuring a Promise to be returned if awaiting the end of the animation.
   *
   * @param {object}            options - Parameters
   *
   * @param {string}            options.name - Saved data set name.
   *
   * @param {boolean}           [options.remove=false] - Deletes data set.
   *
   * @param {Iterable<string>}  [options.properties] - Specific properties to set / animate.
   *
   * @param {boolean}           [options.silent] - Set position data directly; no store or style updates.
   *
   * @param {boolean}           [options.async=false] - If animating return a Promise that resolves with any saved
   *        data.
   *
   * @param {boolean}           [options.animateTo=false] - Animate to restore data.
   *
   * @param {number}            [options.duration=0.1] - Duration in seconds.
   *
   * @param {import('#runtime/svelte/easing').EasingReference} [options.ease='linear'] - Easing function name or
   *        function.
   *
   * @returns {(
   *    import('../data/types').Data.TJSPositionDataExtra |
   *    Promise<import('../data/types').Data.TJSPositionDataExtra | undefined> |
   *    undefined
   * )} Any saved position data.
   */
  restore({
    name,
    remove = false,
    properties,
    silent = false,
    async = false,
    animateTo = false,
    duration = 0.1,
    ease = "linear"
  }) {
    if (typeof name !== "string") {
      throw new TypeError(`TJSPosition - restore error: 'name' is not a string.`);
    }
    const dataSaved = this.#dataSaved.get(name);
    if (dataSaved) {
      if (remove) {
        this.#dataSaved.delete(name);
      }
      let data = dataSaved;
      if (isIterable(properties)) {
        data = {};
        for (const property of properties) {
          data[property] = dataSaved[property];
        }
      }
      if (silent) {
        for (const property in data) {
          this.#data[property] = data[property];
        }
        return dataSaved;
      } else if (animateTo) {
        if (data.transformOrigin !== this.#position.transformOrigin) {
          this.#position.transformOrigin = data.transformOrigin;
        }
        if (async) {
          return this.#position.animate.to(data, { duration, ease }).finished.then(() => dataSaved);
        } else {
          this.#position.animate.to(data, { duration, ease });
        }
      } else {
        this.#position.set(data);
      }
    }
    return async ? Promise.resolve(dataSaved) : dataSaved;
  }
  /**
   * Saves current position state with the opportunity to add extra data to the saved state. Simply include
   * extra properties in `options` to save extra data.
   *
   * @param {object}   options - Options.
   *
   * @param {string}   options.name - name to index this saved data.
   *
   * @param {import('../types').TJSPositionTypes.OptionsGet} [optionsGet] - Additional options for
   *        {@link TJSPosition.get} when serializing position state. By default, `nullable` values are included.
   *
   * @returns {import('../data/types').Data.TJSPositionDataExtra} Current position data plus any extra data stored.
   */
  save({ name, ...extra }, optionsGet) {
    if (typeof name !== "string") {
      throw new TypeError(`TJSPosition - save error: 'name' is not a string.`);
    }
    const data = this.#position.get(extra, optionsGet);
    this.#dataSaved.set(name, data);
    return data;
  }
  /**
   * Directly sets a saved position state. Simply include extra properties in `options` to set extra data.
   *
   * @param {object}   opts - Options.
   *
   * @param {string}   opts.name - name to index this saved data.
   */
  set({ name, ...data }) {
    if (typeof name !== "string") {
      throw new TypeError(`TJSPosition - set error: 'name' is not a string.`);
    }
    this.#dataSaved.set(name, data);
  }
}
class SystemBase {
  static {
    __name(this, "SystemBase");
  }
  /**
   * When true constrains the min / max width or height to element.
   *
   * @type {boolean}
   */
  #constrain;
  /**
   * @type {HTMLElement}
   */
  #element;
  /**
   * When true the validator is active.
   *
   * @type {boolean}
   */
  #enabled;
  /**
   * Provides a manual setting of the element height. As things go `offsetHeight` causes a browser layout and is not
   * performance oriented. If manually set this height is used instead of `offsetHeight`.
   *
   * @type {number}
   */
  #height;
  /**
   * Set from an optional value in the constructor to lock accessors preventing modification.
   */
  #lock;
  /**
   * Stores the subscribers.
   *
   * @type {import('svelte/store').Subscriber<SystemBase>[]}
   */
  #subscribers = [];
  /**
   * Provides a manual setting of the element width. As things go `offsetWidth` causes a browser layout and is not
   * performance oriented. If manually set this width is used instead of `offsetWidth`.
   *
   * @type {number}
   */
  #width;
  /**
   * @param {object}      [options] - Initial options.
   *
   * @param {boolean}     [options.constrain=true] - Initial constrained state.
   *
   * @param {HTMLElement} [options.element] - Target element.
   *
   * @param {boolean}     [options.enabled=true] - Enabled state.
   *
   * @param {boolean}     [options.lock=false] - Lock parameters from being set.
   *
   * @param {number}      [options.width] - Manual width.
   *
   * @param {number}      [options.height] - Manual height.
   */
  constructor({ constrain = true, element: element2, enabled = true, lock = false, width, height } = {}) {
    this.constrain = constrain;
    this.element = element2;
    this.enabled = enabled;
    this.width = width;
    this.height = height;
    this.#lock = typeof lock === "boolean" ? lock : false;
  }
  /**
   * @returns {boolean} The current constrain state.
   */
  get constrain() {
    return this.#constrain;
  }
  /**
   * @returns {HTMLElement | undefined | null} Target element.
   */
  get element() {
    return this.#element;
  }
  /**
   * @returns {boolean} The current enabled state.
   */
  get enabled() {
    return this.#enabled;
  }
  /**
   * @returns {number} Get manual height.
   */
  get height() {
    return this.#height;
  }
  /**
   * @return {boolean} Get locked state.
   */
  get locked() {
    return this.#lock;
  }
  /**
   * @returns {number} Get manual width.
   */
  get width() {
    return this.#width;
  }
  /**
   * @param {boolean}  constrain - New constrain state.
   */
  set constrain(constrain) {
    if (this.#lock) {
      return;
    }
    if (typeof constrain !== "boolean") {
      throw new TypeError(`'constrain' is not a boolean.`);
    }
    this.#constrain = constrain;
    this.#updateSubscribers();
  }
  /**
   * @param {HTMLElement | undefined | null} element - Set target element.
   */
  set element(element2) {
    if (this.#lock) {
      return;
    }
    if (element2 === void 0 || element2 === null || A11yHelper.isFocusTarget(element2)) {
      this.#element = element2;
    } else {
      throw new TypeError(`'element' is not a HTMLElement, undefined, or null.`);
    }
    this.#updateSubscribers();
  }
  /**
   * @param {boolean}  enabled - New enabled state.
   */
  set enabled(enabled) {
    if (this.#lock) {
      return;
    }
    if (typeof enabled !== "boolean") {
      throw new TypeError(`'enabled' is not a boolean.`);
    }
    this.#enabled = enabled;
    this.#updateSubscribers();
  }
  /**
   * @param {number}   height - Set manual height.
   */
  set height(height) {
    if (this.#lock) {
      return;
    }
    if (height === void 0 || Number.isFinite(height)) {
      this.#height = height;
    } else {
      throw new TypeError(`'height' is not a finite number or undefined.`);
    }
    this.#updateSubscribers();
  }
  /**
   * @param {number}   width - Set manual width.
   */
  set width(width) {
    if (this.#lock) {
      return;
    }
    if (width === void 0 || Number.isFinite(width)) {
      this.#width = width;
    } else {
      throw new TypeError(`'width' is not a finite number or undefined.`);
    }
    this.#updateSubscribers();
  }
  /**
   * Set manual width & height.
   *
   * @param {number}   width - New manual width.
   *
   * @param {number}   height - New manual height.
   */
  setDimension(width, height) {
    if (this.#lock) {
      return;
    }
    if (width === void 0 || Number.isFinite(width)) {
      this.#width = width;
    } else {
      throw new TypeError(`'width' is not a finite number or undefined.`);
    }
    if (height === void 0 || Number.isFinite(height)) {
      this.#height = height;
    } else {
      throw new TypeError(`'height' is not a finite number or undefined.`);
    }
    this.#updateSubscribers();
  }
  /**
   * @param {import('svelte/store').Subscriber<SystemBase>} handler - Callback
   *        function that is invoked on update / changes. Receives a copy of the TJSPositionData.
   *
   * @returns {import('svelte/store').Unsubscriber} Unsubscribe function.
   */
  subscribe(handler) {
    this.#subscribers.push(handler);
    handler(this);
    return () => {
      const index = this.#subscribers.findIndex((sub) => sub === handler);
      if (index >= 0) {
        this.#subscribers.splice(index, 1);
      }
    };
  }
  /**
   * Updates subscribers on changes.
   */
  #updateSubscribers() {
    for (let cntr = 0; cntr < this.#subscribers.length; cntr++) {
      this.#subscribers[cntr](this);
    }
  }
}
class Centered extends SystemBase {
  static {
    __name(this, "Centered");
  }
  /**
   * Get the left constraint based on any manual target values or the browser inner width.
   *
   * @param {number}   width - Target width.
   *
   * @returns {number} Calculated left constraint.
   */
  getLeft(width) {
    const boundsWidth = this.width ?? this.element?.offsetWidth ?? globalThis.innerWidth;
    return (boundsWidth - width) / 2;
  }
  /**
   * Get the top constraint based on any manual target values or the browser inner height.
   *
   * @param {number}   height - Target height.
   *
   * @returns {number} Calculated top constraint.
   */
  getTop(height) {
    const boundsHeight = this.height ?? this.element?.offsetHeight ?? globalThis.innerHeight;
    return (boundsHeight - height) / 2;
  }
}
class AdapterValidators {
  static {
    __name(this, "AdapterValidators");
  }
  /** @type {boolean} */
  #enabled = true;
  /**
   * @type {import('./types').ValidatorAPI.ValidatorData[]}
   */
  #validatorData;
  /**
   * @type {Map<import('./types').ValidatorAPI.ValidationFn, import('svelte/store').Unsubscriber>}
   */
  #mapUnsubscribe = /* @__PURE__ */ new Map();
  #updateFn;
  /**
   * @returns {[AdapterValidators, import('./types').ValidatorAPI.ValidatorData[]]} Returns this and internal storage
   * for validator adapter.
   */
  static create(updateFn) {
    const validatorAPI = new AdapterValidators();
    validatorAPI.#updateFn = updateFn;
    return [validatorAPI, validatorAPI.#validatorData];
  }
  /**
   */
  constructor() {
    this.#validatorData = [];
    Object.seal(this);
  }
  /**
   * @returns {boolean} Returns the enabled state.
   */
  get enabled() {
    return this.#enabled;
  }
  /**
   * @returns {number} Returns the length of the validators array.
   */
  get length() {
    return this.#validatorData.length;
  }
  /**
   * @param {boolean}  enabled - Sets enabled state.
   */
  set enabled(enabled) {
    if (typeof enabled !== "boolean") {
      throw new TypeError(`'enabled' is not a boolean.`);
    }
    this.#enabled = enabled;
  }
  /**
   * Provides an iterator for validators.
   *
   * @yields {import('./types').ValidatorAPI.ValidatorData}
   * @returns {IterableIterator<import('./types').ValidatorAPI.ValidatorData>} iterator.
   */
  *[Symbol.iterator]() {
    if (this.#validatorData.length === 0) {
      return;
    }
    for (const entry of this.#validatorData) {
      yield { ...entry };
    }
  }
  /**
   * Adds the given validators.
   *
   * @param {...(
   *    import('./types').ValidatorAPI.ValidatorFn |
   *    import('./types').ValidatorAPI.ValidatorData
   * )}   validators - Validators to add.
   */
  add(...validators) {
    let subscribeCount = 0;
    for (const validator of validators) {
      const validatorType = typeof validator;
      if (validatorType !== "function" && validatorType !== "object" || validator === null) {
        throw new TypeError(`AdapterValidator error: 'validator' is not a function or object.`);
      }
      let data = void 0;
      let subscribeFn = void 0;
      switch (validatorType) {
        case "function":
          data = {
            id: void 0,
            validate: validator,
            weight: 1
          };
          subscribeFn = validator.subscribe;
          break;
        case "object":
          if (typeof validator.validate !== "function") {
            throw new TypeError(`AdapterValidator error: 'validate' attribute is not a function.`);
          }
          if (validator.weight !== void 0 && typeof validator.weight !== "number" || (validator.weight < 0 || validator.weight > 1)) {
            throw new TypeError(
              `AdapterValidator error: 'weight' attribute is not a number between '0 - 1' inclusive.`
            );
          }
          data = {
            id: validator.id !== void 0 ? validator.id : void 0,
            validate: validator.validate.bind(validator),
            weight: validator.weight || 1
          };
          subscribeFn = validator.validate.subscribe ?? validator.subscribe;
          break;
      }
      const index = this.#validatorData.findIndex((value) => {
        return data.weight < value.weight;
      });
      if (index >= 0) {
        this.#validatorData.splice(index, 0, data);
      } else {
        this.#validatorData.push(data);
      }
      if (typeof subscribeFn === "function") {
        const unsubscribe = subscribeFn.call(validator, this.#updateFn);
        if (typeof unsubscribe !== "function") {
          throw new TypeError(
            "AdapterValidator error: Validator has subscribe function, but no unsubscribe function is returned."
          );
        }
        if (this.#mapUnsubscribe.has(data.validate)) {
          throw new Error(
            "AdapterValidator error: Validator added already has an unsubscribe function registered."
          );
        }
        this.#mapUnsubscribe.set(data.validate, unsubscribe);
        subscribeCount++;
      }
    }
    if (subscribeCount < validators.length) {
      this.#updateFn();
    }
  }
  /**
   * Clears / removes all validators.
   */
  clear() {
    this.#validatorData.length = 0;
    for (const unsubscribe of this.#mapUnsubscribe.values()) {
      unsubscribe();
    }
    this.#mapUnsubscribe.clear();
    this.#updateFn();
  }
  /**
   * Removes one or more given validators.
   *
   * @param {...(
   *    import('./types').ValidatorAPI.ValidatorFn |
   *    import('./types').ValidatorAPI.ValidatorData
   * )}   validators - Validators to remove.
   */
  remove(...validators) {
    const length = this.#validatorData.length;
    if (length === 0) {
      return;
    }
    for (const data of validators) {
      const actualValidator = typeof data === "function" ? data : isObject(data) ? data.validate : void 0;
      if (!actualValidator) {
        continue;
      }
      for (let cntr = this.#validatorData.length; --cntr >= 0; ) {
        if (this.#validatorData[cntr].validate === actualValidator) {
          this.#validatorData.splice(cntr, 1);
          let unsubscribe = void 0;
          if (typeof (unsubscribe = this.#mapUnsubscribe.get(actualValidator)) === "function") {
            unsubscribe();
            this.#mapUnsubscribe.delete(actualValidator);
          }
        }
      }
    }
    if (length !== this.#validatorData.length) {
      this.#updateFn();
    }
  }
  /**
   * Remove validators by the provided callback. The callback takes 3 parameters: `id`, `validator`, and `weight`.
   * Any truthy value returned will remove that validator.
   *
   * @param {import('./types').ValidatorAPI.RemoveByCallback} callback - Callback function to evaluate each validator
   *        entry.
   */
  removeBy(callback) {
    const length = this.#validatorData.length;
    if (length === 0) {
      return;
    }
    if (typeof callback !== "function") {
      throw new TypeError(`AdapterValidator error: 'callback' is not a function.`);
    }
    this.#validatorData = this.#validatorData.filter((data) => {
      const remove = callback.call(callback, { ...data });
      if (remove) {
        let unsubscribe;
        if (typeof (unsubscribe = this.#mapUnsubscribe.get(data.validate)) === "function") {
          unsubscribe();
          this.#mapUnsubscribe.delete(data.validate);
        }
      }
      return !remove;
    });
    if (length !== this.#validatorData.length) {
      this.#updateFn();
    }
  }
  /**
   * Removes any validators with matching IDs.
   *
   * @param {...any}   ids - IDs to remove.
   */
  removeById(...ids) {
    const length = this.#validatorData.length;
    if (length === 0) {
      return;
    }
    this.#validatorData = this.#validatorData.filter((data) => {
      let remove = false;
      for (const id of ids) {
        remove |= data.id === id;
      }
      if (remove) {
        let unsubscribe;
        if (typeof (unsubscribe = this.#mapUnsubscribe.get(data.validate)) === "function") {
          unsubscribe();
          this.#mapUnsubscribe.delete(data.validate);
        }
      }
      return !remove;
    });
    if (length !== this.#validatorData.length) {
      this.#updateFn();
    }
  }
}
class TransformBounds extends SystemBase {
  static {
    __name(this, "TransformBounds");
  }
  static #TRANSFORM_DATA = new TJSTransformData();
  /**
   * Provides a validator that respects transforms in positional data constraining the position to within the target
   * elements bounds.
   *
   * @param {import('./types').ValidatorAPI.ValidationData}   valData - The associated validation data for position
   *        updates.
   *
   * @returns {import('../../data/types').Data.TJSPositionData} Potentially adjusted position data.
   */
  validate(valData) {
    if (!this.enabled) {
      return valData.position;
    }
    const boundsWidth = this.width ?? this.element?.offsetWidth ?? globalThis.innerWidth;
    const boundsHeight = this.height ?? this.element?.offsetHeight ?? globalThis.innerHeight;
    if (typeof valData.position.width === "number") {
      const maxW = valData.maxWidth ?? (this.constrain ? boundsWidth : Number.MAX_SAFE_INTEGER);
      valData.position.width = clamp(valData.width, valData.minWidth, maxW);
    }
    if (typeof valData.position.height === "number") {
      const maxH = valData.maxHeight ?? (this.constrain ? boundsHeight : Number.MAX_SAFE_INTEGER);
      valData.position.height = clamp(valData.height, valData.minHeight, maxH);
    }
    const data = valData.transforms.getData(valData.position, TransformBounds.#TRANSFORM_DATA, valData);
    const initialX = data.boundingRect.x;
    const initialY = data.boundingRect.y;
    if (data.boundingRect.bottom + valData.marginTop > boundsHeight) {
      data.boundingRect.y += boundsHeight - data.boundingRect.bottom - valData.marginTop;
    }
    if (data.boundingRect.right + valData.marginLeft > boundsWidth) {
      data.boundingRect.x += boundsWidth - data.boundingRect.right - valData.marginLeft;
    }
    if (data.boundingRect.top - valData.marginTop < 0) {
      data.boundingRect.y += Math.abs(data.boundingRect.top - valData.marginTop);
    }
    if (data.boundingRect.left - valData.marginLeft < 0) {
      data.boundingRect.x += Math.abs(data.boundingRect.left - valData.marginLeft);
    }
    valData.position.left -= initialX - data.boundingRect.x;
    valData.position.top -= initialY - data.boundingRect.y;
    return valData.position;
  }
}
class PositionChangeSet {
  static {
    __name(this, "PositionChangeSet");
  }
  constructor() {
    this.left = false;
    this.top = false;
    this.width = false;
    this.height = false;
    this.maxHeight = false;
    this.maxWidth = false;
    this.minHeight = false;
    this.minWidth = false;
    this.zIndex = false;
    this.transform = false;
    this.transformOrigin = false;
  }
  hasChange() {
    return this.left || this.top || this.width || this.height || this.maxHeight || this.maxWidth || this.minHeight || this.minWidth || this.zIndex || this.transform || this.transformOrigin;
  }
  set(value) {
    this.left = value;
    this.top = value;
    this.width = value;
    this.height = value;
    this.maxHeight = value;
    this.maxWidth = value;
    this.minHeight = value;
    this.minWidth = value;
    this.zIndex = value;
    this.transform = value;
    this.transformOrigin = value;
  }
}
class UpdateElementData {
  static {
    __name(this, "UpdateElementData");
  }
  constructor() {
    this.data = void 0;
    this.dataSubscribers = Object.seal(new TJSPositionData());
    this.dimensionData = Object.seal({ width: 0, height: 0 });
    this.changeSet = void 0;
    this.options = void 0;
    this.queued = false;
    this.styleCache = void 0;
    this.transforms = void 0;
    this.transformData = new TJSTransformData();
    this.subscribers = void 0;
    this.storeDimension = writable(this.dimensionData);
    this.storeTransform = writable(this.transformData, () => {
      this.options.transformSubscribed = true;
      return () => this.options.transformSubscribed = false;
    });
    this.queued = false;
  }
}
class UpdateElementManager {
  static {
    __name(this, "UpdateElementManager");
  }
  /**
   * Stores the active list of all TJSPosition instances currently updating. The list entries are recycled between
   * updates.
   *
   * @type {[HTMLElement, import('./').UpdateElementData][]}
   */
  static list = [];
  /**
   * Tracks the current position in the list.
   *
   * @type {number}
   */
  static listCntr = 0;
  static updatePromise;
  /**
   * Potentially adds the given element and internal updateData instance to the list.
   *
   * @param {HTMLElement}       el - An HTMLElement instance.
   *
   * @param {import('./').UpdateElementData} updateData - An UpdateElementData instance.
   *
   * @returns {Promise<number>} The unified next frame update promise. Returns `currentTime`.
   */
  static add(el, updateData) {
    if (this.listCntr < this.list.length) {
      const entry = this.list[this.listCntr];
      entry[0] = el;
      entry[1] = updateData;
    } else {
      this.list.push([el, updateData]);
    }
    this.listCntr++;
    updateData.queued = true;
    if (!this.updatePromise) {
      this.updatePromise = this.wait();
    }
    return this.updatePromise;
  }
  /**
   * Await on `nextAnimationFrame` and iterate over list map invoking callback functions.
   *
   * @returns {Promise<number>} The next frame Promise / currentTime from nextAnimationFrame.
   */
  static async wait() {
    const currentTime = await nextAnimationFrame();
    this.updatePromise = void 0;
    for (let cntr = this.listCntr; --cntr >= 0; ) {
      const entry = this.list[cntr];
      const el = entry[0];
      const updateData = entry[1];
      entry[0] = void 0;
      entry[1] = void 0;
      updateData.queued = false;
      if (!el.isConnected) {
        continue;
      }
      if (updateData.options.ortho) {
        UpdateElementManager.#updateElementOrtho(el, updateData);
      } else {
        UpdateElementManager.#updateElement(el, updateData);
      }
      if (updateData.options.calculateTransform || updateData.options.transformSubscribed) {
        UpdateElementManager.#updateTransform(el, updateData);
      }
      this.updateSubscribers(updateData);
    }
    this.listCntr = 0;
    return currentTime;
  }
  /**
   * Potentially immediately updates the given element.
   *
   * @param {HTMLElement}       el - An HTMLElement instance.
   *
   * @param {import('./').UpdateElementData} updateData - An UpdateElementData instance.
   */
  static immediate(el, updateData) {
    if (!el.isConnected) {
      return;
    }
    if (updateData.options.ortho) {
      UpdateElementManager.#updateElementOrtho(el, updateData);
    } else {
      UpdateElementManager.#updateElement(el, updateData);
    }
    if (updateData.options.calculateTransform || updateData.options.transformSubscribed) {
      UpdateElementManager.#updateTransform(el, updateData);
    }
    this.updateSubscribers(updateData);
  }
  /**
   * @param {import('./').UpdateElementData} updateData - Data change set.
   */
  static updateSubscribers(updateData) {
    const data = updateData.data;
    const changeSet = updateData.changeSet;
    if (!changeSet.hasChange()) {
      return;
    }
    const output = TJSPositionDataUtil.copyData(data, updateData.dataSubscribers);
    const subscribers = updateData.subscribers;
    if (subscribers.length > 0) {
      for (let cntr = 0; cntr < subscribers.length; cntr++) {
        subscribers[cntr](output);
      }
    }
    if (changeSet.width || changeSet.height) {
      updateData.dimensionData.width = data.width;
      updateData.dimensionData.height = data.height;
      updateData.storeDimension.set(updateData.dimensionData);
    }
    changeSet.set(false);
  }
  // Internal Implementation ----------------------------------------------------------------------------------------
  /**
   * Temporary data for validation.
   *
   * @type {{width, marginTop, height, marginLeft}}
   */
  static #validationData = Object.seal({
    height: void 0,
    width: void 0,
    marginLeft: void 0,
    marginTop: void 0
  });
  /**
   * Decouples updates to any parent target HTMLElement inline styles. Invoke {@link TJSPosition.elementUpdated} to
   * await on the returned promise that is resolved with the current render time via `nextAnimationFrame` /
   * `requestAnimationFrame`. This allows the underlying data model to be updated immediately while updates to the
   * element are in sync with the browser and potentially in the future be further throttled.
   *
   * @param {HTMLElement} el - The target HTMLElement.
   *
   * @param {import('./').UpdateElementData} updateData - Update data.
   */
  static #updateElement(el, updateData) {
    const changeSet = updateData.changeSet;
    const data = updateData.data;
    if (changeSet.left) {
      el.style.left = `${data.left}px`;
    }
    if (changeSet.top) {
      el.style.top = `${data.top}px`;
    }
    if (changeSet.zIndex) {
      el.style.zIndex = typeof data.zIndex === "number" ? `${data.zIndex}` : null;
    }
    if (changeSet.width) {
      el.style.width = typeof data.width === "number" ? `${data.width}px` : data.width;
    }
    if (changeSet.height) {
      el.style.height = typeof data.height === "number" ? `${data.height}px` : data.height;
    }
    if (changeSet.transformOrigin) {
      el.style.transformOrigin = data.transformOrigin;
    }
    if (changeSet.transform) {
      el.style.transform = updateData.transforms.isActive ? updateData.transforms.getCSS() : null;
    }
  }
  /**
   * Decouples updates to any parent target HTMLElement inline styles. Invoke
   * {@link TJSPosition.elementUpdated} to await on the returned promise that is resolved with the current
   * render time via `nextAnimationFrame` / `requestAnimationFrame`. This allows the underlying data model to be updated
   * immediately while updates to the element are in sync with the browser and potentially in the future be further
   * throttled.
   *
   * @param {HTMLElement} el - The target HTMLElement.
   *
   * @param {import('./').UpdateElementData} updateData - Update data.
   */
  static #updateElementOrtho(el, updateData) {
    const changeSet = updateData.changeSet;
    const data = updateData.data;
    if (changeSet.zIndex) {
      el.style.zIndex = typeof data.zIndex === "number" ? `${data.zIndex}` : null;
    }
    if (changeSet.width) {
      el.style.width = typeof data.width === "number" ? `${data.width}px` : data.width;
    }
    if (changeSet.height) {
      el.style.height = typeof data.height === "number" ? `${data.height}px` : data.height;
    }
    if (changeSet.transformOrigin) {
      el.style.transformOrigin = data.transformOrigin;
    }
    if (changeSet.left || changeSet.top || changeSet.transform) {
      el.style.transform = updateData.transforms.getCSSOrtho(data);
    }
  }
  /**
   * Updates the applied transform data and sets the readble `transform` store.
   *
   * @param {HTMLElement} el - The target HTMLElement.
   *
   * @param {import('./').UpdateElementData} updateData - Update element data.
   */
  static #updateTransform(el, updateData) {
    const validationData = this.#validationData;
    validationData.height = updateData.data.height !== "auto" && updateData.data.height !== "inherit" ? updateData.data.height : updateData.styleCache.offsetHeight;
    validationData.width = updateData.data.width !== "auto" && updateData.data.height !== "inherit" ? updateData.data.width : updateData.styleCache.offsetWidth;
    validationData.marginLeft = updateData.styleCache.marginLeft;
    validationData.marginTop = updateData.styleCache.marginTop;
    updateData.transforms.getData(updateData.data, updateData.transformData, validationData);
    updateData.storeTransform.set(updateData.transformData);
  }
}
class TJSPositionStyleCache {
  static {
    __name(this, "TJSPositionStyleCache");
  }
  constructor() {
    this.el = void 0;
    this.computed = void 0;
    this.marginLeft = void 0;
    this.marginTop = void 0;
    this.maxHeight = void 0;
    this.maxWidth = void 0;
    this.minHeight = void 0;
    this.minWidth = void 0;
    this.hasWillChange = false;
    this.resizeObserved = Object.seal({
      contentHeight: void 0,
      contentWidth: void 0,
      offsetHeight: void 0,
      offsetWidth: void 0
    });
    const storeResizeObserved = writable(this.resizeObserved);
    this.stores = {
      element: writable(this.el),
      resizeContentHeight: propertyStore(storeResizeObserved, "contentHeight"),
      resizeContentWidth: propertyStore(storeResizeObserved, "contentWidth"),
      resizeObserved: storeResizeObserved,
      resizeObservable: writable(false),
      resizeOffsetHeight: propertyStore(storeResizeObserved, "offsetHeight"),
      resizeOffsetWidth: propertyStore(storeResizeObserved, "offsetWidth")
    };
  }
  /**
   * Returns the cached offsetHeight from any attached `resizeObserver` action otherwise gets the offsetHeight from
   * the element directly. The more optimized path is using `resizeObserver` as getting it from the element
   * directly is more expensive and alters the execution order of an animation frame.
   *
   * @returns {number} The element offsetHeight.
   */
  get offsetHeight() {
    if (A11yHelper.isFocusTarget(this.el)) {
      return this.resizeObserved.offsetHeight !== void 0 ? this.resizeObserved.offsetHeight : this.el.offsetHeight;
    }
    throw new Error(`TJSPositionStyleCache - get offsetHeight error: no element assigned.`);
  }
  /**
   * Returns the cached offsetWidth from any attached `resizeObserver` action otherwise gets the offsetWidth from
   * the element directly. The more optimized path is using `resizeObserver` as getting it from the element
   * directly is more expensive and alters the execution order of an animation frame.
   *
   * @returns {number} The element offsetHeight.
   */
  get offsetWidth() {
    if (A11yHelper.isFocusTarget(this.el)) {
      return this.resizeObserved.offsetWidth !== void 0 ? this.resizeObserved.offsetWidth : this.el.offsetWidth;
    }
    throw new Error(`TJSPositionStyleCache - get offsetWidth error: no element assigned.`);
  }
  /**
   * @param {HTMLElement} el -
   *
   * @returns {boolean} Does element match cached element.
   */
  hasData(el) {
    return this.el === el;
  }
  /**
   * Resets the style cache.
   */
  reset() {
    if (A11yHelper.isFocusTarget(this.el) && this.el.isConnected && !this.hasWillChange) {
      this.el.style.willChange = null;
    }
    this.el = void 0;
    this.computed = void 0;
    this.marginLeft = void 0;
    this.marginTop = void 0;
    this.maxHeight = void 0;
    this.maxWidth = void 0;
    this.minHeight = void 0;
    this.minWidth = void 0;
    this.hasWillChange = false;
    this.resizeObserved.contentHeight = void 0;
    this.resizeObserved.contentWidth = void 0;
    this.resizeObserved.offsetHeight = void 0;
    this.resizeObserved.offsetWidth = void 0;
    this.stores.element.set(void 0);
  }
  /**
   * Updates the style cache with new data from the given element.
   *
   * @param {HTMLElement} el - An HTML element.
   */
  update(el) {
    this.el = el;
    this.computed = globalThis.getComputedStyle(el);
    this.marginLeft = StyleParse.pixels(el.style.marginLeft) ?? StyleParse.pixels(this.computed.marginLeft);
    this.marginTop = StyleParse.pixels(el.style.marginTop) ?? StyleParse.pixels(this.computed.marginTop);
    this.maxHeight = StyleParse.pixels(el.style.maxHeight) ?? StyleParse.pixels(this.computed.maxHeight);
    this.maxWidth = StyleParse.pixels(el.style.maxWidth) ?? StyleParse.pixels(this.computed.maxWidth);
    this.minHeight = StyleParse.pixels(el.style.minHeight) ?? StyleParse.pixels(this.computed.minHeight);
    this.minWidth = StyleParse.pixels(el.style.minWidth) ?? StyleParse.pixels(this.computed.minWidth);
    const willChange = el.style.willChange !== "" ? el.style.willChange : this.computed.willChange;
    this.hasWillChange = willChange !== "" && willChange !== "auto";
    this.stores.element.set(el);
  }
}
class TJSPosition {
  static {
    __name(this, "TJSPosition");
  }
  /**
   * Public API for {@link TJSPosition.Initial}.
   *
   * @type {Readonly<import('./types').TJSPositionTypes.PositionInitial>}
   */
  static #positionInitial = Object.freeze({
    browserCentered: new Centered({ lock: true }),
    Centered
  });
  /**
   * Public API for {@link TJSPosition.Validators}
   *
   * @type {Readonly<import('./types').TJSPositionTypes.PositionValidators>}
   */
  static #positionValidators = Object.freeze({
    TransformBounds,
    transformWindow: new TransformBounds({ lock: true })
  });
  /**
   * Stores all position data / properties.
   *
   * @type {TJSPositionData}
   */
  #data = Object.seal(new TJSPositionData());
  /**
   * Provides the animation API.
   *
   * @type {import('./animation/types').AnimationAPI}
   */
  #animate = new AnimationAPI(this, this.#data);
  /**
   * Provides a way to turn on / off the position handling.
   *
   * @type {boolean}
   */
  #enabled = true;
  /**
   * Stores ongoing options that are set in the constructor or by transform store subscription.
   *
   * @type {import('./types-local').OptionsInternal}
   */
  #options = {
    calculateTransform: false,
    initial: void 0,
    ortho: true,
    transformSubscribed: false
  };
  /**
   * The associated parent for positional data tracking. Used in validators.
   *
   * @type {import('./types').TJSPositionTypes.PositionParent}
   */
  #parent;
  /**
   * Stores the style attributes that changed on update.
   *
   * @type {PositionChangeSet}
   */
  #positionChangeSet = new PositionChangeSet();
  /**
   * Tracks the current state if this position instance is a candidate for resize observation by the `resizeObserver`
   * action. This is `true` when `width` or `height` is `auto` or `inherit`.
   *
   * @type {boolean}
   */
  #resizeObservable = false;
  /**
   * @type {import('./types').TJSPositionTypes.Stores}
   */
  #stores;
  /**
   * Stores an instance of the computer styles for the target element.
   *
   * @type {TJSPositionStyleCache}
   */
  #styleCache;
  /**
   * Stores the subscribers.
   *
   * @type {import('svelte/store').Subscriber<import('./data/types').Data.TJSPositionData>[]}
   */
  #subscribers = [];
  /**
   * @type {TJSTransforms}
   */
  #transforms = new TJSTransforms();
  /**
   * @type {UpdateElementData}
   */
  #updateElementData;
  /**
   * Stores the UpdateElementManager wait promise.
   *
   * @type {Promise}
   */
  #updateElementPromise;
  /**
   * @type {AdapterValidators}
   */
  #validators;
  /**
   * @type {import('./system/validators/types').ValidatorAPI.ValidatorData[]}
   */
  #validatorData;
  /**
   * @type {PositionStateAPI}
   */
  #state = new PositionStateAPI(this, this.#data, this.#transforms);
  /**
   * @returns {import('./animation/types').AnimationGroupAPI} Public Animation API.
   */
  static get Animate() {
    return AnimationGroupAPI;
  }
  /**
   * @returns {import('./data/types').Data.TJSPositionDataConstructor} TJSPositionData constructor.
   */
  static get Data() {
    return TJSPositionData;
  }
  /**
   * @returns {Readonly<import('./types').TJSPositionTypes.PositionInitial>} TJSPosition default initial helpers.
   */
  static get Initial() {
    return this.#positionInitial;
  }
  /**
   * @returns {import('./system/types').System.SystemBaseConstructor} `SystemBase` constructor.
   */
  static get SystemBase() {
    return SystemBase;
  }
  /**
   * Returns TJSTransformData class / constructor.
   *
   * @returns {import('./transform/types').TransformAPI.TransformDataConstructor} TransformData class /
   *          constructor.
   */
  static get TransformData() {
    return TJSTransformData;
  }
  /**
   * Returns default validators.
   *
   * @returns {Readonly<import('./types').TJSPositionTypes.PositionValidators>} Available validators.
   */
  static get Validators() {
    return this.#positionValidators;
  }
  /**
   * Returns a list of supported transform origins.
   *
   * @returns {Readonly<import('./transform/types').TransformAPI.TransformOrigin[]>} The supported transform origin
   *          strings.
   */
  static get transformOrigins() {
    return TJSTransforms.transformOrigins;
  }
  /**
   * Convenience to copy from source to target of two TJSPositionData like objects. If a target is not supplied a new
   * {@link TJSPositionData} instance is created.
   *
   * @param {Partial<import('./data/types').Data.TJSPositionData>}  source - The source instance to copy from.
   *
   * @param {import('./data/types').Data.TJSPositionData}  [target] - Target TJSPositionData like object; if one is not
   *        provided a new instance is created.
   *
   * @returns {import('./data/types').Data.TJSPositionData} The target instance with all TJSPositionData fields.
   */
  static copyData(source, target) {
    return TJSPositionDataUtil.copyData(source, target);
  }
  /**
   * Returns a duplicate of a given position instance copying any options and validators. The position parent is not
   * copied and a new one must be set manually via the {@link TJSPosition.parent} setter.
   *
   * @param {TJSPosition} position - A position instance.
   *
   * @param {import('./types').TJSPositionTypes.OptionsCtorAll}   [options] - Unique new options to set.
   *
   * @returns {TJSPosition} A duplicate position instance.
   */
  static duplicate(position, options = {}) {
    if (!(position instanceof TJSPosition)) {
      throw new TypeError(`'position' is not an instance of TJSPosition.`);
    }
    const newPosition = new TJSPosition(options);
    newPosition.#options = Object.assign({}, position.#options, options);
    newPosition.#validators.add(...position.#validators);
    newPosition.set(position.#data);
    return newPosition;
  }
  /**
   * @param {(
   *    import('./types').TJSPositionTypes.PositionParent |
   *    import('./types').TJSPositionTypes.OptionsCtorAll
   * )} [parentOrOptions] - A  potential parent element or object w/ `elementTarget` accessor. You may also forego
   *    setting the parent and pass in the options object.
   *
   * @param {import('./types').TJSPositionTypes.OptionsCtorAll}  [options] - The options object.
   */
  constructor(parentOrOptions, options) {
    if (isPlainObject(parentOrOptions)) {
      options = parentOrOptions;
    } else {
      this.#parent = /** @type {import('./types').TJSPositionTypes.PositionParent} */
      parentOrOptions;
    }
    this.#styleCache = new TJSPositionStyleCache();
    const updateData = new UpdateElementData();
    updateData.changeSet = this.#positionChangeSet;
    updateData.data = this.#data;
    updateData.options = this.#options;
    updateData.styleCache = this.#styleCache;
    updateData.subscribers = this.#subscribers;
    updateData.transforms = this.#transforms;
    this.#updateElementData = updateData;
    if (typeof options?.calculateTransform === "boolean") {
      this.#options.calculateTransform = options.calculateTransform;
    }
    if (typeof options?.ortho === "boolean") {
      this.#options.ortho = options.ortho;
    }
    this.#stores = Object.freeze({
      // The main properties for manipulating TJSPosition.
      height: propertyStore(this, "height"),
      left: propertyStore(this, "left"),
      rotateX: propertyStore(this, "rotateX"),
      rotateY: propertyStore(this, "rotateY"),
      rotateZ: propertyStore(this, "rotateZ"),
      scale: propertyStore(this, "scale"),
      top: propertyStore(this, "top"),
      transformOrigin: propertyStore(this, "transformOrigin"),
      translateX: propertyStore(this, "translateX"),
      translateY: propertyStore(this, "translateY"),
      translateZ: propertyStore(this, "translateZ"),
      width: propertyStore(this, "width"),
      zIndex: propertyStore(this, "zIndex"),
      // Stores that control validation when width / height is not `auto`.
      maxHeight: propertyStore(this, "maxHeight"),
      maxWidth: propertyStore(this, "maxWidth"),
      minHeight: propertyStore(this, "minHeight"),
      minWidth: propertyStore(this, "minWidth"),
      // Readable stores based on updates or from resize observer changes.
      dimension: { subscribe: updateData.storeDimension.subscribe },
      element: { subscribe: this.#styleCache.stores.element.subscribe },
      resizeContentHeight: { subscribe: this.#styleCache.stores.resizeContentHeight.subscribe },
      resizeContentWidth: { subscribe: this.#styleCache.stores.resizeContentWidth.subscribe },
      resizeObservable: { subscribe: this.#styleCache.stores.resizeObservable.subscribe },
      resizeOffsetHeight: { subscribe: this.#styleCache.stores.resizeOffsetHeight.subscribe },
      resizeOffsetWidth: { subscribe: this.#styleCache.stores.resizeOffsetWidth.subscribe },
      transform: { subscribe: updateData.storeTransform.subscribe },
      // Protected store that should only be set by resizeObserver action.
      resizeObserved: this.#styleCache.stores.resizeObserved
    });
    Object.defineProperty(this.#stores.transformOrigin, "values", {
      get: () => TJSPosition.transformOrigins
    });
    subscribeIgnoreFirst(this.#stores.resizeObserved, (resizeData) => {
      const parent = this.#parent;
      const el = A11yHelper.isFocusTarget(parent) ? parent : parent?.elementTarget;
      if (A11yHelper.isFocusTarget(el) && Number.isFinite(resizeData?.offsetWidth) && Number.isFinite(resizeData?.offsetHeight)) {
        this.set();
      }
    });
    [this.#validators, this.#validatorData] = AdapterValidators.create(() => this.set());
    if (options?.initial) {
      const initial = options.initial;
      if (typeof initial?.getLeft !== "function" || typeof initial?.getTop !== "function") {
        throw new Error(
          `'options.initial' position helper does not contain 'getLeft' and / or 'getTop' functions.`
        );
      }
      this.#options.initial = initial;
    }
    if (options?.validator) {
      if (isIterable(options?.validator)) {
        this.validators.add(...options.validator);
      } else {
        const validatorFn = options.validator;
        this.validators.add(validatorFn);
      }
    }
    Object.seal(this);
    if (isObject(options)) {
      this.set(options);
    }
  }
  /**
   * Returns the animation API.
   *
   * @returns {import('./animation/types').AnimationAPI} Animation API.
   */
  get animate() {
    return this.#animate;
  }
  /**
   * Returns the dimension data for the readable store.
   *
   * @returns {Readonly<{width: number | 'auto' | 'inherit', height: number | 'auto' | 'inherit'}>} Dimension data.
   */
  get dimension() {
    return this.#updateElementData.dimensionData;
  }
  /**
   * Returns the enabled state.
   *
   * @returns {boolean} Enabled state.
   */
  get enabled() {
    return this.#enabled;
  }
  /**
   * Returns the current HTMLElement being positioned.
   *
   * @returns {HTMLElement | undefined} Current HTMLElement being positioned.
   */
  get element() {
    return this.#styleCache.el;
  }
  /**
   * Returns a promise that is resolved on the next element update with the time of the update.
   *
   * @returns {Promise<number>} Promise resolved on element update.
   */
  get elementUpdated() {
    return this.#updateElementPromise;
  }
  /**
   * Returns the associated {@link TJSPositionTypes.PositionParent} instance.
   *
   * @returns {import('./types').TJSPositionTypes.PositionParent} The current position parent instance.
   */
  get parent() {
    return this.#parent;
  }
  /**
   * Returns the state API.
   *
   * @returns {import('./state/types').PositionStateAPI} TJSPosition state API.
   */
  get state() {
    return this.#state;
  }
  /**
   * Returns the derived writable stores for individual data variables.
   *
   * @returns {import('./types').TJSPositionTypes.Stores} Derived / writable stores.
   */
  get stores() {
    return this.#stores;
  }
  /**
   * Returns the transform data for the readable store.
   *
   * @returns {import('./transform/types').TransformAPI.TransformData} Transform Data.
   */
  get transform() {
    return this.#updateElementData.transformData;
  }
  /**
   * Returns the validators.
   *
   * @returns {import('./system/validators/types').ValidatorAPI} validators.
   */
  get validators() {
    return this.#validators;
  }
  /**
   * Sets the enabled state.
   *
   * @param {boolean}  enabled - New enabled state.
   */
  set enabled(enabled) {
    if (typeof enabled !== "boolean") {
      throw new TypeError(`'enabled' is not a boolean.`);
    }
    this.#enabled = enabled;
  }
  /**
   * Sets the associated {@link TJSPositionTypes.PositionParent} instance. Resets the style cache and default data.
   *
   * @param {import('./types').TJSPositionTypes.PositionParent | undefined} parent - A PositionParent instance or
   *        undefined to disassociate
   */
  set parent(parent) {
    if (parent !== void 0 && !A11yHelper.isFocusTarget(parent) && !isObject(parent)) {
      throw new TypeError(`'parent' is not an HTMLElement, object, or undefined.`);
    }
    this.#parent = parent;
    this.#state.remove({ name: "#defaultData" });
    this.#styleCache.reset();
    if (parent) {
      this.set(this.#data);
    }
  }
  // Data accessors ----------------------------------------------------------------------------------------------------
  /**
   * @returns {number | 'auto' | 'inherit' | null} height
   */
  get height() {
    return this.#data.height;
  }
  /**
   * @returns {number | null} left
   */
  get left() {
    return this.#data.left;
  }
  /**
   * @returns {number | null} maxHeight
   */
  get maxHeight() {
    return this.#data.maxHeight;
  }
  /**
   * @returns {number | null} maxWidth
   */
  get maxWidth() {
    return this.#data.maxWidth;
  }
  /**
   * @returns {number | null} minHeight
   */
  get minHeight() {
    return this.#data.minHeight;
  }
  /**
   * @returns {number | null} minWidth
   */
  get minWidth() {
    return this.#data.minWidth;
  }
  /**
   * @returns {number | null} rotateX
   */
  get rotateX() {
    return this.#data.rotateX;
  }
  /**
   * @returns {number | null} rotateY
   */
  get rotateY() {
    return this.#data.rotateY;
  }
  /**
   * @returns {number | null} rotateZ
   */
  get rotateZ() {
    return this.#data.rotateZ;
  }
  /**
   * @returns {number | null} alias for rotateZ
   */
  get rotation() {
    return this.#data.rotateZ;
  }
  /**
   * @returns {number | null} scale
   */
  get scale() {
    return this.#data.scale;
  }
  /**
   * @returns {number | null} top
   */
  get top() {
    return this.#data.top;
  }
  /**
   * @returns {import('./transform/types').TransformAPI.TransformOrigin | null} transformOrigin
   */
  get transformOrigin() {
    return this.#data.transformOrigin;
  }
  /**
   * @returns {number | null} translateX
   */
  get translateX() {
    return this.#data.translateX;
  }
  /**
   * @returns {number | null} translateY
   */
  get translateY() {
    return this.#data.translateY;
  }
  /**
   * @returns {number | null} translateZ
   */
  get translateZ() {
    return this.#data.translateZ;
  }
  /**
   * @returns {number | 'auto' | 'inherit' | null} width
   */
  get width() {
    return this.#data.width;
  }
  /**
   * @returns {number | null} z-index
   */
  get zIndex() {
    return this.#data.zIndex;
  }
  /**
   * @param {number | 'auto' | 'inherit' | null} height -
   */
  set height(height) {
    this.#stores.height.set(height);
  }
  /**
   * @param {number | string | null} left -
   */
  set left(left) {
    this.#stores.left.set(left);
  }
  /**
   * @param {number | string | null} maxHeight -
   */
  set maxHeight(maxHeight) {
    this.#stores.maxHeight.set(maxHeight);
  }
  /**
   * @param {number | string | null} maxWidth -
   */
  set maxWidth(maxWidth) {
    this.#stores.maxWidth.set(maxWidth);
  }
  /**
   * @param {number | string | null} minHeight -
   */
  set minHeight(minHeight) {
    this.#stores.minHeight.set(minHeight);
  }
  /**
   * @param {number | string | null} minWidth -
   */
  set minWidth(minWidth) {
    this.#stores.minWidth.set(minWidth);
  }
  /**
   * @param {number | string | null} rotateX -
   */
  set rotateX(rotateX) {
    this.#stores.rotateX.set(rotateX);
  }
  /**
   * @param {number | string | null} rotateY -
   */
  set rotateY(rotateY) {
    this.#stores.rotateY.set(rotateY);
  }
  /**
   * @param {number | string | null} rotateZ -
   */
  set rotateZ(rotateZ) {
    this.#stores.rotateZ.set(rotateZ);
  }
  /**
   * @param {number | string | null} rotateZ - alias for rotateZ
   */
  set rotation(rotateZ) {
    this.#stores.rotateZ.set(rotateZ);
  }
  /**
   * @param {number | string | null} scale -
   */
  set scale(scale) {
    this.#stores.scale.set(scale);
  }
  /**
   * @param {number | string | null} top -
   */
  set top(top) {
    this.#stores.top.set(top);
  }
  /**
   * @param {import('./transform/types').TransformAPI.TransformOrigin} transformOrigin -
   */
  set transformOrigin(transformOrigin) {
    if (TJSTransforms.transformOrigins.includes(transformOrigin)) {
      this.#stores.transformOrigin.set(transformOrigin);
    }
  }
  /**
   * @param {number | string | null} translateX -
   */
  set translateX(translateX) {
    this.#stores.translateX.set(translateX);
  }
  /**
   * @param {number | string | null} translateY -
   */
  set translateY(translateY) {
    this.#stores.translateY.set(translateY);
  }
  /**
   * @param {number | string | null} translateZ -
   */
  set translateZ(translateZ) {
    this.#stores.translateZ.set(translateZ);
  }
  /**
   * @param {number | 'auto' | 'inherit' | null} width -
   */
  set width(width) {
    this.#stores.width.set(width);
  }
  /**
   * @param {number | string | null} zIndex -
   */
  set zIndex(zIndex) {
    this.#stores.zIndex.set(zIndex);
  }
  /**
   * Assigns current position data to given object `data` object. By default, `null` position data is not assigned.
   * Other options allow configuration of the data assigned including setting default numeric values for any properties
   * that are null.
   *
   * @param {object}  [data] - Target to assign current position data.
   *
   * @param {import('./types').TJSPositionTypes.OptionsGet}   [options] - Defines options for specific keys and
   *        substituting null for numeric default values. By default, nullable keys are included.
   *
   * @returns {Partial<import('./data/types').Data.TJSPositionData>} Passed in object with current position data.
   */
  get(data = {}, options) {
    const keys = options?.keys;
    const excludeKeys = options?.exclude;
    const nullable = options?.nullable ?? true;
    const numeric = options?.numeric ?? false;
    if (isIterable(keys)) {
      for (const key of keys) {
        data[key] = numeric ? TJSPositionDataUtil.getDataOrDefault(this, key) : this[key];
        if (!nullable && data[key] === null) {
          delete data[key];
        }
      }
      if (isIterable(excludeKeys)) {
        for (const key of excludeKeys) {
          delete data[key];
        }
      }
      return data;
    } else {
      data = Object.assign(data, this.#data);
      if (isIterable(excludeKeys)) {
        for (const key of excludeKeys) {
          delete data[key];
        }
      }
      if (numeric) {
        TJSPositionDataUtil.setNumericDefaults(data);
      }
      if (!nullable) {
        for (const key in data) {
          if (data[key] === null) {
            delete data[key];
          }
        }
      }
      return data;
    }
  }
  /**
   * @returns {import('./data/types').Data.TJSPositionData} Current position data.
   */
  toJSON() {
    return Object.assign({}, this.#data);
  }
  /**
   * All calculation and updates of position are implemented in {@link TJSPosition}. This allows position to be fully
   * reactive and in control of updating inline styles for a connected {@link HTMLElement}.
   *
   * The initial set call with a target element will always set width / height as this is necessary for correct
   * calculations.
   *
   * When a target element is present updated styles are applied after validation. To modify the behavior of set
   * implement one or more validator functions and add them via the validator API available from
   * {@link TJSPosition.validators}.
   *
   * Updates to any target element are decoupled from the underlying TJSPosition data. This method returns this
   * instance that you can then await on the target element inline style update by using
   * {@link TJSPosition.elementUpdated}.
   *
   * Relative updates to any property of {@link TJSPositionData} are possible by specifying properties as strings.
   * This string should be in the form of '+=', '-=', or '*=' and float / numeric value. IE '+=0.2'.
   * {@link TJSPosition.set} will apply the `addition`, `subtraction`, or `multiplication` operation specified against
   * the current value of the given property. Please see {@link Data.TJSPositionDataRelative} for a detailed
   * description.
   *
   * @param {import('./data/types').Data.TJSPositionDataRelative} [position] - TJSPosition data to set.
   *
   * @param {import('./types').TJSPositionTypes.OptionsSet} [options] - Additional options.
   *
   * @returns {TJSPosition} This TJSPosition instance.
   */
  set(position = {}, options) {
    if (!isObject(position)) {
      throw new TypeError(`TJSPosition - set error: 'position' is not an object.`);
    }
    const parent = this.#parent;
    if (!this.#enabled) {
      return this;
    }
    if (parent !== void 0 && typeof parent?.options?.positionable === "boolean" && !parent?.options?.positionable) {
      return this;
    }
    const immediateElementUpdate = options?.immediateElementUpdate ?? false;
    const data = this.#data;
    const transforms = this.#transforms;
    const targetEl = A11yHelper.isFocusTarget(parent) ? parent : parent?.elementTarget;
    const el = A11yHelper.isFocusTarget(targetEl) && targetEl.isConnected ? targetEl : void 0;
    const changeSet = this.#positionChangeSet;
    const styleCache = this.#styleCache;
    if (el) {
      if (!styleCache.hasData(el)) {
        styleCache.update(el);
        if (!styleCache.hasWillChange)
          ;
        changeSet.set(true);
        this.#updateElementData.queued = false;
      }
      ConvertStringData.process(position, this.#data, el);
      position = this.#updatePosition(position, parent, el, styleCache);
      if (position === null) {
        return this;
      }
    }
    if (Number.isFinite(position.left)) {
      position.left = Math.round(position.left);
      if (data.left !== position.left) {
        data.left = position.left;
        changeSet.left = true;
      }
    }
    if (Number.isFinite(position.top)) {
      position.top = Math.round(position.top);
      if (data.top !== position.top) {
        data.top = position.top;
        changeSet.top = true;
      }
    }
    if (Number.isFinite(position.maxHeight) || position.maxHeight === null) {
      position.maxHeight = typeof position.maxHeight === "number" ? Math.round(position.maxHeight) : null;
      if (data.maxHeight !== position.maxHeight) {
        data.maxHeight = position.maxHeight;
        changeSet.maxHeight = true;
      }
    }
    if (Number.isFinite(position.maxWidth) || position.maxWidth === null) {
      position.maxWidth = typeof position.maxWidth === "number" ? Math.round(position.maxWidth) : null;
      if (data.maxWidth !== position.maxWidth) {
        data.maxWidth = position.maxWidth;
        changeSet.maxWidth = true;
      }
    }
    if (Number.isFinite(position.minHeight) || position.minHeight === null) {
      position.minHeight = typeof position.minHeight === "number" ? Math.round(position.minHeight) : null;
      if (data.minHeight !== position.minHeight) {
        data.minHeight = position.minHeight;
        changeSet.minHeight = true;
      }
    }
    if (Number.isFinite(position.minWidth) || position.minWidth === null) {
      position.minWidth = typeof position.minWidth === "number" ? Math.round(position.minWidth) : null;
      if (data.minWidth !== position.minWidth) {
        data.minWidth = position.minWidth;
        changeSet.minWidth = true;
      }
    }
    if (Number.isFinite(position.rotateX) || position.rotateX === null) {
      if (data.rotateX !== position.rotateX) {
        data.rotateX = transforms.rotateX = position.rotateX;
        changeSet.transform = true;
      }
    }
    if (Number.isFinite(position.rotateY) || position.rotateY === null) {
      if (data.rotateY !== position.rotateY) {
        data.rotateY = transforms.rotateY = position.rotateY;
        changeSet.transform = true;
      }
    }
    if (Number.isFinite(position.rotateZ) || position.rotateZ === null) {
      if (data.rotateZ !== position.rotateZ) {
        data.rotateZ = transforms.rotateZ = position.rotateZ;
        changeSet.transform = true;
      }
    }
    if (Number.isFinite(position.scale) || position.scale === null) {
      position.scale = typeof position.scale === "number" ? clamp(position.scale, 0, 1e3) : null;
      if (data.scale !== position.scale) {
        data.scale = transforms.scale = position.scale;
        changeSet.transform = true;
      }
    }
    if (typeof position.transformOrigin === "string" && TJSTransforms.transformOrigins.includes(
      position.transformOrigin
    ) || position.transformOrigin === null) {
      if (data.transformOrigin !== position.transformOrigin) {
        data.transformOrigin = position.transformOrigin;
        changeSet.transformOrigin = true;
      }
    }
    if (Number.isFinite(position.translateX) || position.translateX === null) {
      if (data.translateX !== position.translateX) {
        data.translateX = transforms.translateX = position.translateX;
        changeSet.transform = true;
      }
    }
    if (Number.isFinite(position.translateY) || position.translateY === null) {
      if (data.translateY !== position.translateY) {
        data.translateY = transforms.translateY = position.translateY;
        changeSet.transform = true;
      }
    }
    if (Number.isFinite(position.translateZ) || position.translateZ === null) {
      if (data.translateZ !== position.translateZ) {
        data.translateZ = transforms.translateZ = position.translateZ;
        changeSet.transform = true;
      }
    }
    if (Number.isFinite(position.zIndex)) {
      position.zIndex = Math.round(position.zIndex);
      if (data.zIndex !== position.zIndex) {
        data.zIndex = position.zIndex;
        changeSet.zIndex = true;
      }
    }
    const widthIsObservable = position.width === "auto" || position.width === "inherit";
    if (Number.isFinite(position.width) || widthIsObservable || position.width === null) {
      position.width = typeof position.width === "number" ? Math.round(position.width) : position.width;
      if (data.width !== position.width) {
        data.width = position.width;
        changeSet.width = true;
      }
    }
    const heightIsObservable = position.height === "auto" || position.height === "inherit";
    if (Number.isFinite(position.height) || heightIsObservable || position.height === null) {
      position.height = typeof position.height === "number" ? Math.round(position.height) : position.height;
      if (data.height !== position.height) {
        data.height = position.height;
        changeSet.height = true;
      }
    }
    const resizeObservable = widthIsObservable || heightIsObservable;
    if (this.#resizeObservable !== resizeObservable) {
      this.#resizeObservable = resizeObservable;
      this.#styleCache.stores.resizeObservable.set(resizeObservable);
    }
    if (el) {
      const defaultData = this.#state.getDefault();
      if (!isObject(defaultData)) {
        this.#state.save({ name: "#defaultData", ...Object.assign({}, data) });
      }
      if (immediateElementUpdate) {
        UpdateElementManager.immediate(el, this.#updateElementData);
        this.#updateElementPromise = Promise.resolve(globalThis.performance.now());
      } else if (!this.#updateElementData.queued) {
        this.#updateElementPromise = UpdateElementManager.add(el, this.#updateElementData);
      }
    } else {
      UpdateElementManager.updateSubscribers(this.#updateElementData);
    }
    return this;
  }
  /**
   * @param {import('svelte/store').Subscriber<Readonly<import('./data/types').Data.TJSPositionData>>} handler -
   *        Callback function that is invoked on update / changes. Receives a readonly copy of the TJSPositionData.
   *
   * @returns {import('svelte/store').Unsubscriber} Unsubscribe function.
   */
  subscribe(handler) {
    this.#subscribers.push(handler);
    handler(Object.assign({}, this.#data));
    return () => {
      const index = this.#subscribers.findIndex((sub) => sub === handler);
      if (index >= 0) {
        this.#subscribers.splice(index, 1);
      }
    };
  }
  /**
   * Provides the {@link Writable} store `update` method. Receive and return a {@link TJSPositionData} instance to
   * update the position state. You may manipulate numeric properties by providing relative adjustments described in
   * {@link TJSPositionDataRelative}.
   *
   * @param {import('svelte/store').Updater<import('./data/types').Data.TJSPositionDataRelative>} updater -
   */
  update(updater) {
    const result = updater(this.get());
    if (!isObject(result)) {
      throw new TypeError(`'result' of 'updater' is not an object.`);
    }
    this.set(result);
  }
  // Internal Implementation ----------------------------------------------------------------------------------------
  /**
   * Temporary data storage for `TJSPosition.#updatePosition`.
   *
   * @type {TJSPositionData}
   */
  static #updateDataCopy = Object.seal(new TJSPositionData());
  /**
   * Temporary data storage for `TJSPosition.#updatePosition`.
   *
   * @type {import('./system/validators/types').ValidatorAPI.ValidationData}
   */
  static #validationData = Object.seal({
    position: void 0,
    parent: void 0,
    el: void 0,
    computed: void 0,
    transforms: void 0,
    height: void 0,
    width: void 0,
    marginLeft: void 0,
    marginTop: void 0,
    maxHeight: void 0,
    maxWidth: void 0,
    minHeight: void 0,
    minWidth: void 0,
    rest: void 0
  });
  /**
   * @param {import('./data/types').Data.TJSPositionDataRelative} data -
   *
   * @param {object} parent -
   *
   * @param {HTMLElement} el -
   *
   * @param {TJSPositionStyleCache} styleCache -
   *
   * @returns {null | import('./data/types').Data.TJSPositionData} Updated position data or null if validation fails.
   */
  #updatePosition({
    // Directly supported parameters
    left,
    top,
    maxWidth,
    maxHeight,
    minWidth,
    minHeight,
    width,
    height,
    rotateX,
    rotateY,
    rotateZ,
    scale,
    transformOrigin,
    translateX,
    translateY,
    translateZ,
    zIndex,
    // Aliased parameters
    rotation,
    ...rest
  } = {}, parent, el, styleCache) {
    let currentPosition = TJSPositionDataUtil.copyData(this.#data, TJSPosition.#updateDataCopy);
    if (width !== void 0 || el.style.width === "") {
      const widthValid = width === null || Number.isFinite(width);
      if (width === "auto" || currentPosition.width === "auto" && !widthValid) {
        currentPosition.width = "auto";
        width = styleCache.offsetWidth;
      } else if (width === "inherit" || currentPosition.width === "inherit" && !widthValid) {
        currentPosition.width = "inherit";
        width = styleCache.offsetWidth;
      } else {
        const newWidth = Number.isFinite(width) ? width : currentPosition.width;
        currentPosition.width = width = Number.isFinite(newWidth) ? Math.round(newWidth) : styleCache.offsetWidth;
      }
    } else {
      width = Number.isFinite(currentPosition.width) ? currentPosition.width : styleCache.offsetWidth;
    }
    if (height !== void 0 || el.style.height === "") {
      const heightValid = height === null || Number.isFinite(height);
      if (height === "auto" || currentPosition.height === "auto" && !heightValid) {
        currentPosition.height = "auto";
        height = styleCache.offsetHeight;
      } else if (height === "inherit" || currentPosition.height === "inherit" && !heightValid) {
        currentPosition.height = "inherit";
        height = styleCache.offsetHeight;
      } else {
        const newHeight = Number.isFinite(height) ? height : currentPosition.height;
        currentPosition.height = height = Number.isFinite(newHeight) ? Math.round(newHeight) : styleCache.offsetHeight;
      }
    } else {
      height = Number.isFinite(currentPosition.height) ? currentPosition.height : styleCache.offsetHeight;
    }
    if (Number.isFinite(left)) {
      currentPosition.left = left;
    } else if (!Number.isFinite(currentPosition.left)) {
      currentPosition.left = typeof this.#options?.initial?.getLeft === "function" ? this.#options.initial.getLeft(width) : 0;
    }
    if (Number.isFinite(top)) {
      currentPosition.top = top;
    } else if (!Number.isFinite(currentPosition.top)) {
      currentPosition.top = typeof this.#options?.initial?.getTop === "function" ? this.#options.initial.getTop(height) : 0;
    }
    if (Number.isFinite(maxHeight) || maxHeight === null) {
      currentPosition.maxHeight = Number.isFinite(maxHeight) ? Math.round(maxHeight) : null;
    }
    if (Number.isFinite(maxWidth) || maxWidth === null) {
      currentPosition.maxWidth = Number.isFinite(maxWidth) ? Math.round(maxWidth) : null;
    }
    if (Number.isFinite(minHeight) || minHeight === null) {
      currentPosition.minHeight = Number.isFinite(minHeight) ? Math.round(minHeight) : null;
    }
    if (Number.isFinite(minWidth) || minWidth === null) {
      currentPosition.minWidth = Number.isFinite(minWidth) ? Math.round(minWidth) : null;
    }
    if (Number.isFinite(rotateX) || rotateX === null) {
      currentPosition.rotateX = rotateX;
    }
    if (Number.isFinite(rotateY) || rotateY === null) {
      currentPosition.rotateY = rotateY;
    }
    if (rotateZ !== currentPosition.rotateZ && (Number.isFinite(rotateZ) || rotateZ === null)) {
      currentPosition.rotateZ = rotateZ;
    } else if (rotation !== currentPosition.rotateZ && (Number.isFinite(rotation) || rotation === null)) {
      currentPosition.rotateZ = rotation;
    }
    if (Number.isFinite(translateX) || translateX === null) {
      currentPosition.translateX = translateX;
    }
    if (Number.isFinite(translateY) || translateY === null) {
      currentPosition.translateY = translateY;
    }
    if (Number.isFinite(translateZ) || translateZ === null) {
      currentPosition.translateZ = translateZ;
    }
    if (Number.isFinite(scale) || scale === null) {
      currentPosition.scale = typeof scale === "number" ? clamp(scale, 0, 1e3) : null;
    }
    if (typeof transformOrigin === "string" || transformOrigin === null) {
      currentPosition.transformOrigin = TJSTransforms.transformOrigins.includes(transformOrigin) ? transformOrigin : null;
    }
    if (Number.isFinite(zIndex) || zIndex === null) {
      currentPosition.zIndex = typeof zIndex === "number" ? Math.round(zIndex) : zIndex;
    }
    const validatorData = this.#validatorData;
    if (this.#validators.enabled && validatorData.length) {
      const validationData = TJSPosition.#validationData;
      validationData.parent = parent;
      validationData.el = el;
      validationData.computed = styleCache.computed;
      validationData.transforms = this.#transforms;
      validationData.height = height;
      validationData.width = width;
      validationData.marginLeft = styleCache.marginLeft;
      validationData.marginTop = styleCache.marginTop;
      validationData.maxHeight = styleCache.maxHeight ?? currentPosition.maxHeight;
      validationData.maxWidth = styleCache.maxWidth ?? currentPosition.maxWidth;
      const isMinimized = parent?.reactive?.minimized ?? false;
      validationData.minHeight = isMinimized ? currentPosition.minHeight ?? 0 : styleCache.minHeight || (currentPosition.minHeight ?? 0);
      validationData.minWidth = isMinimized ? currentPosition.minWidth ?? 0 : styleCache.minWidth || (currentPosition.minWidth ?? 0);
      for (let cntr = 0; cntr < validatorData.length; cntr++) {
        validationData.position = currentPosition;
        validationData.rest = rest;
        currentPosition = validatorData[cntr].validate(validationData);
        if (currentPosition === null) {
          return null;
        }
      }
    }
    return currentPosition;
  }
}
function create_if_block$o(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(
        /*label*/
        ctx[3]
      );
      attr(span, "class", "svelte-acci");
      toggle_class(
        span,
        "has-icon",
        /*icon*/
        ctx[4] !== void 0
      );
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*label*/
      8)
        set_data(
          t,
          /*label*/
          ctx2[3]
        );
      if (dirty & /*icon*/
      16) {
        toggle_class(
          span,
          "has-icon",
          /*icon*/
          ctx2[4] !== void 0
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
__name(create_if_block$o, "create_if_block$o");
function create_fragment$18(ctx) {
  let a;
  let html_tag;
  let html_anchor;
  let a_class_value;
  let applyStyles_action;
  let mounted;
  let dispose;
  let if_block = (
    /*label*/
    ctx[3] && create_if_block$o(ctx)
  );
  return {
    c() {
      a = element("a");
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      if (if_block)
        if_block.c();
      html_tag.a = html_anchor;
      attr(a, "class", a_class_value = "header-button " + /*button*/
      ctx[0].class + " svelte-acci");
      attr(
        a,
        "aria-label",
        /*label*/
        ctx[3]
      );
      attr(a, "tabindex", "0");
      attr(a, "role", "button");
      toggle_class(
        a,
        "keep-minimized",
        /*keepMinimized*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, a, anchor);
      html_tag.m(
        /*icon*/
        ctx[4],
        a
      );
      append(a, html_anchor);
      if (if_block)
        if_block.m(a, null);
      if (!mounted) {
        dispose = [
          listen(a, "click", stop_propagation(prevent_default(
            /*onClick*/
            ctx[5]
          ))),
          listen(a, "contextmenu", stop_propagation(prevent_default(
            /*onContextMenu*/
            ctx[6]
          ))),
          listen(
            a,
            "keydown",
            /*onKeydown*/
            ctx[7]
          ),
          listen(
            a,
            "keyup",
            /*onKeyup*/
            ctx[8]
          ),
          action_destroyer(applyStyles_action = applyStyles.call(
            null,
            a,
            /*styles*/
            ctx[1]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*icon*/
      16)
        html_tag.p(
          /*icon*/
          ctx2[4]
        );
      if (
        /*label*/
        ctx2[3]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$o(ctx2);
          if_block.c();
          if_block.m(a, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*button*/
      1 && a_class_value !== (a_class_value = "header-button " + /*button*/
      ctx2[0].class + " svelte-acci")) {
        attr(a, "class", a_class_value);
      }
      if (dirty & /*label*/
      8) {
        attr(
          a,
          "aria-label",
          /*label*/
          ctx2[3]
        );
      }
      if (applyStyles_action && is_function(applyStyles_action.update) && dirty & /*styles*/
      2)
        applyStyles_action.update.call(
          null,
          /*styles*/
          ctx2[1]
        );
      if (dirty & /*button, keepMinimized*/
      5) {
        toggle_class(
          a,
          "keep-minimized",
          /*keepMinimized*/
          ctx2[2]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(a);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_fragment$18, "create_fragment$18");
const s_REGEX_HTML = /^\s*<.*>$/;
function instance$11($$self, $$props, $$invalidate) {
  let title;
  let icon;
  let label;
  let keepMinimized;
  let keyCode;
  let styles;
  let { button = void 0 } = $$props;
  function onClick(event) {
    const invoke = button?.onPress ?? button?.onclick;
    if (typeof invoke === "function") {
      invoke({ button, event });
      $$invalidate(0, button);
    }
  }
  __name(onClick, "onClick");
  function onContextMenu(event) {
    if (button?.onContextMenu === "function") {
      button.onContextMenu({ button, event });
      $$invalidate(0, button);
    }
  }
  __name(onContextMenu, "onContextMenu");
  function onKeydown(event) {
    if (event.code === keyCode) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  __name(onKeydown, "onKeydown");
  function onKeyup(event) {
    if (event.code === keyCode) {
      const invoke = button.onPress ?? button.onclick;
      if (typeof invoke === "function") {
        invoke({ button, event });
        $$invalidate(0, button);
      }
      event.preventDefault();
      event.stopPropagation();
    }
  }
  __name(onKeyup, "onKeyup");
  $$self.$$set = ($$props2) => {
    if ("button" in $$props2)
      $$invalidate(0, button = $$props2.button);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*button*/
    1) {
      $$invalidate(9, title = isObject(button) && typeof button.title === "string" ? localize(button.title) : "");
    }
    if ($$self.$$.dirty & /*button, title*/
    513) {
      $$invalidate(4, icon = isObject(button) && typeof button.icon !== "string" ? void 0 : s_REGEX_HTML.test(button.icon) ? button.icon : `<i class="${button.icon}" title="${title}"></i>`);
    }
    if ($$self.$$.dirty & /*button*/
    1) {
      $$invalidate(3, label = isObject(button) && typeof button.label === "string" ? localize(button.label) : void 0);
    }
    if ($$self.$$.dirty & /*button*/
    1) {
      $$invalidate(2, keepMinimized = isObject(button) && typeof button.keepMinimized === "boolean" ? button.keepMinimized : false);
    }
    if ($$self.$$.dirty & /*button*/
    1) {
      keyCode = isObject(button) && typeof button.keyCode === "string" ? button.keyCode : "Enter";
    }
    if ($$self.$$.dirty & /*button*/
    1) {
      $$invalidate(1, styles = isObject(button) && isObject(button.styles) ? button.styles : void 0);
    }
  };
  return [
    button,
    styles,
    keepMinimized,
    label,
    icon,
    onClick,
    onContextMenu,
    onKeydown,
    onKeyup,
    title
  ];
}
__name(instance$11, "instance$11");
class TJSHeaderButton extends SvelteComponent {
  static {
    __name(this, "TJSHeaderButton");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$11, create_fragment$18, safe_not_equal, { button: 0 });
  }
  get button() {
    return this.$$.ctx[0];
  }
  set button(button) {
    this.$$set({ button });
    flush();
  }
}
function get_each_context$h(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[31] = list[i];
  return child_ctx;
}
__name(get_each_context$h, "get_each_context$h");
function get_each_context_1$4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[31] = list[i];
  return child_ctx;
}
__name(get_each_context_1$4, "get_each_context_1$4");
function create_if_block$n(ctx) {
  let img;
  let img_src_value;
  return {
    c() {
      img = element("img");
      attr(img, "class", "tjs-app-icon keep-minimized svelte-5lh4qo");
      if (!src_url_equal(img.src, img_src_value = /*$storeHeaderIcon*/
      ctx[6]))
        attr(img, "src", img_src_value);
      attr(img, "alt", "icon");
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$storeHeaderIcon*/
      64 && !src_url_equal(img.src, img_src_value = /*$storeHeaderIcon*/
      ctx2[6])) {
        attr(img, "src", img_src_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
__name(create_if_block$n, "create_if_block$n");
function create_each_block_1$4(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*button*/
    ctx[31].props
  ];
  var switch_value = (
    /*button*/
    ctx[31].class
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    if (dirty !== void 0 && dirty[0] & /*buttonsLeft*/
    2) {
      switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*button*/
        ctx2[31].props
      )]));
    }
    return { props: switch_instance_props };
  }
  __name(switch_props, "switch_props");
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*buttonsLeft*/
      2 && switch_value !== (switch_value = /*button*/
      ctx2[31].class)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty[0] & /*buttonsLeft*/
        2 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*button*/
          ctx2[31].props
        )]) : {};
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
__name(create_each_block_1$4, "create_each_block_1$4");
function create_each_block$h(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*button*/
    ctx[31].props
  ];
  var switch_value = (
    /*button*/
    ctx[31].class
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    if (dirty !== void 0 && dirty[0] & /*buttonsRight*/
    4) {
      switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*button*/
        ctx2[31].props
      )]));
    }
    return { props: switch_instance_props };
  }
  __name(switch_props, "switch_props");
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*buttonsRight*/
      4 && switch_value !== (switch_value = /*button*/
      ctx2[31].class)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty[0] & /*buttonsRight*/
        4 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*button*/
          ctx2[31].props
        )]) : {};
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
__name(create_each_block$h, "create_each_block$h");
function create_key_block(ctx) {
  let header;
  let t0;
  let h4;
  let t1_value = localize(
    /*$storeTitle*/
    ctx[7]
  ) + "";
  let t1;
  let t2;
  let t3;
  let span;
  let t4;
  let draggable_action;
  let minimizable_action;
  let current;
  let mounted;
  let dispose;
  let if_block = typeof /*$storeHeaderIcon*/
  ctx[6] === "string" && create_if_block$n(ctx);
  let each_value_1 = ensure_array_like(
    /*buttonsLeft*/
    ctx[1]
  );
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks_1[i] = create_each_block_1$4(get_each_context_1$4(ctx, each_value_1, i));
  }
  const out = /* @__PURE__ */ __name((i) => transition_out(each_blocks_1[i], 1, 1, () => {
    each_blocks_1[i] = null;
  }), "out");
  let each_value = ensure_array_like(
    /*buttonsRight*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$h(get_each_context$h(ctx, each_value, i));
  }
  const out_1 = /* @__PURE__ */ __name((i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  }), "out_1");
  return {
    c() {
      header = element("header");
      if (if_block)
        if_block.c();
      t0 = space();
      h4 = element("h4");
      t1 = text(t1_value);
      t2 = space();
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t3 = space();
      span = element("span");
      t4 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(h4, "class", "window-title svelte-5lh4qo");
      set_style(
        h4,
        "display",
        /*displayHeaderTitle*/
        ctx[4]
      );
      attr(span, "class", "tjs-window-header-spacer keep-minimized svelte-5lh4qo");
      attr(header, "class", "window-header flexrow svelte-5lh4qo");
    },
    m(target, anchor) {
      insert(target, header, anchor);
      if (if_block)
        if_block.m(header, null);
      append(header, t0);
      append(header, h4);
      append(h4, t1);
      append(header, t2);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(header, null);
        }
      }
      append(header, t3);
      append(header, span);
      append(header, t4);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(header, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            header,
            "pointerdown",
            /*onPointerdown*/
            ctx[19]
          ),
          action_destroyer(draggable_action = /*draggable*/
          ctx[0].call(
            null,
            header,
            /*dragOptions*/
            ctx[3]
          )),
          action_destroyer(minimizable_action = /*minimizable*/
          ctx[18].call(
            null,
            header,
            /*$storeMinimizable*/
            ctx[5]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (typeof /*$storeHeaderIcon*/
      ctx2[6] === "string") {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$n(ctx2);
          if_block.c();
          if_block.m(header, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if ((!current || dirty[0] & /*$storeTitle*/
      128) && t1_value !== (t1_value = localize(
        /*$storeTitle*/
        ctx2[7]
      ) + ""))
        set_data(t1, t1_value);
      if (dirty[0] & /*displayHeaderTitle*/
      16) {
        set_style(
          h4,
          "display",
          /*displayHeaderTitle*/
          ctx2[4]
        );
      }
      if (dirty[0] & /*buttonsLeft*/
      2) {
        each_value_1 = ensure_array_like(
          /*buttonsLeft*/
          ctx2[1]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1$4(ctx2, each_value_1, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
            transition_in(each_blocks_1[i], 1);
          } else {
            each_blocks_1[i] = create_each_block_1$4(child_ctx);
            each_blocks_1[i].c();
            transition_in(each_blocks_1[i], 1);
            each_blocks_1[i].m(header, t3);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks_1.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (dirty[0] & /*buttonsRight*/
      4) {
        each_value = ensure_array_like(
          /*buttonsRight*/
          ctx2[2]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$h(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$h(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(header, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out_1(i);
        }
        check_outros();
      }
      if (draggable_action && is_function(draggable_action.update) && dirty[0] & /*dragOptions*/
      8)
        draggable_action.update.call(
          null,
          /*dragOptions*/
          ctx2[3]
        );
      if (minimizable_action && is_function(minimizable_action.update) && dirty[0] & /*$storeMinimizable*/
      32)
        minimizable_action.update.call(
          null,
          /*$storeMinimizable*/
          ctx2[5]
        );
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks_1[i]);
      }
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks_1 = each_blocks_1.filter(Boolean);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        transition_out(each_blocks_1[i]);
      }
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(header);
      }
      if (if_block)
        if_block.d();
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_key_block, "create_key_block");
function create_fragment$17(ctx) {
  let previous_key = (
    /*draggable*/
    ctx[0]
  );
  let key_block_anchor;
  let current;
  let key_block = create_key_block(ctx);
  return {
    c() {
      key_block.c();
      key_block_anchor = empty();
    },
    m(target, anchor) {
      key_block.m(target, anchor);
      insert(target, key_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*draggable*/
      1 && safe_not_equal(previous_key, previous_key = /*draggable*/
      ctx2[0])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(key_block_anchor);
      }
      key_block.d(detaching);
    }
  };
}
__name(create_fragment$17, "create_fragment$17");
function instance$10($$self, $$props, $$invalidate) {
  let $focusKeep;
  let $focusAuto;
  let $elementRoot;
  let $storeHeaderButtons;
  let $storeMinimized;
  let $storeHeaderNoTitleMinimized;
  let $storeDraggable;
  let $storeMinimizable;
  let $storeHeaderIcon;
  let $storeTitle;
  let { draggable: draggable$1 = void 0 } = $$props;
  let { draggableOptions = void 0 } = $$props;
  const application = getContext("#external")?.application;
  const { focusAuto, focusKeep } = application.reactive.storeAppOptions;
  component_subscribe($$self, focusAuto, (value) => $$invalidate(26, $focusAuto = value));
  component_subscribe($$self, focusKeep, (value) => $$invalidate(25, $focusKeep = value));
  const { elementRoot } = getContext("#internal").stores;
  component_subscribe($$self, elementRoot, (value) => $$invalidate(27, $elementRoot = value));
  const storeTitle = application.reactive.storeAppOptions.title;
  component_subscribe($$self, storeTitle, (value) => $$invalidate(7, $storeTitle = value));
  const storeDraggable = application.reactive.storeAppOptions.draggable;
  component_subscribe($$self, storeDraggable, (value) => $$invalidate(24, $storeDraggable = value));
  const storeDragging = application.reactive.storeUIState.dragging;
  const storeHeaderButtons = application.reactive.storeUIState.headerButtons;
  component_subscribe($$self, storeHeaderButtons, (value) => $$invalidate(21, $storeHeaderButtons = value));
  const storeHeaderIcon = application.reactive.storeAppOptions.headerIcon;
  component_subscribe($$self, storeHeaderIcon, (value) => $$invalidate(6, $storeHeaderIcon = value));
  const storeHeaderNoTitleMinimized = application.reactive.storeAppOptions.headerNoTitleMinimized;
  component_subscribe($$self, storeHeaderNoTitleMinimized, (value) => $$invalidate(23, $storeHeaderNoTitleMinimized = value));
  const storeMinimizable = application.reactive.storeAppOptions.minimizable;
  component_subscribe($$self, storeMinimizable, (value) => $$invalidate(5, $storeMinimizable = value));
  const storeMinimized = application.reactive.storeUIState.minimized;
  component_subscribe($$self, storeMinimized, (value) => $$invalidate(22, $storeMinimized = value));
  const s_DRAG_TARGET_CLASSLIST = Object.freeze(["tjs-app-icon", "tjs-window-header-spacer", "window-header", "window-title"]);
  let dragOptions;
  let displayHeaderTitle;
  let buttonsLeft;
  let buttonsRight;
  function minimizable(node, booleanStore) {
    const callback = /* @__PURE__ */ __name((event) => {
      if (event.target.classList.contains("window-title") || event.target.classList.contains("window-header") || event.target.classList.contains("keep-minimized")) {
        application._onToggleMinimize(event);
      }
    }, "callback");
    function activateListeners() {
      node.addEventListener("dblclick", callback);
    }
    __name(activateListeners, "activateListeners");
    function removeListeners() {
      node.removeEventListener("dblclick", callback);
    }
    __name(removeListeners, "removeListeners");
    if (booleanStore) {
      activateListeners();
    }
    return {
      update: (booleanStore2) => {
        if (booleanStore2) {
          activateListeners();
        } else {
          removeListeners();
        }
      },
      destroy: () => removeListeners()
    };
  }
  __name(minimizable, "minimizable");
  function onPointerdown(event) {
    const rootEl = $elementRoot;
    application.position.animate.cancel();
    if ($focusAuto && A11yHelper.isFocusTarget(rootEl) && rootEl?.isConnected) {
      if ($focusKeep) {
        const activeWindow = application.reactive.activeWindow;
        const focusOutside = A11yHelper.isFocusTarget(activeWindow.document.activeElement) && !rootEl.contains(activeWindow.document.activeElement);
        if (focusOutside) {
          rootEl.focus();
        } else {
          event.preventDefault();
        }
      } else {
        rootEl.focus();
      }
    }
  }
  __name(onPointerdown, "onPointerdown");
  $$self.$$set = ($$props2) => {
    if ("draggable" in $$props2)
      $$invalidate(0, draggable$1 = $$props2.draggable);
    if ("draggableOptions" in $$props2)
      $$invalidate(20, draggableOptions = $$props2.draggableOptions);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*draggable*/
    1) {
      $$invalidate(0, draggable$1 = typeof draggable$1 === "function" ? draggable$1 : draggable);
    }
    if ($$self.$$.dirty[0] & /*draggableOptions, $storeDraggable*/
    17825792) {
      $$invalidate(3, dragOptions = Object.assign(
        {},
        {
          tween: true,
          tweenOptions: { duration: 0.06, ease: "cubicOut" }
        },
        isObject(draggableOptions) ? draggableOptions : {},
        {
          position: application.position,
          enabled: $storeDraggable,
          storeDragging,
          hasTargetClassList: s_DRAG_TARGET_CLASSLIST
        }
      ));
    }
    if ($$self.$$.dirty[0] & /*$storeHeaderNoTitleMinimized, $storeMinimized*/
    12582912) {
      $$invalidate(4, displayHeaderTitle = $storeHeaderNoTitleMinimized && $storeMinimized ? "none" : null);
    }
    if ($$self.$$.dirty[0] & /*$storeHeaderButtons, buttonsLeft, buttonsRight*/
    2097158) {
      {
        $$invalidate(1, buttonsLeft = []);
        $$invalidate(2, buttonsRight = []);
        for (const button of $storeHeaderButtons) {
          const buttonsList = typeof button?.alignLeft === "boolean" && button?.alignLeft ? buttonsLeft : buttonsRight;
          buttonsList.push(TJSSvelteConfigUtil.isConfig(button?.svelte) ? { ...button.svelte } : {
            class: TJSHeaderButton,
            props: { button }
          });
        }
      }
    }
  };
  return [
    draggable$1,
    buttonsLeft,
    buttonsRight,
    dragOptions,
    displayHeaderTitle,
    $storeMinimizable,
    $storeHeaderIcon,
    $storeTitle,
    focusAuto,
    focusKeep,
    elementRoot,
    storeTitle,
    storeDraggable,
    storeHeaderButtons,
    storeHeaderIcon,
    storeHeaderNoTitleMinimized,
    storeMinimizable,
    storeMinimized,
    minimizable,
    onPointerdown,
    draggableOptions,
    $storeHeaderButtons,
    $storeMinimized,
    $storeHeaderNoTitleMinimized,
    $storeDraggable
  ];
}
__name(instance$10, "instance$10");
class TJSApplicationHeader extends SvelteComponent {
  static {
    __name(this, "TJSApplicationHeader");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$10, create_fragment$17, safe_not_equal, { draggable: 0, draggableOptions: 20 }, null, [-1, -1]);
  }
}
function create_fragment$16(ctx) {
  let div;
  let resizable_action;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<i class="fas fa-arrows-alt-h svelte-gtiiil"></i>`;
      attr(div, "class", "window-resizable-handle svelte-gtiiil");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      ctx[11](div);
      if (!mounted) {
        dispose = [
          listen(
            div,
            "pointerdown",
            /*onPointerdown*/
            ctx[6]
          ),
          action_destroyer(resizable_action = /*resizable*/
          ctx[7].call(null, div, {
            active: (
              /*$storeResizable*/
              ctx[1]
            ),
            storeResizing: (
              /*storeResizing*/
              ctx[5]
            )
          }))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (resizable_action && is_function(resizable_action.update) && dirty & /*$storeResizable*/
      2)
        resizable_action.update.call(null, {
          active: (
            /*$storeResizable*/
            ctx2[1]
          ),
          storeResizing: (
            /*storeResizing*/
            ctx2[5]
          )
        });
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      ctx[11](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_fragment$16, "create_fragment$16");
function instance$$($$self, $$props, $$invalidate) {
  let $storeElementRoot;
  let $storeMinimized;
  let $storeResizable;
  let { isResizable = false } = $$props;
  const application = getContext("#external")?.application;
  const storeElementRoot = getContext("#internal").stores.elementRoot;
  component_subscribe($$self, storeElementRoot, (value) => $$invalidate(9, $storeElementRoot = value));
  const storeResizable = application.reactive.storeAppOptions.resizable;
  component_subscribe($$self, storeResizable, (value) => $$invalidate(1, $storeResizable = value));
  const storeMinimized = application.reactive.storeUIState.minimized;
  component_subscribe($$self, storeMinimized, (value) => $$invalidate(10, $storeMinimized = value));
  const storeResizing = application.reactive.storeUIState.resizing;
  let elementResize;
  function onPointerdown() {
    application.position.animate.cancel();
  }
  __name(onPointerdown, "onPointerdown");
  function resizable(node, { active: active2 = true, storeResizing: storeResizing2 = void 0 } = {}) {
    let position = null;
    let initialPosition = {};
    let resizing = false;
    const handlers = {
      resizeDown: ["pointerdown", (e) => onResizePointerDown(e), false],
      resizeMove: ["pointermove", (e) => onResizePointerMove(e), false],
      resizeUp: ["pointerup", (e) => onResizePointerUp(e), false]
    };
    function activateListeners() {
      node.addEventListener(...handlers.resizeDown);
      $$invalidate(8, isResizable = true);
      node.style.display = "block";
    }
    __name(activateListeners, "activateListeners");
    function removeListeners() {
      if (typeof storeResizing2?.set === "function") {
        storeResizing2.set(false);
      }
      node.removeEventListener(...handlers.resizeDown);
      node.removeEventListener(...handlers.resizeMove);
      node.removeEventListener(...handlers.resizeUp);
      node.style.display = "none";
      $$invalidate(8, isResizable = false);
    }
    __name(removeListeners, "removeListeners");
    if (active2) {
      activateListeners();
    } else {
      node.style.display = "none";
    }
    function onResizePointerDown(event) {
      event.preventDefault();
      resizing = false;
      position = application.position.get();
      if (position.height === "auto") {
        position.height = $storeElementRoot.clientHeight;
      }
      if (position.width === "auto") {
        position.width = $storeElementRoot.clientWidth;
      }
      initialPosition = { x: event.clientX, y: event.clientY };
      node.addEventListener(...handlers.resizeMove);
      node.addEventListener(...handlers.resizeUp);
      node.setPointerCapture(event.pointerId);
    }
    __name(onResizePointerDown, "onResizePointerDown");
    function onResizePointerMove(event) {
      event.preventDefault();
      if (!resizing && typeof storeResizing2?.set === "function") {
        resizing = true;
        storeResizing2.set(true);
      }
      application.position.set({
        width: position.width + (event.clientX - initialPosition.x),
        height: position.height + (event.clientY - initialPosition.y)
      });
    }
    __name(onResizePointerMove, "onResizePointerMove");
    function onResizePointerUp(event) {
      resizing = false;
      if (typeof storeResizing2?.set === "function") {
        storeResizing2.set(false);
      }
      event.preventDefault();
      node.removeEventListener(...handlers.resizeMove);
      node.removeEventListener(...handlers.resizeUp);
      application?._onResize?.(event);
    }
    __name(onResizePointerUp, "onResizePointerUp");
    return {
      update: ({ active: active3 }) => {
        if (active3) {
          activateListeners();
        } else {
          removeListeners();
        }
      },
      destroy: () => removeListeners()
    };
  }
  __name(resizable, "resizable");
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elementResize = $$value;
      $$invalidate(0, elementResize), $$invalidate(8, isResizable), $$invalidate(10, $storeMinimized), $$invalidate(9, $storeElementRoot);
    });
  }
  __name(div_binding, "div_binding");
  $$self.$$set = ($$props2) => {
    if ("isResizable" in $$props2)
      $$invalidate(8, isResizable = $$props2.isResizable);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*elementResize, isResizable, $storeMinimized, $storeElementRoot*/
    1793) {
      if (elementResize) {
        $$invalidate(0, elementResize.style.display = isResizable && !$storeMinimized ? "block" : "none", elementResize);
        const elementRoot = $storeElementRoot;
        if (elementRoot) {
          elementRoot.classList[isResizable ? "add" : "remove"]("resizable");
        }
      }
    }
  };
  return [
    elementResize,
    $storeResizable,
    storeElementRoot,
    storeResizable,
    storeMinimized,
    storeResizing,
    onPointerdown,
    resizable,
    isResizable,
    $storeElementRoot,
    $storeMinimized,
    div_binding
  ];
}
__name(instance$$, "instance$$");
class ResizableHandle extends SvelteComponent {
  static {
    __name(this, "ResizableHandle");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$$, create_fragment$16, safe_not_equal, { isResizable: 8 });
  }
}
function create_fragment$15(ctx) {
  let div;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      attr(div, "class", "tjs-focus-wrap svelte-kjcljd");
      attr(div, "tabindex", "0");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      ctx[4](div);
      if (!mounted) {
        dispose = listen(
          div,
          "focus",
          /*onFocus*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      ctx[4](null);
      mounted = false;
      dispose();
    }
  };
}
__name(create_fragment$15, "create_fragment$15");
function instance$_($$self, $$props, $$invalidate) {
  let { elementRoot = void 0 } = $$props;
  let { enabled = true } = $$props;
  let ignoreElements, wrapEl;
  function onFocus() {
    if (!enabled) {
      return;
    }
    if (A11yHelper.isFocusTarget(elementRoot)) {
      const firstFocusEl = A11yHelper.getFirstFocusableElement(elementRoot, ignoreElements);
      if (A11yHelper.isFocusTarget(firstFocusEl) && firstFocusEl !== wrapEl) {
        firstFocusEl.focus();
      } else {
        elementRoot.focus();
      }
    }
  }
  __name(onFocus, "onFocus");
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      wrapEl = $$value;
      $$invalidate(0, wrapEl);
    });
  }
  __name(div_binding, "div_binding");
  $$self.$$set = ($$props2) => {
    if ("elementRoot" in $$props2)
      $$invalidate(2, elementRoot = $$props2.elementRoot);
    if ("enabled" in $$props2)
      $$invalidate(3, enabled = $$props2.enabled);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*wrapEl*/
    1) {
      if (wrapEl) {
        ignoreElements = /* @__PURE__ */ new Set([wrapEl]);
      }
    }
  };
  return [wrapEl, onFocus, elementRoot, enabled, div_binding];
}
__name(instance$_, "instance$_");
class TJSFocusWrap extends SvelteComponent {
  static {
    __name(this, "TJSFocusWrap");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$_, create_fragment$15, safe_not_equal, { elementRoot: 2, enabled: 3 });
  }
}
function create_else_block$4(ctx) {
  let div;
  let tjsapplicationheader;
  let t0;
  let section;
  let applyStyles_action;
  let t1;
  let resizablehandle;
  let t2;
  let tjsfocuswrap;
  let div_id_value;
  let div_class_value;
  let div_data_appid_value;
  let applyStyles_action_1;
  let dynamicAction_action;
  let current;
  let mounted;
  let dispose;
  tjsapplicationheader = new TJSApplicationHeader({
    props: {
      draggable: (
        /*draggable*/
        ctx[6]
      ),
      draggableOptions: (
        /*draggableOptions*/
        ctx[7]
      )
    }
  });
  const default_slot_template = (
    /*#slots*/
    ctx[37].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[36],
    null
  );
  resizablehandle = new ResizableHandle({});
  tjsfocuswrap = new TJSFocusWrap({
    props: {
      elementRoot: (
        /*elementRoot*/
        ctx[1]
      ),
      enabled: (
        /*focusWrapEnabled*/
        ctx[11]
      )
    }
  });
  return {
    c() {
      div = element("div");
      create_component(tjsapplicationheader.$$.fragment);
      t0 = space();
      section = element("section");
      if (default_slot)
        default_slot.c();
      t1 = space();
      create_component(resizablehandle.$$.fragment);
      t2 = space();
      create_component(tjsfocuswrap.$$.fragment);
      attr(section, "class", "window-content svelte-90z1oq");
      attr(section, "tabindex", "-1");
      attr(div, "id", div_id_value = /*application*/
      ctx[10].id);
      attr(div, "class", div_class_value = "app window-app " + /*application*/
      ctx[10].options.classes.join(" ") + " svelte-90z1oq");
      attr(div, "data-appid", div_data_appid_value = /*application*/
      ctx[10].appId);
      attr(div, "role", "application");
      attr(div, "tabindex", "-1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(tjsapplicationheader, div, null);
      append(div, t0);
      append(div, section);
      if (default_slot) {
        default_slot.m(section, null);
      }
      ctx[40](section);
      append(div, t1);
      mount_component(resizablehandle, div, null);
      append(div, t2);
      mount_component(tjsfocuswrap, div, null);
      ctx[41](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            section,
            "pointerdown",
            /*onPointerdownContent*/
            ctx[22]
          ),
          action_destroyer(applyStyles_action = applyStyles.call(
            null,
            section,
            /*stylesContent*/
            ctx[9]
          )),
          action_destroyer(
            /*contentResizeObserver*/
            ctx[18].call(
              null,
              section,
              /*resizeObservedContent*/
              ctx[23]
            )
          ),
          listen(div, "close:popup", stop_propagation(prevent_default(
            /*onClosePopup*/
            ctx[19]
          ))),
          listen(
            div,
            "keydown",
            /*onKeydown*/
            ctx[20]
          ),
          listen(
            div,
            "pointerdown",
            /*onPointerdownApp*/
            ctx[21],
            true
          ),
          action_destroyer(applyStyles_action_1 = applyStyles.call(
            null,
            div,
            /*stylesApp*/
            ctx[8]
          )),
          action_destroyer(dynamicAction_action = dynamicAction.call(
            null,
            div,
            /*appResizeObserver*/
            ctx[12]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const tjsapplicationheader_changes = {};
      if (dirty[0] & /*draggable*/
      64)
        tjsapplicationheader_changes.draggable = /*draggable*/
        ctx2[6];
      if (dirty[0] & /*draggableOptions*/
      128)
        tjsapplicationheader_changes.draggableOptions = /*draggableOptions*/
        ctx2[7];
      tjsapplicationheader.$set(tjsapplicationheader_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[36],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[36]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[36],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (applyStyles_action && is_function(applyStyles_action.update) && dirty[0] & /*stylesContent*/
      512)
        applyStyles_action.update.call(
          null,
          /*stylesContent*/
          ctx2[9]
        );
      const tjsfocuswrap_changes = {};
      if (dirty[0] & /*elementRoot*/
      2)
        tjsfocuswrap_changes.elementRoot = /*elementRoot*/
        ctx2[1];
      if (dirty[0] & /*focusWrapEnabled*/
      2048)
        tjsfocuswrap_changes.enabled = /*focusWrapEnabled*/
        ctx2[11];
      tjsfocuswrap.$set(tjsfocuswrap_changes);
      if (!current || dirty[0] & /*application*/
      1024 && div_id_value !== (div_id_value = /*application*/
      ctx2[10].id)) {
        attr(div, "id", div_id_value);
      }
      if (!current || dirty[0] & /*application*/
      1024 && div_class_value !== (div_class_value = "app window-app " + /*application*/
      ctx2[10].options.classes.join(" ") + " svelte-90z1oq")) {
        attr(div, "class", div_class_value);
      }
      if (!current || dirty[0] & /*application*/
      1024 && div_data_appid_value !== (div_data_appid_value = /*application*/
      ctx2[10].appId)) {
        attr(div, "data-appid", div_data_appid_value);
      }
      if (applyStyles_action_1 && is_function(applyStyles_action_1.update) && dirty[0] & /*stylesApp*/
      256)
        applyStyles_action_1.update.call(
          null,
          /*stylesApp*/
          ctx2[8]
        );
      if (dynamicAction_action && is_function(dynamicAction_action.update) && dirty[0] & /*appResizeObserver*/
      4096)
        dynamicAction_action.update.call(
          null,
          /*appResizeObserver*/
          ctx2[12]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(tjsapplicationheader.$$.fragment, local);
      transition_in(default_slot, local);
      transition_in(resizablehandle.$$.fragment, local);
      transition_in(tjsfocuswrap.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjsapplicationheader.$$.fragment, local);
      transition_out(default_slot, local);
      transition_out(resizablehandle.$$.fragment, local);
      transition_out(tjsfocuswrap.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(tjsapplicationheader);
      if (default_slot)
        default_slot.d(detaching);
      ctx[40](null);
      destroy_component(resizablehandle);
      destroy_component(tjsfocuswrap);
      ctx[41](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_else_block$4, "create_else_block$4");
function create_if_block$m(ctx) {
  let div;
  let tjsapplicationheader;
  let t0;
  let section;
  let applyStyles_action;
  let t1;
  let resizablehandle;
  let t2;
  let tjsfocuswrap;
  let div_id_value;
  let div_class_value;
  let div_data_appid_value;
  let applyStyles_action_1;
  let dynamicAction_action;
  let div_intro;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  tjsapplicationheader = new TJSApplicationHeader({
    props: {
      draggable: (
        /*draggable*/
        ctx[6]
      ),
      draggableOptions: (
        /*draggableOptions*/
        ctx[7]
      )
    }
  });
  const default_slot_template = (
    /*#slots*/
    ctx[37].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[36],
    null
  );
  resizablehandle = new ResizableHandle({});
  tjsfocuswrap = new TJSFocusWrap({
    props: { elementRoot: (
      /*elementRoot*/
      ctx[1]
    ) }
  });
  return {
    c() {
      div = element("div");
      create_component(tjsapplicationheader.$$.fragment);
      t0 = space();
      section = element("section");
      if (default_slot)
        default_slot.c();
      t1 = space();
      create_component(resizablehandle.$$.fragment);
      t2 = space();
      create_component(tjsfocuswrap.$$.fragment);
      attr(section, "class", "window-content svelte-90z1oq");
      attr(section, "tabindex", "-1");
      attr(div, "id", div_id_value = /*application*/
      ctx[10].id);
      attr(div, "class", div_class_value = "app window-app " + /*application*/
      ctx[10].options.classes.join(" ") + " svelte-90z1oq");
      attr(div, "data-appid", div_data_appid_value = /*application*/
      ctx[10].appId);
      attr(div, "role", "application");
      attr(div, "tabindex", "-1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(tjsapplicationheader, div, null);
      append(div, t0);
      append(div, section);
      if (default_slot) {
        default_slot.m(section, null);
      }
      ctx[38](section);
      append(div, t1);
      mount_component(resizablehandle, div, null);
      append(div, t2);
      mount_component(tjsfocuswrap, div, null);
      ctx[39](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            section,
            "pointerdown",
            /*onPointerdownContent*/
            ctx[22]
          ),
          action_destroyer(applyStyles_action = applyStyles.call(
            null,
            section,
            /*stylesContent*/
            ctx[9]
          )),
          action_destroyer(
            /*contentResizeObserver*/
            ctx[18].call(
              null,
              section,
              /*resizeObservedContent*/
              ctx[23]
            )
          ),
          listen(div, "close:popup", stop_propagation(prevent_default(
            /*onClosePopup*/
            ctx[19]
          ))),
          listen(
            div,
            "keydown",
            /*onKeydown*/
            ctx[20]
          ),
          listen(
            div,
            "pointerdown",
            /*onPointerdownApp*/
            ctx[21],
            true
          ),
          action_destroyer(applyStyles_action_1 = applyStyles.call(
            null,
            div,
            /*stylesApp*/
            ctx[8]
          )),
          action_destroyer(dynamicAction_action = dynamicAction.call(
            null,
            div,
            /*appResizeObserver*/
            ctx[12]
          ))
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const tjsapplicationheader_changes = {};
      if (dirty[0] & /*draggable*/
      64)
        tjsapplicationheader_changes.draggable = /*draggable*/
        ctx[6];
      if (dirty[0] & /*draggableOptions*/
      128)
        tjsapplicationheader_changes.draggableOptions = /*draggableOptions*/
        ctx[7];
      tjsapplicationheader.$set(tjsapplicationheader_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[36],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[36]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[36],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (applyStyles_action && is_function(applyStyles_action.update) && dirty[0] & /*stylesContent*/
      512)
        applyStyles_action.update.call(
          null,
          /*stylesContent*/
          ctx[9]
        );
      const tjsfocuswrap_changes = {};
      if (dirty[0] & /*elementRoot*/
      2)
        tjsfocuswrap_changes.elementRoot = /*elementRoot*/
        ctx[1];
      tjsfocuswrap.$set(tjsfocuswrap_changes);
      if (!current || dirty[0] & /*application*/
      1024 && div_id_value !== (div_id_value = /*application*/
      ctx[10].id)) {
        attr(div, "id", div_id_value);
      }
      if (!current || dirty[0] & /*application*/
      1024 && div_class_value !== (div_class_value = "app window-app " + /*application*/
      ctx[10].options.classes.join(" ") + " svelte-90z1oq")) {
        attr(div, "class", div_class_value);
      }
      if (!current || dirty[0] & /*application*/
      1024 && div_data_appid_value !== (div_data_appid_value = /*application*/
      ctx[10].appId)) {
        attr(div, "data-appid", div_data_appid_value);
      }
      if (applyStyles_action_1 && is_function(applyStyles_action_1.update) && dirty[0] & /*stylesApp*/
      256)
        applyStyles_action_1.update.call(
          null,
          /*stylesApp*/
          ctx[8]
        );
      if (dynamicAction_action && is_function(dynamicAction_action.update) && dirty[0] & /*appResizeObserver*/
      4096)
        dynamicAction_action.update.call(
          null,
          /*appResizeObserver*/
          ctx[12]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(tjsapplicationheader.$$.fragment, local);
      transition_in(default_slot, local);
      transition_in(resizablehandle.$$.fragment, local);
      transition_in(tjsfocuswrap.$$.fragment, local);
      add_render_callback(() => {
        if (!current)
          return;
        if (div_outro)
          div_outro.end(1);
        div_intro = create_in_transition(
          div,
          /*inTransition*/
          ctx[2],
          /*inTransitionOptions*/
          ctx[4]
        );
        div_intro.start();
      });
      current = true;
    },
    o(local) {
      transition_out(tjsapplicationheader.$$.fragment, local);
      transition_out(default_slot, local);
      transition_out(resizablehandle.$$.fragment, local);
      transition_out(tjsfocuswrap.$$.fragment, local);
      if (div_intro)
        div_intro.invalidate();
      div_outro = create_out_transition(
        div,
        /*outTransition*/
        ctx[3],
        /*outTransitionOptions*/
        ctx[5]
      );
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(tjsapplicationheader);
      if (default_slot)
        default_slot.d(detaching);
      ctx[38](null);
      destroy_component(resizablehandle);
      destroy_component(tjsfocuswrap);
      ctx[39](null);
      if (detaching && div_outro)
        div_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_if_block$m, "create_if_block$m");
function create_fragment$14(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$m, create_else_block$4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*inTransition*/
      ctx2[2] !== TJSDefaultTransition.default || /*outTransition*/
      ctx2[3] !== TJSDefaultTransition.default
    )
      return 0;
    return 1;
  }
  __name(select_block_type, "select_block_type");
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
__name(create_fragment$14, "create_fragment$14");
function instance$Z($$self, $$props, $$invalidate) {
  let appResizeObserver;
  let $focusKeep;
  let $focusAuto;
  let $minimized;
  let $focusTrap;
  let $resizeObservable;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { elementContent = void 0 } = $$props;
  let { elementRoot = void 0 } = $$props;
  let { draggable: draggable2 = void 0 } = $$props;
  let { draggableOptions = void 0 } = $$props;
  let { stylesApp = void 0 } = $$props;
  let { stylesContent = void 0 } = $$props;
  const application = getContext("#external")?.application;
  const { focusAuto, focusKeep, focusTrap } = application.reactive.storeAppOptions;
  component_subscribe($$self, focusAuto, (value) => $$invalidate(32, $focusAuto = value));
  component_subscribe($$self, focusKeep, (value) => $$invalidate(42, $focusKeep = value));
  component_subscribe($$self, focusTrap, (value) => $$invalidate(34, $focusTrap = value));
  const { minimized } = application.reactive.storeUIState;
  component_subscribe($$self, minimized, (value) => $$invalidate(33, $minimized = value));
  const { resizeObservable } = application.position.stores;
  component_subscribe($$self, resizeObservable, (value) => $$invalidate(35, $resizeObservable = value));
  let { appOffsetHeight = false } = $$props;
  let { appOffsetWidth = false } = $$props;
  const initialAppResizeObserver = !!appOffsetHeight || !!appOffsetWidth;
  let { contentOffsetHeight = false } = $$props;
  let { contentOffsetWidth = false } = $$props;
  const contentResizeObserver = !!contentOffsetHeight || !!contentOffsetWidth ? resizeObserver : () => null;
  const internal = new AppShellContextInternal();
  const s_IGNORE_CLASSES = { ignoreClasses: ["tjs-focus-wrap"] };
  setContext("#internal", internal);
  let focusWrapEnabled;
  let { transition = TJSDefaultTransition.default } = $$props;
  let { inTransition = TJSDefaultTransition.default } = $$props;
  let { outTransition = TJSDefaultTransition.default } = $$props;
  let { transitionOptions = void 0 } = $$props;
  let { inTransitionOptions = TJSDefaultTransition.options } = $$props;
  let { outTransitionOptions = TJSDefaultTransition.options } = $$props;
  let oldTransition = TJSDefaultTransition.default;
  let oldTransitionOptions = void 0;
  onMount(() => elementRoot.focus());
  function onClosePopup(event) {
    if (!$focusAuto) {
      return;
    }
    const targetEl = event?.detail?.target;
    if (!A11yHelper.isFocusTarget(targetEl)) {
      return;
    }
    if (A11yHelper.isFocusable(targetEl)) {
      return;
    }
    const elementRootContains = elementRoot.contains(targetEl);
    if (targetEl === elementRoot) {
      elementRoot.focus();
    } else if (targetEl === elementContent) {
      elementContent.focus();
    } else if (elementRootContains) {
      if (elementContent.contains(targetEl)) {
        elementContent.focus();
      } else {
        elementRoot.focus();
      }
    }
  }
  __name(onClosePopup, "onClosePopup");
  function onKeydown(event) {
    if ((event.target === elementRoot || event.target === elementContent) && KeyboardManager && KeyboardManager?._getMatchingActions?.(KeyboardManager?.getKeyboardEventContext?.(event))?.length) {
      event.target?.blur();
      return;
    }
    if (focusWrapEnabled && event.shiftKey && event.code === "Tab") {
      const allFocusable = A11yHelper.getFocusableElements(elementRoot, s_IGNORE_CLASSES);
      const firstFocusEl = allFocusable.length > 0 ? allFocusable[0] : void 0;
      const lastFocusEl = allFocusable.length > 0 ? allFocusable[allFocusable.length - 1] : void 0;
      const activeWindow = application.reactive.activeWindow;
      if (elementRoot === activeWindow.document.activeElement || firstFocusEl === activeWindow.document.activeElement) {
        if (A11yHelper.isFocusTarget(lastFocusEl) && firstFocusEl !== lastFocusEl) {
          lastFocusEl.focus();
        }
        event.preventDefault();
        event.stopPropagation();
      }
    }
    if (typeof application?.options?.popOut === "boolean" && application.options.popOut && application !== globalThis.ui?.activeWindow) {
      application.bringToTop.call(application);
    }
  }
  __name(onKeydown, "onKeydown");
  function onPointerdownApp() {
    if (typeof application?.options?.popOut === "boolean" && application.options.popOut && application !== globalThis.ui?.activeWindow) {
      application.bringToTop.call(application);
    }
  }
  __name(onPointerdownApp, "onPointerdownApp");
  function onPointerdownContent(event) {
    const focusable = A11yHelper.isFocusable(event.target);
    if (!focusable && $focusAuto) {
      if ($focusKeep) {
        const activeWindow = application.reactive.activeWindow;
        const focusOutside = !elementRoot.contains(activeWindow.document.activeElement);
        if (focusOutside) {
          elementContent.focus();
        } else {
          event.preventDefault();
        }
      } else {
        elementContent.focus();
      }
    }
  }
  __name(onPointerdownContent, "onPointerdownContent");
  function resizeObservedContent(offsetWidth, offsetHeight) {
    $$invalidate(27, contentOffsetWidth = offsetWidth);
    $$invalidate(26, contentOffsetHeight = offsetHeight);
  }
  __name(resizeObservedContent, "resizeObservedContent");
  function resizeObservedApp(offsetWidth, offsetHeight, contentWidth, contentHeight) {
    application.position.stores.resizeObserved.update((object) => {
      object.contentWidth = contentWidth;
      object.contentHeight = contentHeight;
      object.offsetWidth = offsetWidth;
      object.offsetHeight = offsetHeight;
      return object;
    });
    $$invalidate(24, appOffsetHeight = offsetHeight);
    $$invalidate(25, appOffsetWidth = offsetWidth);
  }
  __name(resizeObservedApp, "resizeObservedApp");
  function section_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elementContent = $$value;
      $$invalidate(0, elementContent);
    });
  }
  __name(section_binding, "section_binding");
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elementRoot = $$value;
      $$invalidate(1, elementRoot);
    });
  }
  __name(div_binding, "div_binding");
  function section_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elementContent = $$value;
      $$invalidate(0, elementContent);
    });
  }
  __name(section_binding_1, "section_binding_1");
  function div_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elementRoot = $$value;
      $$invalidate(1, elementRoot);
    });
  }
  __name(div_binding_1, "div_binding_1");
  $$self.$$set = ($$props2) => {
    if ("elementContent" in $$props2)
      $$invalidate(0, elementContent = $$props2.elementContent);
    if ("elementRoot" in $$props2)
      $$invalidate(1, elementRoot = $$props2.elementRoot);
    if ("draggable" in $$props2)
      $$invalidate(6, draggable2 = $$props2.draggable);
    if ("draggableOptions" in $$props2)
      $$invalidate(7, draggableOptions = $$props2.draggableOptions);
    if ("stylesApp" in $$props2)
      $$invalidate(8, stylesApp = $$props2.stylesApp);
    if ("stylesContent" in $$props2)
      $$invalidate(9, stylesContent = $$props2.stylesContent);
    if ("appOffsetHeight" in $$props2)
      $$invalidate(24, appOffsetHeight = $$props2.appOffsetHeight);
    if ("appOffsetWidth" in $$props2)
      $$invalidate(25, appOffsetWidth = $$props2.appOffsetWidth);
    if ("contentOffsetHeight" in $$props2)
      $$invalidate(26, contentOffsetHeight = $$props2.contentOffsetHeight);
    if ("contentOffsetWidth" in $$props2)
      $$invalidate(27, contentOffsetWidth = $$props2.contentOffsetWidth);
    if ("transition" in $$props2)
      $$invalidate(28, transition = $$props2.transition);
    if ("inTransition" in $$props2)
      $$invalidate(2, inTransition = $$props2.inTransition);
    if ("outTransition" in $$props2)
      $$invalidate(3, outTransition = $$props2.outTransition);
    if ("transitionOptions" in $$props2)
      $$invalidate(29, transitionOptions = $$props2.transitionOptions);
    if ("inTransitionOptions" in $$props2)
      $$invalidate(4, inTransitionOptions = $$props2.inTransitionOptions);
    if ("outTransitionOptions" in $$props2)
      $$invalidate(5, outTransitionOptions = $$props2.outTransitionOptions);
    if ("$$scope" in $$props2)
      $$invalidate(36, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[1] & /*$resizeObservable*/
    16) {
      $$invalidate(12, appResizeObserver = initialAppResizeObserver || $resizeObservable ? {
        action: resizeObserver,
        data: resizeObservedApp
      } : void 0);
    }
    if ($$self.$$.dirty[0] & /*elementContent*/
    1) {
      if (elementContent !== void 0 && elementContent !== null) {
        getContext("#internal").stores.elementContent.set(elementContent);
      }
    }
    if ($$self.$$.dirty[0] & /*elementRoot*/
    2) {
      if (elementRoot !== void 0 && elementRoot !== null) {
        getContext("#internal").stores.elementRoot.set(elementRoot);
      }
    }
    if ($$self.$$.dirty[1] & /*$focusAuto, $focusTrap, $minimized*/
    14) {
      $$invalidate(11, focusWrapEnabled = $focusAuto && $focusTrap && !$minimized);
    }
    if ($$self.$$.dirty[0] & /*oldTransition, transition*/
    1342177280) {
      if (oldTransition !== transition) {
        const newTransition = typeof transition === "function" ? transition : TJSDefaultTransition.default;
        $$invalidate(2, inTransition = newTransition);
        $$invalidate(3, outTransition = newTransition);
        $$invalidate(30, oldTransition = newTransition);
      }
    }
    if ($$self.$$.dirty[0] & /*transitionOptions*/
    536870912 | $$self.$$.dirty[1] & /*oldTransitionOptions*/
    1) {
      if (oldTransitionOptions !== transitionOptions) {
        const newOptions = transitionOptions !== TJSDefaultTransition.options && isObject(transitionOptions) ? transitionOptions : TJSDefaultTransition.options;
        $$invalidate(4, inTransitionOptions = newOptions);
        $$invalidate(5, outTransitionOptions = newOptions);
        $$invalidate(31, oldTransitionOptions = newOptions);
      }
    }
    if ($$self.$$.dirty[0] & /*inTransition*/
    4) {
      if (typeof inTransition !== "function") {
        $$invalidate(2, inTransition = TJSDefaultTransition.default);
      }
    }
    if ($$self.$$.dirty[0] & /*outTransition, application*/
    1032) {
      {
        if (typeof outTransition !== "function") {
          $$invalidate(3, outTransition = TJSDefaultTransition.default);
        }
        const defaultCloseAnimation = application?.options?.defaultCloseAnimation;
        if (typeof defaultCloseAnimation === "boolean" && defaultCloseAnimation && outTransition !== TJSDefaultTransition.default) {
          $$invalidate(10, application.options.defaultCloseAnimation = false, application);
        }
      }
    }
    if ($$self.$$.dirty[0] & /*inTransitionOptions*/
    16) {
      if (!isObject(inTransitionOptions)) {
        $$invalidate(4, inTransitionOptions = TJSDefaultTransition.options);
      }
    }
    if ($$self.$$.dirty[0] & /*outTransitionOptions*/
    32) {
      if (!isObject(outTransitionOptions)) {
        $$invalidate(5, outTransitionOptions = TJSDefaultTransition.options);
      }
    }
  };
  return [
    elementContent,
    elementRoot,
    inTransition,
    outTransition,
    inTransitionOptions,
    outTransitionOptions,
    draggable2,
    draggableOptions,
    stylesApp,
    stylesContent,
    application,
    focusWrapEnabled,
    appResizeObserver,
    focusAuto,
    focusKeep,
    focusTrap,
    minimized,
    resizeObservable,
    contentResizeObserver,
    onClosePopup,
    onKeydown,
    onPointerdownApp,
    onPointerdownContent,
    resizeObservedContent,
    appOffsetHeight,
    appOffsetWidth,
    contentOffsetHeight,
    contentOffsetWidth,
    transition,
    transitionOptions,
    oldTransition,
    oldTransitionOptions,
    $focusAuto,
    $minimized,
    $focusTrap,
    $resizeObservable,
    $$scope,
    slots,
    section_binding,
    div_binding,
    section_binding_1,
    div_binding_1
  ];
}
__name(instance$Z, "instance$Z");
class ApplicationShell extends SvelteComponent {
  static {
    __name(this, "ApplicationShell");
  }
  constructor(options) {
    super();
    init$1(
      this,
      options,
      instance$Z,
      create_fragment$14,
      safe_not_equal,
      {
        elementContent: 0,
        elementRoot: 1,
        draggable: 6,
        draggableOptions: 7,
        stylesApp: 8,
        stylesContent: 9,
        appOffsetHeight: 24,
        appOffsetWidth: 25,
        contentOffsetHeight: 26,
        contentOffsetWidth: 27,
        transition: 28,
        inTransition: 2,
        outTransition: 3,
        transitionOptions: 29,
        inTransitionOptions: 4,
        outTransitionOptions: 5
      },
      null,
      [-1, -1]
    );
  }
  get elementContent() {
    return this.$$.ctx[0];
  }
  set elementContent(elementContent) {
    this.$$set({ elementContent });
    flush();
  }
  get elementRoot() {
    return this.$$.ctx[1];
  }
  set elementRoot(elementRoot) {
    this.$$set({ elementRoot });
    flush();
  }
  get draggable() {
    return this.$$.ctx[6];
  }
  set draggable(draggable2) {
    this.$$set({ draggable: draggable2 });
    flush();
  }
  get draggableOptions() {
    return this.$$.ctx[7];
  }
  set draggableOptions(draggableOptions) {
    this.$$set({ draggableOptions });
    flush();
  }
  get stylesApp() {
    return this.$$.ctx[8];
  }
  set stylesApp(stylesApp) {
    this.$$set({ stylesApp });
    flush();
  }
  get stylesContent() {
    return this.$$.ctx[9];
  }
  set stylesContent(stylesContent) {
    this.$$set({ stylesContent });
    flush();
  }
  get appOffsetHeight() {
    return this.$$.ctx[24];
  }
  set appOffsetHeight(appOffsetHeight) {
    this.$$set({ appOffsetHeight });
    flush();
  }
  get appOffsetWidth() {
    return this.$$.ctx[25];
  }
  set appOffsetWidth(appOffsetWidth) {
    this.$$set({ appOffsetWidth });
    flush();
  }
  get contentOffsetHeight() {
    return this.$$.ctx[26];
  }
  set contentOffsetHeight(contentOffsetHeight) {
    this.$$set({ contentOffsetHeight });
    flush();
  }
  get contentOffsetWidth() {
    return this.$$.ctx[27];
  }
  set contentOffsetWidth(contentOffsetWidth) {
    this.$$set({ contentOffsetWidth });
    flush();
  }
  get transition() {
    return this.$$.ctx[28];
  }
  set transition(transition) {
    this.$$set({ transition });
    flush();
  }
  get inTransition() {
    return this.$$.ctx[2];
  }
  set inTransition(inTransition) {
    this.$$set({ inTransition });
    flush();
  }
  get outTransition() {
    return this.$$.ctx[3];
  }
  set outTransition(outTransition) {
    this.$$set({ outTransition });
    flush();
  }
  get transitionOptions() {
    return this.$$.ctx[29];
  }
  set transitionOptions(transitionOptions) {
    this.$$set({ transitionOptions });
    flush();
  }
  get inTransitionOptions() {
    return this.$$.ctx[4];
  }
  set inTransitionOptions(inTransitionOptions) {
    this.$$set({ inTransitionOptions });
    flush();
  }
  get outTransitionOptions() {
    return this.$$.ctx[5];
  }
  set outTransitionOptions(outTransitionOptions) {
    this.$$set({ outTransitionOptions });
    flush();
  }
}
cssVariables.setProperties({
  // Anchor text shadow / header buttons
  "--tjs-default-text-shadow-focus-hover": "0 0 8px var(--color-shadow-primary)",
  // TJSApplicationShell app background.
  "--tjs-app-background": `url("${globalThis.foundry.utils.getRoute("/ui/denim075.png")}")`
}, false);
class TJSGameSettings {
  static {
    __name(this, "TJSGameSettings");
  }
  /** @type {string} */
  #namespace;
  /** @type {GameSettingData[]} */
  #settings = [];
  /**
   * @type {Map<string, import('svelte/store').Writable>}
   */
  #stores = /* @__PURE__ */ new Map();
  /**
   * Creates the TJSGameSettings instance.
   *
   * @param {string}   namespace - The namespace for all settings.
   */
  constructor(namespace) {
    if (typeof namespace !== "string") {
      throw new TypeError(`'namespace' is not a string.`);
    }
    this.#namespace = namespace;
  }
  /**
   * Creates a new writable for the given key.
   *
   * @param {*}  initialValue - An initial value to set to new stores.
   *
   * @returns {import('svelte/store').Writable} The new writable.
   */
  static #createStore(initialValue) {
    return writable(initialValue);
  }
  /**
   * @returns {string} Returns namespace set in constructor.
   */
  get namespace() {
    return this.#namespace;
  }
  /**
   * Gets a store from the `stores` Map or creates a new store for the key.
   *
   * @param {string}   key - Key to lookup in stores map.
   *
   * @param {string}   [initialValue] - An initial value to set to new stores.
   *
   * @returns {import('svelte/store').Writable} The store for the given key.
   */
  #getStore(key, initialValue) {
    let store = this.#stores.get(key);
    if (store === void 0) {
      store = TJSGameSettings.#createStore(initialValue);
      this.#stores.set(key, store);
    }
    return store;
  }
  /**
   * Returns a readable Game Settings store for the associated key.
   *
   * @param {string}   key - Game setting key.
   *
   * @returns {import('svelte/store').Readable | undefined} The associated store for the given game setting key.
   */
  getReadableStore(key) {
    if (!this.#stores.has(key)) {
      console.warn(`TJSGameSettings - getReadableStore: '${key}' is not a registered setting.`);
      return;
    }
    const store = this.#getStore(key);
    return { subscribe: store.subscribe };
  }
  /**
   * Returns a writable Game Settings store for the associated key.
   *
   * @param {string}   key - Game setting key.
   *
   * @returns {import('svelte/store').Writable | undefined} The associated store for the given game setting key.
   */
  getStore(key) {
    return this.getWritableStore(key);
  }
  /**
   * Returns a writable Game Settings store for the associated key.
   *
   * @param {string}   key - Game setting key.
   *
   * @returns {import('svelte/store').Writable | undefined} The associated store for the given game setting key.
   */
  getWritableStore(key) {
    if (!this.#stores.has(key)) {
      console.warn(`TJSGameSettings - getWritableStore: '${key}' is not a registered setting.`);
      return;
    }
    return this.#getStore(key);
  }
  /**
   * Registers a setting with TJSGameSettings and Foundry core.
   *
   * Note: The specific store subscription handler assigned to the passed in store or store created for the setting
   * internally is returned from this function. In some cases when setting up custom stores particularly of object
   * types with several child property stores (`propertyStore`) it is necessary to only update the setting store and
   * not all subscribers to the custom store as the `propertyStore` instances are also subscribers to the custom store.
   *
   * This allows the custom store in the `set` implementation to mainly only trigger the TJSGameSettings subscriber
   * handler on updates and not all the connected `propertyStore` instances.
   *
   * @param {GameSetting} setting - A GameSetting instance to set to Foundry game settings.
   *
   * @param {boolean}     coreConfig - When false this overrides the `setting.options.config` parameter when
   *                                   registering the setting with Foundry. This allows the settings to be displayed
   *                                   in the app itself, but removed from the standard Foundry configuration location.
   *
   * @returns {Function} The specific store subscription handler assigned to the passed in store.
   */
  register(setting, coreConfig = true) {
    if (!isObject(setting)) {
      throw new TypeError(`TJSGameSettings - register: setting is not an object.`);
    }
    if (!isObject(setting.options)) {
      throw new TypeError(`TJSGameSettings - register: 'setting.options' attribute is not an object.`);
    }
    if (typeof coreConfig !== "boolean") {
      throw new TypeError(`TJSGameSettings - register: 'coreConfig' is not an boolean.`);
    }
    if (setting.store !== void 0 && !isMinimalWritableStore(setting.store)) {
      throw new TypeError(
        `TJSGameSettings - register: 'setting.store' attribute is not a minimal writable store.`
      );
    }
    const namespace = setting.namespace;
    const key = setting.key;
    const folder = setting.folder;
    const foundryConfig = coreConfig ? setting.options.config : false;
    if (typeof namespace !== "string") {
      throw new TypeError(`TJSGameSettings - register: 'namespace' attribute is not a string.`);
    }
    if (typeof key !== "string") {
      throw new TypeError(`TJSGameSettings - register: 'key' attribute is not a string.`);
    }
    if (folder !== void 0 && typeof folder !== "string") {
      throw new TypeError(`TJSGameSettings - register: 'folder' attribute is not a string.`);
    }
    const store = setting.store;
    const options = setting.options;
    const onchangeFunctions = [];
    let gateSet = false;
    onchangeFunctions.push((value) => {
      const callbackStore = this.#getStore(key);
      if (callbackStore && !gateSet) {
        gateSet = true;
        callbackStore.set(value);
        gateSet = false;
      }
    });
    if (isIterable(options?.onChange)) {
      for (const entry of options.onChange) {
        if (typeof entry === "function") {
          onchangeFunctions.push(entry);
        }
      }
    } else if (typeof options.onChange === "function") {
      onchangeFunctions.push(options.onChange);
    }
    const onChange = /* @__PURE__ */ __name((value) => {
      for (const entry of onchangeFunctions) {
        entry(value);
      }
    }, "onChange");
    globalThis.game.settings.register(namespace, key, { ...options, config: foundryConfig, onChange });
    const targetStore = store ? store : this.#getStore(key, globalThis.game.settings.get(namespace, key));
    if (store) {
      this.#stores.set(key, targetStore);
      store.set(globalThis.game.settings.get(namespace, key));
    }
    const storeHandler = /* @__PURE__ */ __name(async (value) => {
      if (!gateSet) {
        gateSet = true;
        await globalThis.game.settings.set(namespace, key, value);
      }
      gateSet = false;
    }, "storeHandler");
    subscribeIgnoreFirst(targetStore, storeHandler);
    const gameSettingData = {
      namespace,
      key,
      folder,
      ...options
    };
    Object.freeze(gameSettingData);
    this.#settings.push(gameSettingData);
    return storeHandler;
  }
  /**
   * Registers multiple settings.
   *
   * Please refer to the note in {@link TJSGameSettings.register} about the returned object of store subscriber handler
   * functions.
   *
   * @param {Iterable<GameSetting>} settings - An iterable list of game setting configurations to register.
   *
   * @param {boolean}     coreConfig - When false this overrides the `setting.options.config` parameter when
   *                                   registering the setting with Foundry. This allows the settings to be displayed
   *                                   in the app itself, but removed from the standard Foundry configuration location.
   *
   * @returns { {[key: string]: Function} } An object containing all TJSGameSetting store subscriber handlers for each
   *          setting `key` added.
   */
  registerAll(settings, coreConfig) {
    const storeHandlers = {};
    if (!isIterable(settings)) {
      throw new TypeError(`TJSGameSettings - registerAll: settings is not iterable.`);
    }
    for (const entry of settings) {
      if (!isObject(entry)) {
        throw new TypeError(`TJSGameSettings - registerAll: entry in settings is not an object.`);
      }
      if (typeof entry.namespace !== "string") {
        throw new TypeError(`TJSGameSettings - registerAll: entry in settings missing 'namespace' attribute.`);
      }
      if (typeof entry.key !== "string") {
        throw new TypeError(`TJSGameSettings - registerAll: entry in settings missing 'key' attribute.`);
      }
      if (!isObject(entry.options)) {
        throw new TypeError(`TJSGameSettings - registerAll: entry in settings missing 'options' attribute.`);
      }
      storeHandlers[entry.key] = this.register(entry, coreConfig);
    }
    return storeHandlers;
  }
  // Iterators ------------------------------------------------------------------------------------------------------
  /**
   * Returns an iterable for the game setting data; {@link GameSettingData}.
   *
   * @param {RegExp} [regex] - Optional regular expression to filter by game setting keys.
   *
   * @returns {IterableIterator<GameSettingData>} Iterable iterator of GameSettingData.
   * @yields {GameSettingData}
   */
  *data(regex = void 0) {
    if (regex !== void 0 && !CrossWindow.isRegExp(regex)) {
      throw new TypeError(`'regex' is not a RegExp`);
    }
    if (!this.#settings.length) {
      return void 0;
    }
    if (regex) {
      for (const setting of this.#settings) {
        if (regex.test(setting.key)) {
          yield setting;
        }
      }
    } else {
      for (const setting of this.#settings) {
        yield setting;
      }
    }
  }
  /**
   * @template T
   *
   * Returns an iterable for the game setting keys and stores.
   *
   * @param {RegExp} [regex] - Optional regular expression to filter by game setting keys.
   *
   * @returns {IterableIterator<[string, import('svelte/store').Writable<T>]>} Iterable iterator of keys and stores.
   * @yields {import('svelte/store').Writable<T>}
   */
  *entries(regex = void 0) {
    if (regex !== void 0 && !CrossWindow.isRegExp(regex)) {
      throw new TypeError(`'regex' is not a RegExp`);
    }
    if (!this.#stores.size) {
      return void 0;
    }
    if (regex) {
      for (const key of this.#stores.keys()) {
        if (regex.test(key)) {
          yield [key, this.getStore(key)];
        }
      }
    } else {
      for (const key of this.#stores.keys()) {
        yield [key, this.getStore(key)];
      }
    }
  }
  /**
   * Returns an iterable for the game setting keys from existing stores.
   *
   * @param {RegExp} [regex] - Optional regular expression to filter by game setting keys.
   *
   * @returns {IterableIterator<string>} Iterable iterator of game setting keys.
   * @yields {string}
   */
  *keys(regex = void 0) {
    if (regex !== void 0 && !CrossWindow.isRegExp(regex)) {
      throw new TypeError(`'regex' is not a RegExp`);
    }
    if (!this.#stores.size) {
      return void 0;
    }
    if (regex) {
      for (const key of this.#stores.keys()) {
        if (regex.test(key)) {
          yield key;
        }
      }
    } else {
      for (const key of this.#stores.keys()) {
        yield key;
      }
    }
  }
  /**
   * @template T
   *
   * Returns an iterable for the game setting stores.
   *
   * @param {RegExp} [regex] - Optional regular expression to filter by game setting keys.
   *
   * @returns {IterableIterator<import('svelte/store').Writable<T>>} Iterable iterator of stores.
   * @yields {import('svelte/store').Writable<T>}
   */
  *stores(regex = void 0) {
    if (regex !== void 0 && !CrossWindow.isRegExp(regex)) {
      throw new TypeError(`'regex' is not a RegExp`);
    }
    if (!this.#stores.size) {
      return void 0;
    }
    if (regex) {
      for (const key of this.#stores.keys()) {
        if (regex.test(key)) {
          yield this.getStore(key);
        }
      }
    } else {
      for (const key of this.#stores.keys()) {
        yield this.getStore(key);
      }
    }
  }
}
const gameSettings = new TJSGameSettings(SYSTEM_ID);
function create_default_slot$g(ctx) {
  let main;
  let div1;
  let h1;
  let p0;
  let i0;
  let a0;
  let t3_value = localize$1("Welcome.Released") + "";
  let t3;
  let t4;
  let t5_value = localize$1("Setting.DontShowWelcome.Introduction") + "";
  let t5;
  let p1;
  let i1;
  let t6_value = localize$1("Setting.DontShowWelcome.Bugs") + "";
  let t6;
  let t7;
  let a1;
  let p2;
  let i2;
  let t10_value = localize$1("Setting.DontShowWelcome.Support") + "";
  let t10;
  let t11;
  let a2;
  let t13;
  let a3;
  let p3;
  let div4;
  let div2;
  let input;
  let div3;
  let span0;
  let footer;
  let div5;
  let div6;
  let h4;
  let span1;
  let a5;
  let mounted;
  let dispose;
  return {
    c() {
      main = element("main");
      div1 = element("div");
      div1.innerHTML = `<div class="texture svelte-pyn9ka"></div><img src="/systems/foundryvtt-final-fantasy/assets/FF-logo.png" alt="Final Fantasy XIV RPG Logo" style="border: none; width: auto;"/>`;
      h1 = element("h1");
      h1.textContent = `${localize$1("Welcome.Introduction")}`;
      p0 = element("p");
      i0 = element("i");
      a0 = element("a");
      a0.textContent = `${localize$1("Title")} `;
      t3 = text(t3_value);
      t4 = space();
      t5 = text(t5_value);
      p1 = element("p");
      i1 = element("i");
      t6 = text(t6_value);
      t7 = space();
      a1 = element("a");
      a1.textContent = `${localize$1("Setting.DontShowWelcome.IssuesLinkText")} `;
      p2 = element("p");
      i2 = element("i");
      t10 = text(t10_value);
      t11 = space();
      a2 = element("a");
      a2.textContent = `${localize$1("Setting.DontShowWelcome.SponsorLinkText")}`;
      t13 = text(" or ");
      a3 = element("a");
      a3.textContent = "PayPal";
      p3 = element("p");
      p3.textContent = `${localize$1("Welcome.Disclaimer")}`;
      div4 = element("div");
      div2 = element("div");
      input = element("input");
      div3 = element("div");
      span0 = element("span");
      span0.textContent = `${localize$1("Setting.DontShowWelcome.Name")}`;
      footer = element("footer");
      div5 = element("div");
      div5.innerHTML = `<a href="https://www.aardvark.games" class="svelte-pyn9ka"><img src="/systems/foundryvtt-final-fantasy/assets/aardvark-logo.webp" alt="Aardvark Game Studios Logo" height="40" width="40" style="fill: white; border: none; width: auto;"/></a>`;
      div6 = element("div");
      h4 = element("h4");
      h4.textContent = `${localize$1("Title")} `;
      span1 = element("span");
      span1.textContent = `${localize$1("Welcome.CreatedBy")} `;
      a5 = element("a");
      a5.textContent = "Aardvark Game Studios";
      attr(div1, "class", "logo-background svelte-pyn9ka");
      attr(i0, "class", "fa-solid fa-info-circle mr-sm");
      attr(a0, "href", "https://www.square-enix-shop.com/ffxivttrpg/en/freetrial.html");
      attr(p0, "class", "lightest");
      attr(i1, "class", "fa-solid fa-bug mr-sm");
      attr(a1, "href", "https://github.com/geoidesic/foundryvtt-final-fantasy/issues");
      attr(p1, "class", "lighter");
      attr(i2, "class", "fa-solid fa-heart mr-sm");
      set_style(i2, "color", "#660000");
      attr(a2, "href", "https://github.com/sponsors/geoidesic");
      attr(a3, "href", "https://https://paypal.me/geoidesic");
      attr(p3, "class", "smallest");
      attr(input, "type", "checkbox");
      attr(input, "label", localize$1("Setting.DontShowWelcome.Name"));
      attr(input, "class", "svelte-pyn9ka");
      attr(div2, "class", "flex0");
      attr(div3, "class", "flex");
      attr(div4, "class", "flexrow inset justify-vertical mb-sm dont-show svelte-pyn9ka");
      attr(div4, "data-tooltip", localize$1("Setting.DontShowWelcome.Hint"));
      attr(main, "class", "svelte-pyn9ka");
      attr(div5, "class", "right mr-md");
      attr(a5, "href", "https://www.aardvark.games");
      attr(a5, "class", "svelte-pyn9ka");
      attr(div6, "class", "left");
      attr(footer, "class", "svelte-pyn9ka");
    },
    m(target, anchor) {
      insert(target, main, anchor);
      append(main, div1);
      append(main, h1);
      append(main, p0);
      append(p0, i0);
      append(p0, a0);
      append(p0, t3);
      append(p0, t4);
      append(p0, t5);
      append(main, p1);
      append(p1, i1);
      append(p1, t6);
      append(p1, t7);
      append(p1, a1);
      append(main, p2);
      append(p2, i2);
      append(p2, t10);
      append(p2, t11);
      append(p2, a2);
      append(p2, t13);
      append(p2, a3);
      append(main, p3);
      append(main, div4);
      append(div4, div2);
      append(div2, input);
      input.checked = /*dontShowWelcome*/
      ctx[1];
      append(div4, div3);
      append(div3, span0);
      insert(target, footer, anchor);
      append(footer, div5);
      append(footer, div6);
      append(div6, h4);
      append(div6, span1);
      append(div6, a5);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "change",
            /*handleChange*/
            ctx[3]
          ),
          listen(
            input,
            "change",
            /*input_change_handler*/
            ctx[7]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*dontShowWelcome*/
      2) {
        input.checked = /*dontShowWelcome*/
        ctx2[1];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(main);
        detach(footer);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_default_slot$g, "create_default_slot$g");
function create_fragment$13(ctx) {
  let applicationshell;
  let updating_elementRoot;
  let current;
  function applicationshell_elementRoot_binding(value) {
    ctx[8](value);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  let applicationshell_props = {
    $$slots: { default: [create_default_slot$g] },
    $$scope: { ctx }
  };
  if (
    /*elementRoot*/
    ctx[0] !== void 0
  ) {
    applicationshell_props.elementRoot = /*elementRoot*/
    ctx[0];
  }
  applicationshell = new ApplicationShell({ props: applicationshell_props });
  binding_callbacks.push(() => bind(applicationshell, "elementRoot", applicationshell_elementRoot_binding));
  return {
    c() {
      create_component(applicationshell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(applicationshell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const applicationshell_changes = {};
      if (dirty & /*$$scope, dontShowWelcome*/
      1026) {
        applicationshell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_elementRoot && dirty & /*elementRoot*/
      1) {
        updating_elementRoot = true;
        applicationshell_changes.elementRoot = /*elementRoot*/
        ctx2[0];
        add_flush_callback(() => updating_elementRoot = false);
      }
      applicationshell.$set(applicationshell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applicationshell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applicationshell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applicationshell, detaching);
    }
  };
}
__name(create_fragment$13, "create_fragment$13");
function instance$Y($$self, $$props, $$invalidate) {
  let dontShowWelcome2;
  let $dontShowWelcomeStore;
  let { elementRoot = void 0 } = $$props;
  let { version: version2 = void 0 } = $$props;
  const application = getContext("#external").application;
  const dontShowWelcomeStore = gameSettings.getStore("dontShowWelcome");
  component_subscribe($$self, dontShowWelcomeStore, (value) => $$invalidate(6, $dontShowWelcomeStore = value));
  const handleChange = /* @__PURE__ */ __name((event) => {
    game.settings.set(SYSTEM_ID, "dontShowWelcome", event.target.checked);
  }, "handleChange");
  let draggable2 = application.reactive.draggable;
  draggable2 = true;
  onMount(async () => {
  });
  function input_change_handler() {
    dontShowWelcome2 = this.checked;
    $$invalidate(1, dontShowWelcome2), $$invalidate(6, $dontShowWelcomeStore);
  }
  __name(input_change_handler, "input_change_handler");
  function applicationshell_elementRoot_binding(value) {
    elementRoot = value;
    $$invalidate(0, elementRoot);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  $$self.$$set = ($$props2) => {
    if ("elementRoot" in $$props2)
      $$invalidate(0, elementRoot = $$props2.elementRoot);
    if ("version" in $$props2)
      $$invalidate(4, version2 = $$props2.version);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*draggable*/
    32) {
      application.reactive.draggable = draggable2;
    }
    if ($$self.$$.dirty & /*$dontShowWelcomeStore*/
    64) {
      $$invalidate(1, dontShowWelcome2 = $dontShowWelcomeStore);
    }
    if ($$self.$$.dirty & /*dontShowWelcome*/
    2) {
      game.system.log.d("dontShowWelcome", dontShowWelcome2);
    }
  };
  return [
    elementRoot,
    dontShowWelcome2,
    dontShowWelcomeStore,
    handleChange,
    version2,
    draggable2,
    $dontShowWelcomeStore,
    input_change_handler,
    applicationshell_elementRoot_binding
  ];
}
__name(instance$Y, "instance$Y");
class WelcomeAppShell extends SvelteComponent {
  static {
    __name(this, "WelcomeAppShell");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$Y, create_fragment$13, safe_not_equal, { elementRoot: 0, version: 4 });
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(elementRoot) {
    this.$$set({ elementRoot });
    flush();
  }
  get version() {
    return this.$$.ctx[4];
  }
  set version(version2) {
    this.$$set({ version: version2 });
    flush();
  }
}
class ApplicationState {
  static {
    __name(this, "ApplicationState");
  }
  /** @type {object} */
  #application;
  /**
   * Stores the current save state key being restored by animating. When a restore is already being animated with the
   * same name the subsequent restore animation is ignored.
   *
   * @type {string | undefined}
   */
  #currentRestoreKey;
  /** @type {Map<string, import('./types').ApplicationStateData>} */
  #dataSaved = /* @__PURE__ */ new Map();
  /**
   * @param {object}   application - The application.
   */
  constructor(application) {
    this.#application = application;
    Object.seal(this);
  }
  /**
   * Clears all saved application state.
   */
  clear() {
    this.#dataSaved.clear();
  }
  /**
   * Returns current application state along with any extra data passed into method.
   *
   * @param {object} [extra] - Extra data to add to application state.
   *
   * @returns {import('./types').ApplicationStateData} Passed in object with current application state.
   */
  current(extra = {}) {
    return Object.assign(extra, {
      position: this.#application?.position?.get(),
      beforeMinimized: this.#application?.position?.state.get({ name: "#beforeMinimized" }),
      options: this.#application?.reactive?.toJSON(),
      ui: { minimized: this.#application?.reactive?.minimized }
    });
  }
  /**
   * Gets any saved application state by name.
   *
   * @param {object}   options - Options.
   *
   * @param {string}   options.name - Saved data set name.
   *
   * @returns {import('./types').ApplicationStateData | undefined} Any saved application state.
   */
  get({ name }) {
    if (typeof name !== "string") {
      throw new TypeError(`ApplicationState - get error: 'name' is not a string.`);
    }
    return this.#dataSaved.get(name);
  }
  /**
   * @returns {IterableIterator<string>} The saved application state names / keys.
   */
  keys() {
    return this.#dataSaved.keys();
  }
  /**
   * Removes and returns any saved application state by name.
   *
   * @param {object}   options - Options.
   *
   * @param {string}   options.name - Name to remove and retrieve.
   *
   * @returns {import('./types').ApplicationStateData | undefined} Any saved application state.
   */
  remove({ name }) {
    if (typeof name !== "string") {
      throw new TypeError(`ApplicationState - remove: 'name' is not a string.`);
    }
    const data = this.#dataSaved.get(name);
    this.#dataSaved.delete(name);
    return data;
  }
  /**
   * Restores a previously saved application state by `name` returning the data. Several optional parameters are
   * available to animate / tween to the new state. When `animateTo` is true an animation is scheduled via
   * {@link AnimationAPI.to} and the duration and easing name or function may be specified.
   *
   * @param {object}            options - Options.
   *
   * @param {string}            options.name - Saved data set name.
   *
   * @param {boolean}           [options.remove=false] - Remove data set.
   *
   * @param {boolean}           [options.animateTo=false] - Animate to restore data.
   *
   * @param {number}            [options.duration=0.1] - Duration in seconds.
   *
   * @param {import('@typhonjs-fvtt/runtime/svelte/easing').EasingReference} [options.ease='linear'] - Easing function or easing
   *        function name.
   *
   * @returns {import('./types').ApplicationStateData | undefined} Any saved application state.
   */
  restore({ name, remove = false, animateTo = false, duration = 0.1, ease = "linear" }) {
    if (typeof name !== "string") {
      throw new TypeError(`ApplicationState - restore error: 'name' is not a string.`);
    }
    const dataSaved = this.#dataSaved.get(name);
    if (dataSaved) {
      if (remove) {
        this.#dataSaved.delete(name);
      }
      if (animateTo && name !== this.#currentRestoreKey) {
        this.#currentRestoreKey = name;
        this.#setImpl(dataSaved, {
          animateTo,
          async: true,
          duration,
          ease
        }).then(() => {
          if (name === this.#currentRestoreKey) {
            this.#currentRestoreKey = void 0;
          }
        });
      }
    }
    return dataSaved;
  }
  /**
   * Saves current application state with the opportunity to add extra data to the saved state.
   *
   * @param {object}   options - Options.
   *
   * @param {string}   options.name - Name to index this saved state.
   *
   * @returns {import('./types').ApplicationStateData} Current saved application state.
   */
  save({ name, ...extra }) {
    if (typeof name !== "string") {
      throw new TypeError(`ApplicationState - save error: 'name' is not a string.`);
    }
    const data = this.current(extra);
    this.#dataSaved.set(name, data);
    return data;
  }
  /**
   * Sets application state from the given {@link ApplicationStateData} instance. Several optional parameters are
   * available to animate / tween to the new state. When `animateTo` is true an animation is scheduled via
   * {@link AnimationAPI.to} and the duration and easing name or function may be specified.
   *
   * Note: If serializing application state any minimized apps will use the before minimized state on initial render
   * of the app as it is currently not possible to render apps with Foundry VTT core API in the minimized state.
   *
   * @param {import('./types').ApplicationStateData}   data - Saved data set name.
   *
   * @param {object}         [options] - Optional parameters
   *
   * @param {boolean}        [options.animateTo=false] - Animate to restore data.
   *
   * @param {number}         [options.duration=0.1] - Duration in seconds.
   *
   * @param {import('@typhonjs-fvtt/runtime/svelte/easing').EasingReference} [options.ease='linear'] - Easing function or easing
   *        function name.
   */
  set(data, options = {}) {
    this.#setImpl(data, { ...options, async: false });
  }
  // Internal implementation ----------------------------------------------------------------------------------------
  /**
   * Sets application state from the given {@link ApplicationStateData} instance. Several optional parameters are
   * available to animate / tween to the new state. When `animateTo` is true an animation is scheduled via
   * {@link AnimationAPI.to} and the duration and easing name or function may be specified.
   *
   * Note: If serializing application state any minimized apps will use the before minimized state on initial render
   * of the app as it is currently not possible to render apps with Foundry VTT core API in the minimized state.
   *
   * TODO: THIS METHOD NEEDS TO BE REFACTORED WHEN TRL IS MADE INTO A STANDALONE FRAMEWORK.
   *
   * @param {import('./types').ApplicationStateData}   data - Saved data set name.
   *
   * @param {object}            [opts] - Optional parameters
   *
   * @param {boolean}           [opts.async=false] - If animating return a Promise that resolves with any saved data.
   *
   * @param {boolean}           [opts.animateTo=false] - Animate to restore data.
   *
   * @param {number}            [opts.duration=0.1] - Duration in seconds.
   *
   * @param {import('@typhonjs-fvtt/runtime/svelte/easing').EasingReference} [opts.ease='linear'] - Easing function or easing
   *        function name.
   *
   * @returns {undefined | Promise<void>} When asynchronous the animation Promise.
   */
  #setImpl(data, { async = false, animateTo = false, duration = 0.1, ease = "linear" } = {}) {
    if (!isObject(data)) {
      throw new TypeError(`ApplicationState - restore error: 'data' is not an object.`);
    }
    const application = this.#application;
    if (!isObject(data?.position)) {
      console.warn(`ApplicationState.set warning: 'data.position' is not an object.`);
      return;
    }
    const rendered = application.rendered;
    if (animateTo) {
      if (!rendered) {
        console.warn(`ApplicationState.set warning: Application is not rendered and 'animateTo' is true.`);
        return;
      }
      if (data.position.transformOrigin !== application.position.transformOrigin) {
        application.position.transformOrigin = data.position.transformOrigin;
      }
      if (isObject(data?.ui)) {
        const minimized = typeof data.ui?.minimized === "boolean" ? data.ui.minimized : false;
        if (application?.reactive?.minimized && !minimized) {
          application.maximize({ animate: false, duration: 0 });
        }
      }
      const promise2 = application.position.animate.to(data.position, {
        duration,
        ease,
        strategy: "cancelAll"
      }).finished.then(({ cancelled }) => {
        if (cancelled) {
          return;
        }
        if (isObject(data?.options)) {
          application?.reactive.mergeOptions(data.options);
        }
        if (isObject(data?.ui)) {
          const minimized = typeof data.ui?.minimized === "boolean" ? data.ui.minimized : false;
          if (!application?.reactive?.minimized && minimized) {
            application.minimize({ animate: false, duration: 0 });
          }
        }
        if (isObject(data?.beforeMinimized)) {
          application.position.state.set({ name: "#beforeMinimized", ...data.beforeMinimized });
        }
      });
      if (async) {
        return promise2;
      }
    } else {
      if (rendered) {
        if (isObject(data?.options)) {
          application?.reactive.mergeOptions(data.options);
        }
        if (isObject(data?.ui)) {
          const minimized = typeof data.ui?.minimized === "boolean" ? data.ui.minimized : false;
          if (application?.reactive?.minimized && !minimized) {
            application.maximize({ animate: false, duration: 0 });
          } else if (!application?.reactive?.minimized && minimized) {
            application.minimize({ animate: false, duration });
          }
        }
        if (isObject(data?.beforeMinimized)) {
          application.position.state.set({ name: "#beforeMinimized", ...data.beforeMinimized });
        }
        application.position.set(data.position);
      } else {
        let positionData = data.position;
        if (isObject(data.beforeMinimized)) {
          positionData = data.beforeMinimized;
          positionData.left = data.position.left;
          positionData.top = data.position.top;
        }
        application.position.set(positionData);
      }
    }
  }
}
class GetSvelteData {
  static {
    __name(this, "GetSvelteData");
  }
  /** @type {import('./types').MountedAppShell[] | null[]} */
  #applicationShellHolder;
  /** @type {import('./types').SvelteData[]} */
  #svelteData;
  /**
   * Keep a direct reference to the SvelteData array in an associated {@link SvelteApplication}.
   *
   * @param {import('./types').MountedAppShell[] | null[]}  applicationShellHolder - A reference to the
   *        MountedAppShell array.
   *
   * @param {import('./types').SvelteData[]}  svelteData - A reference to the SvelteData array of mounted components.
   */
  constructor(applicationShellHolder, svelteData) {
    this.#applicationShellHolder = applicationShellHolder;
    this.#svelteData = svelteData;
  }
  /**
   * Returns any mounted {@link MountedAppShell}.
   *
   * @returns {import('./types').MountedAppShell | null} Any mounted application shell.
   */
  get applicationShell() {
    return this.#applicationShellHolder[0];
  }
  /**
   * Returns the indexed Svelte component.
   *
   * @param {number}   index -
   *
   * @returns {object} The loaded Svelte component.
   */
  component(index) {
    const data = this.#svelteData[index];
    return data?.component ?? void 0;
  }
  /**
   * Returns the Svelte component entries iterator.
   *
   * @returns {IterableIterator<[number, import('svelte').SvelteComponent]>} Svelte component entries iterator.
   * @yields
   */
  *componentEntries() {
    for (let cntr = 0; cntr < this.#svelteData.length; cntr++) {
      yield [cntr, this.#svelteData[cntr].component];
    }
  }
  /**
   * Returns the Svelte component values iterator.
   *
   * @returns {IterableIterator<import('svelte').SvelteComponent>} Svelte component values iterator.
   * @yields
   */
  *componentValues() {
    for (let cntr = 0; cntr < this.#svelteData.length; cntr++) {
      yield this.#svelteData[cntr].component;
    }
  }
  /**
   * Returns the indexed SvelteData entry.
   *
   * @param {number}   index - The index of SvelteData instance to retrieve.
   *
   * @returns {import('./types').SvelteData} The loaded Svelte config + component.
   */
  data(index) {
    return this.#svelteData[index];
  }
  /**
   * Returns the {@link SvelteData} instance for a given component.
   *
   * @param {import('svelte').SvelteComponent} component - Svelte component.
   *
   * @returns {import('./types').SvelteData} -  The loaded Svelte config + component.
   */
  dataByComponent(component) {
    for (const data of this.#svelteData) {
      if (data.component === component) {
        return data;
      }
    }
    return void 0;
  }
  /**
   * Returns the SvelteData entries iterator.
   *
   * @returns {IterableIterator<[number, import('./types').SvelteData]>} SvelteData entries iterator.
   */
  dataEntries() {
    return this.#svelteData.entries();
  }
  /**
   * Returns the SvelteData values iterator.
   *
   * @returns {IterableIterator<import('./types').SvelteData>} SvelteData values iterator.
   */
  dataValues() {
    return this.#svelteData.values();
  }
  /**
   * Returns the length of the mounted Svelte component list.
   *
   * @returns {number} Length of mounted Svelte component list.
   */
  get length() {
    return this.#svelteData.length;
  }
}
function storeGenerator({ storage, serialize = JSON.stringify, deserialize = JSON.parse }) {
  function isSimpleDeriver(deriver) {
    return deriver.length < 2;
  }
  __name(isSimpleDeriver, "isSimpleDeriver");
  function storageReadable(key, value, start) {
    return {
      subscribe: storageWritable(key, value, start).subscribe
    };
  }
  __name(storageReadable, "storageReadable");
  function storageWritable(key, value, start) {
    function wrap_start(ogSet) {
      return start(/* @__PURE__ */ __name(function wrap_set(new_value) {
        if (storage) {
          storage.setItem(key, serialize(new_value));
        }
        return ogSet(new_value);
      }, "wrap_set"), /* @__PURE__ */ __name(function wrap_update(fn) {
        set(fn(get_store_value(ogStore)));
      }, "wrap_update"));
    }
    __name(wrap_start, "wrap_start");
    if (storage) {
      const storageValue = storage.getItem(key);
      try {
        if (storageValue) {
          value = deserialize(storageValue);
        }
      } catch (err) {
      }
      storage.setItem(key, serialize(value));
    }
    const ogStore = writable(value, start ? wrap_start : void 0);
    function set(new_value) {
      if (storage) {
        storage.setItem(key, serialize(new_value));
      }
      ogStore.set(new_value);
    }
    __name(set, "set");
    function update2(fn) {
      set(fn(get_store_value(ogStore)));
    }
    __name(update2, "update");
    function subscribe2(run2, invalidate) {
      return ogStore.subscribe(run2, invalidate);
    }
    __name(subscribe2, "subscribe");
    return { set, update: update2, subscribe: subscribe2 };
  }
  __name(storageWritable, "storageWritable");
  function storageDerived(key, stores, fn, initial_value) {
    const single = !Array.isArray(stores);
    const stores_array = single ? [stores] : stores;
    if (storage && storage.getItem(key)) {
      try {
        initial_value = deserialize(storage.getItem(key));
      } catch (err) {
      }
    }
    return storageReadable(key, initial_value, (set, update2) => {
      let inited = false;
      const values = [];
      let pending = 0;
      let cleanup;
      const sync = /* @__PURE__ */ __name(() => {
        if (pending) {
          return;
        }
        cleanup?.();
        const input = single ? values[0] : values;
        if (isSimpleDeriver(fn)) {
          set(fn(input));
        } else {
          const result = fn(input, set, update2);
          if (typeof result === "function") {
            cleanup = result;
          }
        }
      }, "sync");
      const unsubscribers = stores_array.map((store, i) => store.subscribe((value) => {
        values[i] = value;
        pending &= ~(1 << i);
        if (inited) {
          sync();
        }
      }, () => {
        pending |= 1 << i;
      }));
      inited = true;
      sync();
      return /* @__PURE__ */ __name(function stop() {
        unsubscribers.forEach((unsubscriber) => unsubscriber());
        cleanup?.();
      }, "stop");
    });
  }
  __name(storageDerived, "storageDerived");
  return {
    readable: storageReadable,
    writable: storageWritable,
    derived: storageDerived,
    storage,
    serialize,
    deserialize
  };
}
__name(storeGenerator, "storeGenerator");
const sessionStores = storeGenerator({ storage: globalThis?.sessionStorage });
class TJSWebStorage {
  static {
    __name(this, "TJSWebStorage");
  }
  /** @type {import('./').StorageStores} */
  #storageStores;
  /**
   * @type {(Map<string, {
   *    store: import('svelte/store').Writable,
   *    deserialize?: (value: string, ...rest: any[]) => any,
   *    serialize?: (value: any, ...rest: any[]) => string
   * }>)}
   */
  #stores = /* @__PURE__ */ new Map();
  /**
   * @param {import('./').StorageStores} storageStores - Provides a complete set of
   *        storage API store helper functions and the associated storage API instance and serializations strategy.
   */
  constructor(storageStores) {
    this.#storageStores = storageStores;
  }
  /**
   * Creates a new store for the given key.
   *
   * @template T
   *
   * @param {string}   key - Key to lookup in stores map.
   *
   * @param {T}        [defaultValue] - A default value to set for the store.
   *
   * @param {import('./').StorageStores} [storageStores] - Additional store creation options.
   *
   * @returns {import('svelte/store').Writable<T>} The new store.
   */
  #createStore(key, defaultValue = void 0, storageStores) {
    try {
      const value = this.#storageStores.storage.getItem(key);
      if (value !== null) {
        const deserialize = storageStores?.deserialize ?? this.#storageStores.deserialize;
        defaultValue = deserialize(value);
      }
    } catch (err) {
    }
    const writable2 = storageStores?.writable ?? this.#storageStores.writable;
    return writable2(key, defaultValue);
  }
  /**
   * @param {string}   key - Storage key.
   *
   * @returns {(value: string, ...rest: any[]) => any} Deserialize function.
   */
  #getDeserialize(key) {
    return this.#stores.get(key)?.deserialize ?? this.#storageStores.deserialize;
  }
  /**
   * @param {string}   key - Storage key.
   *
   * @returns {(value: any, ...rest: any[]) => string} Serialize function.
   */
  #getSerialize(key) {
    return this.#stores.get(key)?.serialize ?? this.#storageStores.serialize;
  }
  /**
   * Gets a store from the `stores` Map or creates a new store for the key and a given default value.
   *
   * @template T
   *
   * @param {string}   key - Key to lookup in stores map.
   *
   * @param {T}        [defaultValue] - A default value to set for the store.
   *
   * @param {import('./').StorageStores} [storageStores] - Additional store creation options.
   *
   * @returns {import('svelte/store').Writable<T>} The store for the given key.
   */
  #getStore(key, defaultValue = void 0, storageStores) {
    const storeEntry = this.#stores.get(key);
    if (storeEntry) {
      return storeEntry.store;
    }
    const store = this.#createStore(key, defaultValue, storageStores);
    this.#stores.set(key, {
      store,
      deserialize: storageStores?.deserialize,
      serialize: storageStores?.serialize
    });
    return store;
  }
  /**
   * Get value from the storage API.
   *
   * @param {string}   key - Key to lookup in storage API.
   *
   * @param {*}        [defaultValue] - A default value to return if key not present in session storage.
   *
   * @returns {*} Value from session storage or if not defined any default value provided.
   */
  getItem(key, defaultValue) {
    let value = defaultValue;
    const storageValue = this.#storageStores.storage.getItem(key);
    if (storageValue !== null) {
      try {
        value = this.#getDeserialize(key)(storageValue);
      } catch (err) {
        value = defaultValue;
      }
    } else if (defaultValue !== void 0) {
      try {
        const newValue = this.#getSerialize(key)(defaultValue);
        this.#storageStores.storage.setItem(key, newValue);
      } catch (err) {
      }
    }
    return value;
  }
  /**
   * Returns the backing Svelte store for the given key; potentially sets a default value if the key
   * is not already set.
   *
   * @template T
   *
   * @param {string}   key - Key to lookup in storage API.
   *
   * @param {T}        [defaultValue] - A default value to return if key not present in session storage.
   *
   * @param {import('./').StorageStores} [storageStores] - Additional store creation options.
   *
   * @returns {import('svelte/store').Writable<T>} The Svelte store for this key.
   */
  getStore(key, defaultValue, storageStores) {
    return this.#getStore(key, defaultValue, storageStores);
  }
  /**
   * Returns whether a store has already been created for the given key.
   *
   * @param {string}   key - Key to lookup in storage API.
   */
  hasStore(key) {
    return this.#stores.has(key);
  }
  /**
   * Sets the value for the given key in storage API.
   *
   * @param {string}   key - Key to lookup in storage API.
   *
   * @param {*}        value - A value to set for this key.
   */
  setItem(key, value) {
    const store = this.#getStore(key);
    store.set(value);
  }
  /**
   * Convenience method to swap a boolean value stored in storage API updating the associated store value.
   *
   * @param {string}   key - Key to lookup in storage API.
   *
   * @param {boolean}  [defaultValue] - A default value to return if key not present in session storage.
   *
   * @returns {boolean} The boolean swap for the given key.
   */
  swapItemBoolean(key, defaultValue) {
    const store = this.#getStore(key, defaultValue);
    let currentValue = false;
    try {
      currentValue = !!this.#getDeserialize(key)(this.#storageStores.storage.getItem(key));
    } catch (err) {
    }
    const newValue = typeof currentValue === "boolean" ? !currentValue : false;
    store.set(newValue);
    return newValue;
  }
  // Iterators ------------------------------------------------------------------------------------------------------
  /**
   * @template T
   *
   * Returns an iterable for the session storage keys and stores.
   *
   * @param {RegExp} [regex] - Optional regular expression to filter by storage keys.
   *
   * @returns {IterableIterator<[string, import('svelte/store').Writable<T>]>} Iterable iterator of keys and stores.
   * @yields {import('svelte/store').Writable<[string, Writable<T>]>}
   */
  *entries(regex = void 0) {
    if (regex !== void 0 && !CrossWindow.isRegExp(regex)) {
      throw new TypeError(`'regex' is not a RegExp`);
    }
    if (!this.#stores.size) {
      return void 0;
    }
    if (regex) {
      for (const key of this.#stores.keys()) {
        if (regex.test(key)) {
          yield [key, this.getStore(key)];
        }
      }
    } else {
      for (const key of this.#stores.keys()) {
        yield [key, this.getStore(key)];
      }
    }
  }
  /**
   * Returns an iterable for the session storage keys from existing stores.
   *
   * @param {RegExp} [regex] - Optional regular expression to filter by storage keys.
   *
   * @returns {IterableIterator<string>} Iterable iterator of session storage keys.
   * @yields {string}
   */
  *keys(regex = void 0) {
    if (regex !== void 0 && !CrossWindow.isRegExp(regex)) {
      throw new TypeError(`'regex' is not a RegExp`);
    }
    if (!this.#stores.size) {
      return void 0;
    }
    if (regex) {
      for (const key of this.#stores.keys()) {
        if (regex.test(key)) {
          yield key;
        }
      }
    } else {
      for (const key of this.#stores.keys()) {
        yield key;
      }
    }
  }
  /**
   * @template T
   *
   * Returns an iterable for the session storage stores.
   *
   * @param {RegExp} [regex] - Optional regular expression to filter by storage keys.
   *
   * @returns {IterableIterator<import('svelte/store').Writable<T>>} Iterable iterator of stores.
   * @yields {import('svelte/store').Writable<T>}
   */
  *stores(regex = void 0) {
    if (regex !== void 0 && !CrossWindow.isRegExp(regex)) {
      throw new TypeError(`'regex' is not a RegExp`);
    }
    if (!this.#stores.size) {
      return void 0;
    }
    if (regex) {
      for (const key of this.#stores.keys()) {
        if (regex.test(key)) {
          yield this.getStore(key);
        }
      }
    } else {
      for (const key of this.#stores.keys()) {
        yield this.getStore(key);
      }
    }
  }
}
class TJSSessionStorage extends TJSWebStorage {
  static {
    __name(this, "TJSSessionStorage");
  }
  constructor() {
    super(sessionStores);
  }
}
class SvelteReactive {
  static {
    __name(this, "SvelteReactive");
  }
  /**
   * @type {import('../SvelteApplication').SvelteApplication}
   */
  #application;
  /**
   * @type {boolean}
   */
  #initialized = false;
  /** @type {import('@typhonjs-fvtt/runtime/svelte/store/web-storage').WebStorage} */
  #sessionStorage;
  /**
   * The Application option store which is injected into mounted Svelte component context under the `external` key.
   *
   * @type {import('./types').StoreAppOptions}
   */
  #storeAppOptions;
  /**
   * Stores the update function for `#storeAppOptions`.
   *
   * @type {(this: void, updater: import('svelte/store').Updater<object>) => void}
   */
  #storeAppOptionsUpdate;
  /**
   * Stores the UI state data to make it accessible via getters.
   *
   * @type {object}
   */
  #dataUIState;
  /**
   * The UI option store which is injected into mounted Svelte component context under the `external` key.
   *
   * @type {import('./types').StoreUIOptions}
   */
  #storeUIState;
  /**
   * Stores the update function for `#storeUIState`.
   *
   * @type {(this: void, updater: import('svelte/store').Updater<object>) => void}
   */
  #storeUIStateUpdate;
  /**
   * Stores the unsubscribe functions from local store subscriptions.
   *
   * @type {import('svelte/store').Unsubscriber[]}
   */
  #storeUnsubscribe = [];
  /**
   * @param {import('../SvelteApplication').SvelteApplication} application - The host Foundry application.
   */
  constructor(application) {
    this.#application = application;
    const optionsSessionStorage = application?.options?.sessionStorage;
    if (optionsSessionStorage !== void 0 && !(optionsSessionStorage instanceof TJSWebStorage)) {
      throw new TypeError(`'options.sessionStorage' is not an instance of TJSWebStorage.`);
    }
    this.#sessionStorage = optionsSessionStorage !== void 0 ? optionsSessionStorage : new TJSSessionStorage();
  }
  /**
   * Initializes reactive support. Package private for internal use.
   *
   * @returns {SvelteReactiveStores | undefined} Internal methods to interact with Svelte stores.
   * @package
   * @internal
   */
  initialize() {
    if (this.#initialized) {
      return;
    }
    this.#initialized = true;
    this.#storesInitialize();
    return {
      appOptionsUpdate: this.#storeAppOptionsUpdate,
      uiStateUpdate: this.#storeUIStateUpdate,
      subscribe: this.#storesSubscribe.bind(this),
      unsubscribe: this.#storesUnsubscribe.bind(this)
    };
  }
  // Store getters -----------------------------------------------------------------------------------------------------
  /**
   * @returns {import('@typhonjs-fvtt/runtime/svelte/store/web-storage').WebStorage} Returns WebStorage (session) instance.
   */
  get sessionStorage() {
    return this.#sessionStorage;
  }
  /**
   * Returns the store for app options.
   *
   * @returns {import('./types').StoreAppOptions} App options store.
   */
  get storeAppOptions() {
    return this.#storeAppOptions;
  }
  /**
   * Returns the store for UI options.
   *
   * @returns {import('./types').StoreUIOptions} UI options store.
   */
  get storeUIState() {
    return this.#storeUIState;
  }
  // Only reactive getters ---------------------------------------------------------------------------------------------
  /**
   * Returns the current active Window / WindowProxy UI state.
   *
   * @returns {Window} Active window UI state.
   */
  get activeWindow() {
    return this.#dataUIState.activeWindow ?? globalThis;
  }
  /**
   * Returns the current dragging UI state.
   *
   * @returns {boolean} Dragging UI state.
   */
  get dragging() {
    return this.#dataUIState.dragging;
  }
  /**
   * Returns the current minimized UI state.
   *
   * @returns {boolean} Minimized UI state.
   */
  get minimized() {
    return this.#dataUIState.minimized;
  }
  /**
   * Returns the current resizing UI state.
   *
   * @returns {boolean} Resizing UI state.
   */
  get resizing() {
    return this.#dataUIState.resizing;
  }
  /**
   * Sets the current active Window / WindowProxy UI state.
   *
   * Note: This is protected usage and used internally.
   *
   * @param {Window} activeWindow - Active Window / WindowProxy UI state.
   */
  set activeWindow(activeWindow) {
    if (activeWindow === void 0 || activeWindow === null || Object.prototype.toString.call(activeWindow) === "[object Window]") {
      this.#storeUIStateUpdate((options) => deepMerge(options, { activeWindow: activeWindow ?? globalThis }));
    }
  }
  // Reactive getter / setters -----------------------------------------------------------------------------------------
  /**
   * Returns the draggable app option.
   *
   * @returns {boolean} Draggable app option.
   */
  get draggable() {
    return this.#application?.options?.draggable;
  }
  /**
   * Returns the focusAuto app option.
   *
   * @returns {boolean} When true auto-management of app focus is enabled.
   */
  get focusAuto() {
    return this.#application?.options?.focusAuto;
  }
  /**
   * Returns the focusKeep app option.
   *
   * @returns {boolean} When `focusAuto` and `focusKeep` is true; keeps internal focus.
   */
  get focusKeep() {
    return this.#application?.options?.focusKeep;
  }
  /**
   * Returns the focusTrap app option.
   *
   * @returns {boolean} When true focus trapping / wrapping is enabled keeping focus inside app.
   */
  get focusTrap() {
    return this.#application?.options?.focusTrap;
  }
  /**
   * Returns the headerButtonNoClose app option.
   *
   * @returns {boolean} Remove the close the button in header app option.
   */
  get headerButtonNoClose() {
    return this.#application?.options?.headerButtonNoClose;
  }
  /**
   * Returns the headerButtonNoLabel app option.
   *
   * @returns {boolean} Remove the labels from buttons in header app option.
   */
  get headerButtonNoLabel() {
    return this.#application?.options?.headerButtonNoLabel;
  }
  /**
   * Returns the headerIcon app option.
   *
   * @returns {string|void} URL for header app icon.
   */
  get headerIcon() {
    return this.#application?.options?.headerIcon;
  }
  /**
   * Returns the headerNoTitleMinimized app option.
   *
   * @returns {boolean} When true removes the header title when minimized.
   */
  get headerNoTitleMinimized() {
    return this.#application?.options?.headerNoTitleMinimized;
  }
  /**
   * Returns the minimizable app option.
   *
   * @returns {boolean} Minimizable app option.
   */
  get minimizable() {
    return this.#application?.options?.minimizable;
  }
  /**
   * Returns the Foundry popOut state; {@link Application.popOut}
   *
   * @returns {boolean} Positionable app option.
   */
  get popOut() {
    return this.#application.popOut;
  }
  /**
   * Returns the positionable app option; {@link SvelteApplicationOptions.positionable}
   *
   * @returns {boolean} Positionable app option.
   */
  get positionable() {
    return this.#application?.options?.positionable;
  }
  /**
   * Returns the resizable option.
   *
   * @returns {boolean} Resizable app option.
   */
  get resizable() {
    return this.#application?.options?.resizable;
  }
  /**
   * Returns the title accessor from the parent Application class; {@link Application.title}
   * TODO: Application v2; note that super.title localizes `this.options.title`; IMHO it shouldn't.
   *
   * @returns {string} Title.
   */
  get title() {
    return this.#application.title;
  }
  /**
   * Sets `this.options.draggable` which is reactive for application shells.
   *
   * @param {boolean}  draggable - Sets the draggable option.
   */
  set draggable(draggable2) {
    if (typeof draggable2 === "boolean") {
      this.setOptions("draggable", draggable2);
    }
  }
  /**
   * Sets `this.options.focusAuto` which is reactive for application shells.
   *
   * @param {boolean}  focusAuto - Sets the focusAuto option.
   */
  set focusAuto(focusAuto) {
    if (typeof focusAuto === "boolean") {
      this.setOptions("focusAuto", focusAuto);
    }
  }
  /**
   * Sets `this.options.focusKeep` which is reactive for application shells.
   *
   * @param {boolean}  focusKeep - Sets the focusKeep option.
   */
  set focusKeep(focusKeep) {
    if (typeof focusKeep === "boolean") {
      this.setOptions("focusKeep", focusKeep);
    }
  }
  /**
   * Sets `this.options.focusTrap` which is reactive for application shells.
   *
   * @param {boolean}  focusTrap - Sets the focusTrap option.
   */
  set focusTrap(focusTrap) {
    if (typeof focusTrap === "boolean") {
      this.setOptions("focusTrap", focusTrap);
    }
  }
  /**
   * Sets `this.options.headerButtonNoClose` which is reactive for application shells.
   *
   * @param {boolean}  headerButtonNoClose - Sets the headerButtonNoClose option.
   */
  set headerButtonNoClose(headerButtonNoClose) {
    if (typeof headerButtonNoClose === "boolean") {
      this.setOptions("headerButtonNoClose", headerButtonNoClose);
    }
  }
  /**
   * Sets `this.options.headerButtonNoLabel` which is reactive for application shells.
   *
   * @param {boolean}  headerButtonNoLabel - Sets the headerButtonNoLabel option.
   */
  set headerButtonNoLabel(headerButtonNoLabel) {
    if (typeof headerButtonNoLabel === "boolean") {
      this.setOptions("headerButtonNoLabel", headerButtonNoLabel);
    }
  }
  /**
   * Sets `this.options.headerIcon` which is reactive for application shells.
   *
   * @param {string | undefined}  headerIcon - Sets the headerButtonNoLabel option.
   */
  set headerIcon(headerIcon) {
    if (headerIcon === void 0 || typeof headerIcon === "string") {
      this.setOptions("headerIcon", headerIcon);
    }
  }
  /**
   * Sets `this.options.headerNoTitleMinimized` which is reactive for application shells.
   *
   * @param {boolean}  headerNoTitleMinimized - Sets the headerNoTitleMinimized option.
   */
  set headerNoTitleMinimized(headerNoTitleMinimized) {
    if (typeof headerNoTitleMinimized === "boolean") {
      this.setOptions("headerNoTitleMinimized", headerNoTitleMinimized);
    }
  }
  /**
   * Sets `this.options.minimizable` which is reactive for application shells that are also pop out.
   *
   * @param {boolean}  minimizable - Sets the minimizable option.
   */
  set minimizable(minimizable) {
    if (typeof minimizable === "boolean") {
      this.setOptions("minimizable", minimizable);
    }
  }
  /**
   * Sets `this.options.popOut` which is reactive for application shells. This will add / remove this application
   * from `ui.windows`.
   *
   * @param {boolean}  popOut - Sets the popOut option.
   */
  set popOut(popOut) {
    if (typeof popOut === "boolean") {
      this.setOptions("popOut", popOut);
    }
  }
  /**
   * Sets `this.options.positionable` enabling / disabling {@link SvelteApplication.position}.
   *
   * @param {boolean}  positionable - Sets the positionable option.
   */
  set positionable(positionable) {
    if (typeof positionable === "boolean") {
      this.setOptions("positionable", positionable);
    }
  }
  /**
   * Sets `this.options.resizable` which is reactive for application shells.
   *
   * @param {boolean}  resizable - Sets the resizable option.
   */
  set resizable(resizable) {
    if (typeof resizable === "boolean") {
      this.setOptions("resizable", resizable);
    }
  }
  /**
   * Sets `this.options.title` which is reactive for application shells.
   *
   * Note: Will set empty string if title is undefined or null.
   *
   * @param {string | undefined | null}   title - Application title; will be localized, so a translation key is fine.
   */
  set title(title) {
    if (typeof title === "string") {
      this.setOptions("title", title);
    } else if (title === void 0 || title === null) {
      this.setOptions("title", "");
    }
  }
  // Reactive Options API -------------------------------------------------------------------------------------------
  /**
   * Provides a way to safely get this applications options given an accessor string which describes the
   * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries
   * to walk.
   *
   * // TODO DOCUMENT the accessor in more detail.
   *
   * @param {string}   accessor - The path / key to set. You can set multiple levels.
   *
   * @param {*}        [defaultValue] - A default value returned if the accessor is not found.
   *
   * @returns {*} Value at the accessor.
   */
  getOptions(accessor, defaultValue) {
    return safeAccess(this.#application.options, accessor, defaultValue);
  }
  /**
   * Provides a way to merge `options` into this applications options and update the appOptions store.
   *
   * @param {object}   options - The options object to merge with `this.options`.
   */
  mergeOptions(options) {
    this.#storeAppOptionsUpdate((instanceOptions) => deepMerge(instanceOptions, options));
  }
  /**
   * Provides a way to safely set this applications options given an accessor string which describes the
   * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries
   * to walk.
   *
   * Additionally if an application shell Svelte component is mounted and exports the `appOptions` property then
   * the application options is set to `appOptions` potentially updating the application shell / Svelte component.
   *
   * // TODO DOCUMENT the accessor in more detail.
   *
   * @param {string}   accessor - The path / key to set. You can set multiple levels.
   *
   * @param {any}      value - Value to set.
   */
  setOptions(accessor, value) {
    const success = safeSet(this.#application.options, accessor, value);
    if (success) {
      this.#storeAppOptionsUpdate(() => this.#application.options);
    }
  }
  /**
   * Serializes the main {@link SvelteApplicationOptions} for common application state.
   *
   * @returns {import('./types').SvelteReactiveData} Common application state.
   */
  toJSON() {
    return {
      draggable: this.#application?.options?.draggable ?? true,
      focusAuto: this.#application?.options?.focusAuto ?? true,
      focusKeep: this.#application?.options?.focusKeep ?? false,
      focusTrap: this.#application?.options?.focusTrap ?? true,
      headerButtonNoClose: this.#application?.options?.headerButtonNoClose ?? false,
      headerButtonNoLabel: this.#application?.options?.headerButtonNoLabel ?? false,
      headerNoTitleMinimized: this.#application?.options?.headerNoTitleMinimized ?? false,
      minimizable: this.#application?.options?.minimizable ?? true,
      positionable: this.#application?.options?.positionable ?? true,
      resizable: this.#application?.options?.resizable ?? true
    };
  }
  /**
   * Updates the UI Options store with the current header buttons. You may dynamically add / remove header buttons
   * if using an application shell Svelte component. In either overriding `_getHeaderButtons` or responding to the
   * Hooks fired return a new button array and the uiOptions store is updated and the application shell will render
   * the new buttons.
   *
   * Optionally you can set in the SvelteApplication app options {@link SvelteApplicationOptions.headerButtonNoClose}
   * to remove the close button and {@link SvelteApplicationOptions.headerButtonNoLabel} to true and labels will be
   * removed from the header buttons.
   *
   * @param {object} [opts] - Optional parameters (for internal use)
   *
   * @param {boolean} [opts.headerButtonNoClose] - The value for `headerButtonNoClose`.
   *
   * @param {boolean} [opts.headerButtonNoLabel] - The value for `headerButtonNoLabel`.
   */
  updateHeaderButtons({
    headerButtonNoClose = this.#application.options.headerButtonNoClose,
    headerButtonNoLabel = this.#application.options.headerButtonNoLabel
  } = {}) {
    let buttons = this.#application._getHeaderButtons();
    if (typeof headerButtonNoClose === "boolean" && headerButtonNoClose) {
      buttons = buttons.filter((button) => button.class !== "close");
    }
    if (typeof headerButtonNoLabel === "boolean" && headerButtonNoLabel) {
      for (const button of buttons) {
        button.label = void 0;
      }
    }
    this.#storeUIStateUpdate((options) => {
      options.headerButtons = buttons;
      return options;
    });
  }
  // Internal implementation ----------------------------------------------------------------------------------------
  /**
   * Initializes the Svelte stores and derived stores for the application options and UI state.
   *
   * While writable stores are created the update method is stored in private variables locally and derived Readable
   * stores are provided for essential options which are commonly used.
   *
   * These stores are injected into all Svelte components mounted under the `external` context: `storeAppOptions` and
   * `storeUIState`.
   */
  #storesInitialize() {
    const writableAppOptions = writable(this.#application.options);
    this.#storeAppOptionsUpdate = writableAppOptions.update;
    const storeAppOptions = {
      subscribe: writableAppOptions.subscribe,
      draggable: propertyStore(writableAppOptions, "draggable"),
      focusAuto: propertyStore(writableAppOptions, "focusAuto"),
      focusKeep: propertyStore(writableAppOptions, "focusKeep"),
      focusTrap: propertyStore(writableAppOptions, "focusTrap"),
      headerButtonNoClose: propertyStore(writableAppOptions, "headerButtonNoClose"),
      headerButtonNoLabel: propertyStore(writableAppOptions, "headerButtonNoLabel"),
      headerIcon: propertyStore(writableAppOptions, "headerIcon"),
      headerNoTitleMinimized: propertyStore(writableAppOptions, "headerNoTitleMinimized"),
      minimizable: propertyStore(writableAppOptions, "minimizable"),
      popOut: propertyStore(writableAppOptions, "popOut"),
      positionable: propertyStore(writableAppOptions, "positionable"),
      resizable: propertyStore(writableAppOptions, "resizable"),
      title: propertyStore(writableAppOptions, "title")
    };
    Object.freeze(storeAppOptions);
    this.#storeAppOptions = storeAppOptions;
    this.#dataUIState = {
      activeWindow: globalThis,
      dragging: false,
      headerButtons: [],
      minimized: this.#application._minimized,
      resizing: false
    };
    const writableUIOptions = writable(this.#dataUIState);
    this.#storeUIStateUpdate = writableUIOptions.update;
    const storeUIState = {
      subscribe: writableUIOptions.subscribe,
      // activeWindow: propertyStore(writableUIOptions, 'activeWindow'),
      activeWindow: derived(writableUIOptions, ($options, set) => set($options.activeWindow)),
      dragging: propertyStore(writableUIOptions, "dragging"),
      headerButtons: derived(writableUIOptions, ($options, set) => set($options.headerButtons)),
      minimized: derived(writableUIOptions, ($options, set) => set($options.minimized)),
      resizing: propertyStore(writableUIOptions, "resizing")
    };
    Object.freeze(storeUIState);
    this.#storeUIState = storeUIState;
  }
  /**
   * Registers local store subscriptions for app options. `popOut` controls registering this app with `ui.windows`.
   *
   * @see SvelteApplication._injectHTML
   */
  #storesSubscribe() {
    this.#storeUnsubscribe.push(subscribeIgnoreFirst(this.#storeAppOptions.headerButtonNoClose, (value) => {
      this.updateHeaderButtons({ headerButtonNoClose: value });
    }));
    this.#storeUnsubscribe.push(subscribeIgnoreFirst(this.#storeAppOptions.headerButtonNoLabel, (value) => {
      this.updateHeaderButtons({ headerButtonNoLabel: value });
    }));
    this.#storeUnsubscribe.push(subscribeIgnoreFirst(this.#storeAppOptions.popOut, (value) => {
      if (value && this.#application.rendered) {
        globalThis.ui.windows[this.#application.appId] = this.#application;
      } else {
        delete globalThis.ui.windows[this.#application.appId];
      }
    }));
  }
  /**
   * Unsubscribes from any locally monitored stores.
   *
   * @see SvelteApplication.close
   */
  #storesUnsubscribe() {
    this.#storeUnsubscribe.forEach((unsubscribe) => unsubscribe());
    this.#storeUnsubscribe = [];
  }
}
const applicationShellContract = ["elementRoot"];
Object.freeze(applicationShellContract);
function isApplicationShell(component) {
  if (component === null || component === void 0) {
    return false;
  }
  let compHasContract = true;
  let protoHasContract = true;
  for (const accessor of applicationShellContract) {
    const descriptor = Object.getOwnPropertyDescriptor(component, accessor);
    if (descriptor === void 0 || descriptor.get === void 0 || descriptor.set === void 0) {
      compHasContract = false;
    }
  }
  const prototype = Object.getPrototypeOf(component);
  for (const accessor of applicationShellContract) {
    const descriptor = Object.getOwnPropertyDescriptor(prototype, accessor);
    if (descriptor === void 0 || descriptor.get === void 0 || descriptor.set === void 0) {
      protoHasContract = false;
    }
  }
  return compHasContract || protoHasContract;
}
__name(isApplicationShell, "isApplicationShell");
function loadSvelteConfig({ app, config, elementRootUpdate } = {}) {
  let target;
  if (CrossWindow.isHTMLElement(config.target)) {
    target = config.target;
  } else if (typeof config.target === "string") {
    const activeWindow = app?.reactive?.activeWindow;
    target = activeWindow?.document?.querySelector(config.target);
  }
  if (!CrossWindow.isHTMLElement(target)) {
    console.log(
      `%c[TRL] loadSvelteConfig error - Could not find target, '${config.target}', for config:
`,
      "background: rgb(57,34,34)",
      config
    );
    throw new Error();
  }
  const NewSvelteComponent = config.class;
  const svelteConfig = TJSSvelteConfigUtil.parseConfig({ ...config, target }, app);
  const externalContext = svelteConfig.context.get("#external");
  externalContext.application = app;
  externalContext.elementRootUpdate = elementRootUpdate;
  externalContext.sessionStorage = app.reactive.sessionStorage;
  let eventbus;
  if (isObject(app._eventbus) && typeof app._eventbus.createProxy === "function") {
    eventbus = app._eventbus.createProxy();
    externalContext.eventbus = eventbus;
  }
  Object.seal(externalContext);
  const component = new NewSvelteComponent(svelteConfig);
  svelteConfig.eventbus = eventbus;
  let element2;
  if (isApplicationShell(component)) {
    element2 = component.elementRoot;
  }
  if (!CrossWindow.isHTMLElement(element2)) {
    console.log(
      `%c[TRL] loadSvelteConfig error - No application shell contract found. Did you bind and export a HTMLElement as 'elementRoot' and include '<svelte:options accessors={true}/>'?

Offending config:
`,
      "background: rgb(57,34,34)",
      config
    );
    throw new Error();
  }
  return { config: svelteConfig, component, element: element2 };
}
__name(loadSvelteConfig, "loadSvelteConfig");
class TJSAppIndex {
  static {
    __name(this, "TJSAppIndex");
  }
  /**
   * Stores all visible / rendered apps.
   *
   * @type {Map<string, import('@typhonjs-fvtt/runtime/svelte/application').SvelteApplication>}
   */
  static #visibleApps = /* @__PURE__ */ new Map();
  /**
   * Adds a SvelteApplication to all visible apps tracked.
   *
   * @param {import('@typhonjs-fvtt/runtime/svelte/application').SvelteApplication} app - A SvelteApplication
   *
   * @package
   */
  static add(app) {
    this.#visibleApps.set(app.id, app);
  }
  /**
   * Removes a SvelteApplication from all visible apps tracked.
   *
   * @param {import('@typhonjs-fvtt/runtime/svelte/application').SvelteApplication} app - A SvelteApplication
   *
   * @package
   */
  static delete(app) {
    this.#visibleApps.delete(app.id);
  }
  /**
   * Gets a particular app by ID.
   *
   * @param {string}   key - App ID.
   *
   * @returns {import('@typhonjs-fvtt/runtime/svelte/application').SvelteApplication} Associated app.
   */
  static get(key) {
    return this.#visibleApps.get(key);
  }
  /**
   * Returns whether an associated app by ID is being tracked.
   *
   * @param {string}   key - App ID.
   *
   * @returns {boolean} The given App ID is visible.
   */
  static has(key) {
    return this.#visibleApps.has(key);
  }
  /**
   * @returns {IterableIterator<string>} All visible app IDs.
   */
  static keys() {
    return this.#visibleApps.keys();
  }
  /**
   * @returns {IterableIterator<import('@typhonjs-fvtt/runtime/svelte/application').SvelteApplication>} All visible apps.
   */
  static values() {
    return this.#visibleApps.values();
  }
}
class SvelteApplication extends Application {
  static {
    __name(this, "SvelteApplication");
  }
  /**
   * Stores the first mounted component which follows the application shell contract.
   *
   * @type {import('./internal/state-svelte/types').MountedAppShell[] | null[]} Application shell.
   */
  #applicationShellHolder = [null];
  /**
   * Stores and manages application state for saving / restoring / serializing.
   *
   * @type {ApplicationState}
   */
  #applicationState;
  /**
   * Stores the target element which may not necessarily be the main element.
   *
   * @type {HTMLElement}
   */
  #elementTarget = null;
  /**
   * Stores the content element which is set for application shells.
   *
   * @type {HTMLElement}
   */
  #elementContent = null;
  /**
   * On initial render gating of `setPosition` invoked by `Application._render` occurs, so that percentage values
   * can correctly be positioned with initial helper constraints (centered).
   *
   * @type {boolean}
   */
  #gateSetPosition = false;
  /**
   * Stores initial z-index from `_renderOuter` to set to target element / Svelte component.
   *
   * @type {number}
   */
  #initialZIndex = 95;
  /**
   * Stores on mount state which is checked in _render to trigger onSvelteMount callback.
   *
   * @type {boolean}
   */
  #onMount = false;
  /**
   * The position store.
   *
   * @type {TJSPosition}
   */
  #position;
  /**
   * Contains the Svelte stores and reactive accessors.
   *
   * @type {SvelteReactive}
   */
  #reactive;
  /**
   * Stores SvelteData entries with instantiated Svelte components.
   *
   * @type {import('./internal/state-svelte/types').SvelteData[]}
   */
  #svelteData = [];
  /**
   * Provides a helper class that combines multiple methods for interacting with the mounted components tracked in
   * #svelteData.
   *
   * @type {GetSvelteData}
   */
  #getSvelteData = new GetSvelteData(this.#applicationShellHolder, this.#svelteData);
  /**
   * Contains methods to interact with the Svelte stores.
   *
   * @type {import('./internal/state-reactive/SvelteReactive').SvelteReactiveStores}
   */
  #stores;
  /**
   * @param {import('@typhonjs-fvtt/runtime/svelte/application').SvelteApplicationOptions} options - The options for the application.
   *
   * @inheritDoc
   */
  constructor(options = {}) {
    super(options);
    if (!isObject(this.options.svelte)) {
      throw new Error(`SvelteApplication - constructor - No Svelte configuration object found in 'options'.`);
    }
    this.#applicationState = new ApplicationState(this);
    this.#position = new TJSPosition(this, {
      ...this.position,
      ...this.options,
      initial: this.options.positionInitial,
      ortho: this.options.positionOrtho,
      validator: this.options.positionValidator
    });
    delete this.position;
    Object.defineProperty(this, "position", {
      get: () => this.#position,
      set: (position) => {
        if (isObject(position)) {
          this.#position.set(position);
        }
      }
    });
    this.#reactive = new SvelteReactive(this);
    this.#stores = this.#reactive.initialize();
  }
  /**
   * Specifies the default options that SvelteApplication supports.
   *
   * @returns {import('@typhonjs-fvtt/runtime/svelte/application').SvelteApplicationOptions} options - Application options.
   * @see https://foundryvtt.com/api/interfaces/client.ApplicationOptions.html
   *
   * @internal
   */
  static get defaultOptions() {
    return deepMerge(super.defaultOptions, {
      defaultCloseAnimation: true,
      // If false the default slide close animation is not run.
      draggable: true,
      // If true then application shells are draggable.
      focusAuto: true,
      // When true auto-management of app focus is enabled.
      focusKeep: false,
      // When `focusAuto` and `focusKeep` is true; keeps internal focus.
      focusSource: void 0,
      // Stores any A11yFocusSource data that is applied when app is closed.
      focusTrap: true,
      // When true focus trapping / wrapping is enabled keeping focus inside app.
      headerButtonNoClose: false,
      // If true then the close header button is removed.
      headerButtonNoLabel: false,
      // If true then header button labels are removed for application shells.
      headerIcon: void 0,
      // Sets a header icon given an image URL.
      headerNoTitleMinimized: false,
      // If true then header title is hidden when application is minimized.
      minHeight: MIN_WINDOW_HEIGHT,
      // Assigned to position. Number specifying minimum window height.
      minWidth: MIN_WINDOW_WIDTH,
      // Assigned to position. Number specifying minimum window width.
      positionable: true,
      // If false then `position.set` does not take effect.
      positionInitial: TJSPosition.Initial.browserCentered,
      // A helper for initial position placement.
      positionOrtho: true,
      // When true TJSPosition is optimized for orthographic use.
      positionValidator: TJSPosition.Validators.transformWindow,
      // A function providing the default validator.
      sessionStorage: void 0,
      // An instance of WebStorage (session) to share across SvelteApplications.
      svelte: void 0,
      // A Svelte configuration object.
      transformOrigin: "top left"
      // By default, 'top / left' respects rotation when minimizing.
    });
  }
  /**
   * Returns the content element if an application shell is mounted.
   *
   * @returns {HTMLElement} Content element.
   */
  get elementContent() {
    return this.#elementContent;
  }
  /**
   * Returns the target element or main element if no target defined.
   *
   * @returns {HTMLElement} Target element.
   */
  get elementTarget() {
    return this.#elementTarget;
  }
  /**
   * Returns the reactive accessors & Svelte stores for SvelteApplication.
   *
   * @returns {import('./internal/state-reactive/types').SvelteReactive} The reactive accessors & Svelte stores.
   */
  get reactive() {
    return this.#reactive;
  }
  /**
   * Returns the application state manager.
   *
   * @returns {import('./internal/state-app/types').ApplicationState} The application state manager.
   */
  get state() {
    return this.#applicationState;
  }
  /**
   * Returns the Svelte helper class w/ various methods to access mounted Svelte components.
   *
   * @returns {import('./internal/state-svelte/types').GetSvelteData} GetSvelteData
   */
  get svelte() {
    return this.#getSvelteData;
  }
  /**
   * In this case of when a template is defined in app options `html` references the inner HTML / template. However,
   * to activate classic v1 tabs for a Svelte component the element target is passed as an array simulating JQuery as
   * the element is retrieved immediately and the core listeners use standard DOM queries.
   *
   * @protected
   * @ignore
   * @internal
   */
  _activateCoreListeners(html) {
    super._activateCoreListeners(typeof this.options.template === "string" ? html : [this.popOut ? this.#elementTarget?.firstChild : this.#elementTarget]);
  }
  /**
   * Provide an override to set this application as the active window regardless of z-index. Changes behaviour from
   * Foundry core.
   *
   * @param {object} [opts] - Optional parameters.
   *
   * @param {boolean} [opts.focus=true] - When true and the active element is not contained in the app `elementTarget`
   *        is focused..
   *
   * @param {boolean} [opts.force=false] - Force bring to top; will increment z-index by popOut order.
   *
   * @ignore
   * @internal
   */
  bringToTop({ focus = true, force = false } = {}) {
    if (this.reactive.activeWindow !== globalThis) {
      return;
    }
    if (force || this.popOut) {
      super.bringToTop();
    }
    const elementTarget = this.elementTarget;
    const activeElement = document.activeElement;
    if (focus && elementTarget && activeElement !== elementTarget && !elementTarget?.contains(activeElement)) {
      if (A11yHelper.isFocusTarget(activeElement)) {
        activeElement.blur();
      }
      elementTarget?.focus();
    }
    globalThis.ui.activeWindow = this;
  }
  /**
   * Note: This method is fully overridden and duplicated as Svelte components need to be destroyed manually and the
   * best visual result is to destroy them after the default slide up animation occurs, but before the element
   * is removed from the DOM.
   *
   * If you destroy the Svelte components before the slide up animation the Svelte elements are removed immediately
   * from the DOM. The purpose of overriding ensures the slide up animation is always completed before
   * the Svelte components are destroyed and then the element is removed from the DOM.
   *
   * Close the application and unregisters references to it within UI mappings.
   * This function returns a Promise which resolves once the window closing animation concludes.
   *
   * @param {object}   [options] - Optional parameters.
   *
   * @param {boolean}  [options.force] - Force close regardless of render state.
   *
   * @returns {Promise<void>}    A Promise which resolves once the application is closed.
   *
   * @ignore
   * @internal
   */
  async close(options = {}) {
    const states = Application.RENDER_STATES;
    if (!options.force && ![states.RENDERED, states.ERROR].includes(this._state)) {
      return;
    }
    const el = this.#elementTarget;
    if (!el) {
      this._state = states.CLOSED;
      return;
    }
    if (CrossWindow.getWindow(el, { throws: false }) !== globalThis) {
      return;
    }
    this._state = states.CLOSING;
    this.#stores.unsubscribe();
    const content = el.querySelector(".window-content");
    if (content) {
      content.style.overflow = "hidden";
      for (let cntr = content.children.length; --cntr >= 0; ) {
        content.children[cntr].style.overflow = "hidden";
      }
    }
    for (const cls of this.constructor._getInheritanceChain()) {
      Hooks.call(`close${cls.name}`, this, $(el));
    }
    const animate = typeof this.options.defaultCloseAnimation === "boolean" ? this.options.defaultCloseAnimation : true;
    if (animate) {
      el.style.minHeight = "0";
      const { paddingBottom, paddingTop } = globalThis.getComputedStyle(el);
      await el.animate([
        { maxHeight: `${el.clientHeight}px`, paddingTop, paddingBottom },
        { maxHeight: 0, paddingTop: 0, paddingBottom: 0 }
      ], { duration: 250, easing: "ease-in", fill: "forwards" }).finished;
    }
    const svelteDestroyPromises = [];
    for (const entry of this.#svelteData) {
      svelteDestroyPromises.push(TJSSvelteUtil.outroAndDestroy(entry.component));
      const eventbus = entry.config.eventbus;
      if (isObject(eventbus) && typeof eventbus.off === "function") {
        eventbus.off();
        entry.config.eventbus = void 0;
      }
    }
    await Promise.allSettled(svelteDestroyPromises);
    TJSAppIndex.delete(this);
    this.#svelteData.length = 0;
    el.remove();
    this.position.state.restore({
      name: "#beforeMinimized",
      properties: ["width", "height"],
      silent: true,
      remove: true
    });
    this.#applicationShellHolder[0] = null;
    this._element = null;
    this.#elementContent = null;
    this.#elementTarget = null;
    delete globalThis.ui.windows[this.appId];
    this._minimized = false;
    this._scrollPositions = null;
    this._state = states.CLOSED;
    this.#onMount = false;
    this.#stores.uiStateUpdate((storeOptions) => deepMerge(storeOptions, { minimized: this._minimized }));
    A11yHelper.applyFocusSource(this.options.focusSource);
    delete this.options.focusSource;
  }
  /**
   * Inject the Svelte components defined in `this.options.svelte`. The Svelte component can attach to the existing
   * pop-out of Application or provide no template and render into a document fragment which is then attached to the
   * DOM.
   *
   * @protected
   * @ignore
   * @internal
   */
  _injectHTML() {
    this.reactive.updateHeaderButtons();
    const elementRootUpdate = /* @__PURE__ */ __name(() => {
      let cntr = 0;
      return (elementRoot) => {
        if (elementRoot !== null && elementRoot !== void 0 && cntr++ > 0) {
          this.#updateApplicationShell();
          return true;
        }
        return false;
      };
    }, "elementRootUpdate");
    if (!isObject(this.options.svelte)) {
      throw new Error(`SvelteApplication - _injectHTML - No Svelte configuration object found in 'options'.`);
    }
    const svelteData = loadSvelteConfig({
      app: this,
      config: this.options.svelte,
      elementRootUpdate
    });
    if (this.svelte.applicationShell !== null) {
      throw new Error(
        `SvelteApplication - _injectHTML - An application shell is already mounted; offending config:
${JSON.stringify(this.options.svelte)}`
      );
    }
    this.#applicationShellHolder[0] = svelteData.component;
    if (TJSSvelteUtil.isHMRProxy(svelteData.component) && Array.isArray(svelteData.component?.$$?.on_hmr)) {
      svelteData.component.$$.on_hmr.push(() => () => this.#updateApplicationShell());
    }
    this.#svelteData.push(svelteData);
    this._element = $(this.svelte.applicationShell.elementRoot);
    this.#elementContent = hasGetter(this.svelte.applicationShell, "elementContent") ? this.svelte.applicationShell.elementContent : null;
    this.#elementTarget = hasGetter(this.svelte.applicationShell, "elementTarget") ? this.svelte.applicationShell.elementTarget : this.svelte.applicationShell.elementRoot;
    if (typeof this.options.positionable === "boolean" && this.options.positionable) {
      this.#elementTarget.style.zIndex = typeof this.options.zIndex === "number" ? this.options.zIndex : this.#initialZIndex ?? 95;
    }
    this.#stores.subscribe();
  }
  /**
   * Provides a mechanism to update the UI options store for maximized.
   *
   * Note: the sanity check is duplicated from {@link Application.maximize} the store is updated _before_
   * performing the rest of animations. This allows application shells to remove / show any resize handlers
   * correctly. Extra constraint data is stored in a saved position state in {@link SvelteApplication.minimize}
   * to animate the content area.
   *
   * @param {object}   [opts] - Optional parameters.
   *
   * @param {boolean}  [opts.animate=true] - When true perform default maximizing animation.
   *
   * @param {number}   [opts.duration=0.1] - Controls content area animation duration in seconds.
   */
  async maximize({ animate = true, duration = 0.1 } = {}) {
    if (!this.popOut || [false, null].includes(this._minimized)) {
      return;
    }
    this._minimized = null;
    const durationMS = duration * 1e3;
    const element2 = this.elementTarget;
    const header = element2.querySelector(".window-header");
    const content = element2.querySelector(".window-content");
    const positionBefore = this.position.state.get({ name: "#beforeMinimized" });
    if (animate) {
      await this.position.state.restore({
        name: "#beforeMinimized",
        async: true,
        animateTo: true,
        properties: ["width"],
        duration: 0.1
      });
    }
    element2.classList.remove("minimized");
    for (let cntr = header.children.length; --cntr >= 0; ) {
      header.children[cntr].style.display = null;
    }
    content.style.display = null;
    let constraints;
    if (animate) {
      ({ constraints } = this.position.state.restore({
        name: "#beforeMinimized",
        animateTo: true,
        properties: ["height"],
        remove: true,
        duration
      }));
    } else {
      ({ constraints } = this.position.state.remove({ name: "#beforeMinimized" }));
    }
    await content.animate([
      { maxHeight: 0, paddingTop: 0, paddingBottom: 0, offset: 0 },
      { ...constraints, offset: 1 },
      { maxHeight: "100%", offset: 1 }
    ], { duration: durationMS, fill: "forwards" }).finished;
    this.position.set({
      minHeight: positionBefore.minHeight ?? this.options?.minHeight ?? MIN_WINDOW_HEIGHT,
      minWidth: positionBefore.minWidth ?? this.options?.minWidth ?? MIN_WINDOW_WIDTH
    });
    element2.style.minWidth = null;
    element2.style.minHeight = null;
    this._minimized = false;
    setTimeout(() => {
      content.style.overflow = null;
      for (let cntr = content.children.length; --cntr >= 0; ) {
        content.children[cntr].style.overflow = null;
      }
    }, 50);
    this.#stores.uiStateUpdate((options) => deepMerge(options, { minimized: false }));
  }
  /**
   * Provides a mechanism to update the UI options store for minimized.
   *
   * Note: the sanity check is duplicated from {@link Application.minimize} the store is updated _before_
   * performing the rest of animations. This allows application shells to remove / show any resize handlers
   * correctly. Extra constraint data is stored in a saved position state in {@link SvelteApplication.minimize}
   * to animate the content area.
   *
   * @param {object}   [opts] - Optional parameters.
   *
   * @param {boolean}  [opts.animate=true] - When true perform default minimizing animation.
   *
   * @param {number}   [opts.duration=0.1] - Controls content area animation duration in seconds.
   */
  async minimize({ animate = true, duration = 0.1 } = {}) {
    if (!this.rendered || !this.popOut || [true, null].includes(this._minimized)) {
      return;
    }
    this.#stores.uiStateUpdate((options) => deepMerge(options, { minimized: true }));
    this._minimized = null;
    const durationMS = duration * 1e3;
    const element2 = this.elementTarget;
    const header = element2.querySelector(".window-header");
    const content = element2.querySelector(".window-content");
    const beforeMinWidth = this.position.minWidth;
    const beforeMinHeight = this.position.minHeight;
    this.position.set({ minWidth: 100, minHeight: 30 });
    element2.style.minWidth = "100px";
    element2.style.minHeight = "30px";
    if (content) {
      content.style.overflow = "hidden";
      for (let cntr = content.children.length; --cntr >= 0; ) {
        content.children[cntr].style.overflow = "hidden";
      }
    }
    const { paddingBottom, paddingTop } = globalThis.getComputedStyle(content);
    const constraints = {
      maxHeight: `${content.clientHeight}px`,
      paddingTop,
      paddingBottom
    };
    if (animate) {
      const animation = content.animate([
        constraints,
        { maxHeight: 0, paddingTop: 0, paddingBottom: 0 }
      ], { duration: durationMS, fill: "forwards" });
      animation.finished.then(() => content.style.display = "none");
    } else {
      setTimeout(() => content.style.display = "none", durationMS);
    }
    const saved = this.position.state.save({ name: "#beforeMinimized", constraints });
    saved.minWidth = beforeMinWidth;
    saved.minHeight = beforeMinHeight;
    const headerOffsetHeight = header.offsetHeight;
    this.position.minHeight = headerOffsetHeight;
    if (animate) {
      await this.position.animate.to({ height: headerOffsetHeight }, { duration }).finished;
    }
    for (let cntr = header.children.length; --cntr >= 0; ) {
      const className = header.children[cntr].className;
      if (className.includes("window-title") || className.includes("close")) {
        continue;
      }
      if (className.includes("keep-minimized")) {
        header.children[cntr].style.display = "block";
        continue;
      }
      header.children[cntr].style.display = "none";
    }
    if (animate) {
      await this.position.animate.to({ width: MIN_WINDOW_WIDTH }, { duration: 0.1 }).finished;
    }
    element2.classList.add("minimized");
    this._minimized = true;
  }
  /**
   * Provides a callback after all Svelte components are initialized.
   *
   * @param {import('./internal/state-svelte/types').MountedAppShell} [mountedAppShell] - The mounted app shell
   *        elements.
   */
  onSvelteMount(mountedAppShell) {
  }
  // eslint-disable-line no-unused-vars
  /**
   * Provides a callback after the main application shell is remounted. This may occur during HMR / hot module
   * replacement or directly invoked from the `elementRootUpdate` callback passed to the application shell component
   * context.
   *
   * @param {import('./internal/state-svelte/types').MountedAppShell} [mountedAppShell] - The mounted app shell
   *        elements.
   */
  onSvelteRemount(mountedAppShell) {
  }
  // eslint-disable-line no-unused-vars
  /**
   * Override replacing HTML as Svelte components control the rendering process. Only potentially change the outer
   * application frame / title for pop-out applications.
   *
   * @protected
   * @ignore
   * @internal
   */
  _replaceHTML(element2, html) {
    if (!element2.length) {
      return;
    }
    this.reactive.updateHeaderButtons();
  }
  /**
   * Provides an override verifying that a new Application being rendered for the first time doesn't have a
   * corresponding DOM element already loaded. This is a check that only occurs when `this._state` is
   * `Application.RENDER_STATES.NONE`. It is useful in particular when SvelteApplication has a static ID
   * explicitly set in `this.options.id` and long intro / outro transitions are assigned. If a new application
   * sharing this static ID attempts to open / render for the first time while an existing DOM element sharing
   * this static ID exists then the initial render is cancelled below rather than crashing later in the render
   * cycle {@link TJSPosition.set}.
   *
   * @protected
   * @ignore
   * @internal
   */
  async _render(force = false, options = {}) {
    if (isObject(options?.focusSource)) {
      this.options.focusSource = options.focusSource;
    }
    const activeWindow = this.reactive.activeWindow;
    try {
      if (this._state === Application.RENDER_STATES.NONE && A11yHelper.isFocusTarget(activeWindow.document.querySelector(`#${this.id}`))) {
        console.warn(`SvelteApplication - _render: A DOM element already exists for CSS ID '${this.id}'. Cancelling initial render for new application with appId '${this.appId}'.`);
        return;
      }
    } catch (err) {
      console.warn(`SvelteApplication - _render: Potentially malformed application ID '${this.id}'. Cancelling initial render for new application with appId '${this.appId}'.`);
      return;
    }
    this.#gateSetPosition = true;
    await super._render(force, options);
    this.#gateSetPosition = false;
    if ([Application.RENDER_STATES.CLOSING, Application.RENDER_STATES.RENDERING].includes(this._state)) {
      return;
    }
    if (!force && this._state <= Application.RENDER_STATES.NONE) {
      return;
    }
    if (!this._minimized) {
      this.#position.set({
        left: typeof this.options?.left === "string" ? this.options.left : void 0,
        height: typeof this.options?.height === "string" ? this.options.height : void 0,
        maxHeight: typeof this.options?.maxHeight === "string" ? this.options.maxHeight : void 0,
        maxWidth: typeof this.options?.maxWidth === "string" ? this.options.maxWidth : void 0,
        minHeight: typeof this.options?.minHeight === "string" ? this.options.minHeight : void 0,
        minWidth: typeof this.options?.minWidth === "string" ? this.options.minWidth : void 0,
        rotateX: typeof this.options?.rotateX === "string" ? this.options.rotateX : void 0,
        rotateY: typeof this.options?.rotateY === "string" ? this.options.rotateY : void 0,
        rotateZ: typeof this.options?.rotateZ === "string" ? this.options.rotateZ : void 0,
        rotation: typeof this.options?.rotation === "string" ? this.options.rotation : void 0,
        top: typeof this.options?.top === "string" ? this.options.top : void 0,
        width: typeof this.options?.width === "string" ? this.options.width : void 0,
        ...options
      });
    }
    if (!this.#onMount) {
      TJSAppIndex.add(this);
      this.onSvelteMount({
        elementRoot: (
          /** @type {HTMLElement} */
          this._element[0]
        ),
        elementContent: this.#elementContent,
        elementTarget: this.#elementTarget
      });
      this.#onMount = true;
    }
  }
  /**
   * Render the inner application content. Provide an empty JQuery element per the core Foundry API.
   *
   * @protected
   * @ignore
   * @internal
   */
  async _renderInner() {
    const activeWindow = this.reactive.activeWindow;
    const html = activeWindow.document.createDocumentFragment();
    return $(html);
  }
  /**
   * Stores the initial z-index set in `_renderOuter` which is used in `_injectHTML` to set the target element
   * z-index after the Svelte component is mounted.
   *
   * @protected
   * @ignore
   * @internal
   */
  async _renderOuter() {
    const html = await super._renderOuter();
    this.#initialZIndex = html[0].style.zIndex;
    return html;
  }
  /**
   * All calculation and updates of position are implemented in {@link TJSPosition.set}. This allows position to be
   * fully reactive and in control of updating inline styles for the application.
   *
   * This method remains for backward compatibility with Foundry. If you have a custom override quite likely you need
   * to update to using the {@link TJSPosition.validators} / ValidatorAPI functionality.
   *
   * @param {import('@typhonjs-fvtt/runtime/svelte/store/position').Data.TJSPositionDataRelative}   [position] - TJSPosition data.
   *
   * @returns {TJSPosition} The updated position object for the application containing the new values.
   * @ignore
   */
  setPosition(position) {
    return !this.#gateSetPosition ? this.position.set(position) : this.position;
  }
  /**
   * This method is invoked by the `elementRootUpdate` callback that is added to the external context passed to
   * Svelte components. When invoked it updates the local element roots tracked by SvelteApplication.
   *
   * This method may also be invoked by HMR / hot module replacement via `svelte-hmr`.
   */
  #updateApplicationShell() {
    const applicationShell = this.svelte.applicationShell;
    if (applicationShell !== null) {
      this._element = $(applicationShell.elementRoot);
      this.#elementContent = hasGetter(applicationShell, "elementContent") ? applicationShell.elementContent : null;
      this.#elementTarget = hasGetter(applicationShell, "elementTarget") ? applicationShell.elementTarget : null;
      if (this.#elementTarget === null) {
        this.#elementTarget = typeof this.options.selectorTarget === "string" ? this._element[0].querySelector(this.options.selectorTarget) : this._element[0];
      }
      if (typeof this.options.positionable === "boolean" && this.options.positionable) {
        this.#elementTarget.style.zIndex = typeof this.options.zIndex === "number" ? this.options.zIndex : this.#initialZIndex ?? 95;
        super.bringToTop();
        this.position.set(this.position.get());
      }
      super._activateCoreListeners([this.popOut ? this.#elementTarget?.firstChild : this.#elementTarget]);
      this.onSvelteRemount({
        elementRoot: (
          /** @type {HTMLElement} */
          this._element[0]
        ),
        elementContent: this.#elementContent,
        elementTarget: this.#elementTarget
      });
    }
  }
}
class PopoutSupport {
  static {
    __name(this, "PopoutSupport");
  }
  static initialize() {
    Hooks.on("PopOut:loading", (app, popout) => {
      if (app instanceof SvelteApplication) {
        app.position.enabled = false;
        app.state.save({
          name: "#beforePopout",
          headerButtonNoClose: app.reactive.headerButtonNoClose
        });
        app.reactive.activeWindow = popout;
        app.reactive.headerButtonNoClose = true;
      }
    });
    Hooks.on("PopOut:popin", (app) => this.#handleRejoin(app));
    Hooks.on("PopOut:close", (app) => this.#handleRejoin(app));
  }
  /**
   * Handles rejoining the app to main browser window.
   *
   * @param {Application} app - The target app.
   */
  static #handleRejoin(app) {
    if (app instanceof SvelteApplication) {
      app.position.enabled = true;
      const beforeData = app.state.remove({ name: "#beforePopout" });
      if (beforeData) {
        app.reactive.headerButtonNoClose = beforeData?.headerButtonNoClose ?? false;
      }
      app.reactive.activeWindow = void 0;
    }
  }
}
PopoutSupport.initialize();
const version = "0.1.45";
class WelcomeApplication extends SvelteApplication {
  static {
    __name(this, "WelcomeApplication");
  }
  /**
   * Default Application options
   * @return {object} options - Application options.
   * @see https://foundryvtt.com/api/interfaces/client.ApplicationOptions.html
   */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      id: `${SYSTEM_ID}--welcome`,
      classes: [SYSTEM_CODE],
      resizable: true,
      minimizable: true,
      width: 600,
      height: 700,
      // headerIcon: 'systems/foundryvtt-final-fantasy/assets/critical.svg',
      title: game.i18n.localize(`${SYSTEM_CODE}.SystemName`) + " v" + version,
      headerIcon: "systems/foundryvtt-final-fantasy/assets/aardvark-claw.webp",
      svelte: {
        class: WelcomeAppShell,
        target: document.body,
        intro: true,
        props: {
          version
          // A prop passed to HelloFoundryAppShell for the initial message displayed.
        }
      }
    });
  }
}
function canvasReady() {
  Hooks.once("ready", async () => {
    if (!game.settings.get(SYSTEM_ID, "dontShowWelcome")) {
      new WelcomeApplication().render(true, { focus: true });
    }
  });
}
__name(canvasReady, "canvasReady");
function registerSettings() {
  dontShowWelcome();
  applicationWindowHeaderIconsOnly();
  confirmBeforeDeletingActorItem();
  chatMessageSound();
  showStatusEffectNames();
  manualInitiative();
  showChatProfileImages();
  chatMessageSenderIsActorOwner();
  automaticUses();
  defaultChatDescriptionVisible();
}
__name(registerSettings, "registerSettings");
function automaticUses() {
  gameSettings.register({
    namespace: SYSTEM_ID,
    key: "automaticUses",
    options: {
      name: localize$1("Setting.automaticUses.Name"),
      hint: localize$1("Setting.automaticUses.Hint"),
      scope: "user",
      config: true,
      default: true,
      type: Boolean
    }
  });
}
__name(automaticUses, "automaticUses");
function chatMessageSenderIsActorOwner() {
  gameSettings.register({
    namespace: SYSTEM_ID,
    key: "chatMessageSenderIsActorOwner",
    options: {
      name: localize$1("Setting.chatMessageSenderIsActorOwner.Name"),
      hint: localize$1("Setting.chatMessageSenderIsActorOwner.Hint"),
      scope: "user",
      config: true,
      default: true,
      type: Boolean
    }
  });
}
__name(chatMessageSenderIsActorOwner, "chatMessageSenderIsActorOwner");
function manualInitiative() {
  gameSettings.register({
    namespace: SYSTEM_ID,
    key: "manual-initiative",
    options: {
      name: localize$1("Setting.ManualInitiative.Name"),
      hint: localize$1("Setting.ManualInitiative.Hint"),
      scope: "world",
      config: true,
      default: true,
      type: Boolean
    }
  });
}
__name(manualInitiative, "manualInitiative");
function showStatusEffectNames() {
  gameSettings.register({
    namespace: SYSTEM_ID,
    key: "show-status-effect-names",
    options: {
      name: localize$1("Setting.ShowStatusEffects.Name"),
      hint: localize$1("Setting.ShowStatusEffects.Hint"),
      scope: "world",
      config: true,
      default: true,
      type: Boolean
    }
  });
}
__name(showStatusEffectNames, "showStatusEffectNames");
function dontShowWelcome() {
  gameSettings.register({
    namespace: SYSTEM_ID,
    key: "dontShowWelcome",
    options: {
      name: localize$1("Setting.DontShowWelcome.Name"),
      hint: localize$1("Setting.DontShowWelcome.Hint"),
      scope: "user",
      config: true,
      default: false,
      type: Boolean
    }
  });
}
__name(dontShowWelcome, "dontShowWelcome");
function applicationWindowHeaderIconsOnly() {
  gameSettings.register({
    namespace: SYSTEM_ID,
    key: "applicationWindowHeaderIconsOnly",
    options: {
      name: localize$1("Setting.applicationWindowHeaderIconsOnly.Name"),
      hint: localize$1("Setting.applicationWindowHeaderIconsOnly.Hint"),
      scope: "user",
      config: true,
      default: false,
      type: Boolean
    }
  });
}
__name(applicationWindowHeaderIconsOnly, "applicationWindowHeaderIconsOnly");
function confirmBeforeDeletingActorItem() {
  gameSettings.register({
    namespace: SYSTEM_ID,
    key: "confirmBeforeDeletingActorItem",
    options: {
      name: localize$1("Setting.confirmBeforeDeletingActorItem.Name"),
      hint: localize$1("Setting.confirmBeforeDeletingActorItem.Hint"),
      scope: "user",
      config: true,
      default: true,
      type: Boolean
    }
  });
}
__name(confirmBeforeDeletingActorItem, "confirmBeforeDeletingActorItem");
function chatMessageSound() {
  gameSettings.register({
    namespace: SYSTEM_ID,
    key: "chatMessageSound",
    options: {
      name: localize$1("Setting.chatMessageSound.Name"),
      hint: localize$1("Setting.chatMessageSound.Hint"),
      scope: "user",
      config: true,
      default: "sounds/notify.wav",
      type: String,
      filePicker: "any"
    }
  });
}
__name(chatMessageSound, "chatMessageSound");
function showChatProfileImages() {
  gameSettings.register({
    namespace: SYSTEM_ID,
    key: "showChatProfileImages",
    options: {
      name: localize$1("Setting.showChatProfileImages.Name"),
      hint: localize$1("Setting.showChatProfileImages.Hint"),
      scope: "user",
      config: true,
      default: true,
      type: Boolean
    }
  });
}
__name(showChatProfileImages, "showChatProfileImages");
function defaultChatDescriptionVisible() {
  gameSettings.register({
    namespace: SYSTEM_ID,
    key: "defaultChatDescriptionVisible",
    options: {
      name: localize$1("Setting.DefaultChatDescriptionVisible.Name"),
      hint: localize$1("Setting.DefaultChatDescriptionVisible.Hint"),
      scope: "world",
      config: true,
      default: false,
      type: Boolean
    }
  });
}
__name(defaultChatDescriptionVisible, "defaultChatDescriptionVisible");
class FFTypeDataModel extends foundry.abstract.TypeDataModel {
  static {
    __name(this, "FFTypeDataModel");
  }
  /**
   * Defines the base schema for all data models
   * @return {object} The schema definition object
   */
  static defineSchema() {
    return {};
  }
}
const {
  HTMLField: HTMLField$2,
  SchemaField: SchemaField$5,
  NumberField: NumberField$6,
  BooleanField: BooleanField$5,
  ArrayField: ArrayField$5,
  StringField: StringField$7
} = foundry.data.fields;
class FFActorDataModel extends FFTypeDataModel {
  static {
    __name(this, "FFActorDataModel");
  }
  /**
   * Defines the base schema for actor data models
   * @return {object} The schema definition object
   */
  static defineSchema() {
    return {
      ...super.defineSchema(),
      isEditing: new BooleanField$5({ initial: false }),
      hasMoved: new BooleanField$5({ initial: false }),
      inventoryLocked: new BooleanField$5({ initial: false }),
      effectActionsLocked: new BooleanField$5({ initial: false }),
      description: new HTMLField$2(),
      DOT: new NumberField$6({ required: true, integer: true, min: 0, initial: 0 }),
      globalCheckMod: new NumberField$6({ required: true, integer: true, min: 0, initial: 0 }),
      points: new SchemaField$5({
        MP: new SchemaField$5({
          val: new NumberField$6({ required: true, integer: true, initial: 0 }),
          max: new NumberField$6({ required: true, integer: true, initial: 0 })
        }),
        HP: new SchemaField$5({
          val: new NumberField$6({ required: true, integer: true, min: 0, initial: 0 }),
          max: new NumberField$6({ required: true, integer: true, min: 0, initial: 0 })
        }),
        BP: new SchemaField$5({
          val: new NumberField$6({ required: true, integer: true, min: 0, initial: 0 })
        })
      }),
      attributes: new SchemaField$5({
        primary: new SchemaField$5({
          str: new SchemaField$5({
            //- @deprecated: I think `label` is in the wrong place? Should maybe just be in the svelte template as it is a constant, not data
            // label: new StringField({ initial: localize('FFXIV.Types.Actor.Types.PC.Attributes.Primary.str.Label') }),
            val: new NumberField$6({ required: true, integer: true, initial: 0 }),
            mod: new NumberField$6({ required: true, integer: true, initial: 0 })
          }),
          dex: new SchemaField$5({
            // label: new StringField({ initial: localize('FFXIV.Types.Actor.Types.PC.Attributes.Primary.dex.Label') }),
            val: new NumberField$6({ required: true, integer: true, initial: 0 }),
            mod: new NumberField$6({ required: true, integer: true, initial: 0 })
          }),
          vit: new SchemaField$5({
            // label: new StringField({ initial: localize('FFXIV.Types.Actor.Types.PC.Attributes.Primary.vit.Label') }),
            val: new NumberField$6({ required: true, integer: true, initial: 0 }),
            mod: new NumberField$6({ required: true, integer: true, initial: 0 })
          }),
          int: new SchemaField$5({
            // label: new StringField({ initial: localize('FFXIV.Types.Actor.Types.PC.Attributes.Primary.ing.Label') }),
            val: new NumberField$6({ required: true, integer: true, initial: 0 }),
            mod: new NumberField$6({ required: true, integer: true, initial: 0 })
          }),
          mnd: new SchemaField$5({
            // label: new StringField({ initial: localize('FFXIV.Types.Actor.Types.PC.Attributes.Primary.mnd.Label') }),
            val: new NumberField$6({ required: true, integer: true, initial: 0 }),
            mod: new NumberField$6({ required: true, integer: true, initial: 0 })
          })
        }),
        secondary: new SchemaField$5({
          def: new SchemaField$5({
            // label: new StringField({ initial: localize('FFXIV.Types.Actor.Types.PC.Attributes.Primary.def.Label') }),
            val: new NumberField$6({ required: true, integer: true, min: 0, initial: 0 }),
            mod: new NumberField$6({ required: true, integer: true, min: 0, initial: 0 })
          }),
          mag: new SchemaField$5({
            // label: new StringField({ initial: localize('FFXIV.Types.Actor.Types.PC.Attributes.Primary.mag.Label') }),
            val: new NumberField$6({ required: true, integer: true, min: 0, initial: 0 }),
            mod: new NumberField$6({ required: true, integer: true, min: 0, initial: 0 })
          }),
          vig: new SchemaField$5({
            // label: new StringField({ initial: localize('FFXIV.Types.Actor.Types.PC.Attributes.Primary.vig.Label') }),
            val: new NumberField$6({ required: true, integer: true, min: 0, initial: 0 }),
            mod: new NumberField$6({ required: true, integer: true, min: 0, initial: 0 })
          }),
          spd: new SchemaField$5({
            // label: new StringField({ initial: localize('FFXIV.Types.Actor.Types.PC.Attributes.Primary.spd.Label') }),
            val: new NumberField$6({ required: true, integer: true, min: 0, initial: 0 }),
            mod: new NumberField$6({ required: true, integer: true, min: 0, initial: 0 })
          })
        })
      })
    };
  }
  /** 
   * Check if the actor has any favourited items
   * @return {boolean} True if the actor has any favourited items
   */
  hasFavouriteItems() {
    return this.parent.items.some((item) => item.system.favourite === true);
  }
}
const {
  StringField: StringField$6
} = foundry.data.fields;
class NPCModel extends FFActorDataModel {
  static {
    __name(this, "NPCModel");
  }
  /**
   * Defines the schema for NPC data
   * @return {object} The schema definition object
   */
  static defineSchema() {
    return {
      ...super.defineSchema(),
      size: new StringField$6({ initial: "" })
    };
  }
}
const {
  HTMLField: HTMLField$1,
  SchemaField: SchemaField$4,
  NumberField: NumberField$5,
  StringField: StringField$5,
  ArrayField: ArrayField$4,
  BooleanField: BooleanField$4
} = foundry.data.fields;
class PCModel extends FFActorDataModel {
  static {
    __name(this, "PCModel");
  }
  /**
   * Defines the schema for PC data
   * @return {object} The schema definition object
   */
  static defineSchema() {
    return {
      ...super.defineSchema(),
      biography: new HTMLField$1(),
      job: new SchemaField$4({
        uuid: new StringField$5({ required: true, initial: "" }),
        grants: new ArrayField$4(
          new StringField$5({ required: true, initial: "" })
        ),
        level: new NumberField$5({ required: true, integer: true, min: 30, initial: null }),
        role: new StringField$5({ required: true, initial: "" }),
        name: new StringField$5({ required: true, initial: "" }),
        img: new StringField$5({ required: true, initial: "" })
      }),
      actionState: new SchemaField$4({
        available: new ArrayField$4(new StringField$5(), {
          initial: ["primary", "secondary"]
        }),
        used: new ArrayField$4(new SchemaField$4({
          type: new StringField$5({ required: true }),
          messageId: new StringField$5({ required: true })
        }), {
          initial: []
        }),
        usedReaction: new BooleanField$4({ required: true, initial: false })
      })
    };
  }
}
const { HTMLField, BooleanField: BooleanField$3, StringField: StringField$4, NumberField: NumberField$4, ArrayField: ArrayField$3, SchemaField: SchemaField$3 } = foundry.data.fields;
class FFItemDataModel extends FFTypeDataModel {
  static {
    __name(this, "FFItemDataModel");
  }
  /**
   * Defines the base schema for item data models
   * @return {object} The schema definition object
   */
  static defineSchema() {
    return {
      ...super.defineSchema(),
      // Include the schema from the base class
      description: new HTMLField(),
      favourite: new BooleanField$3({ initial: false }),
      effectActionsLocked: new BooleanField$3({ initial: false }),
      durations: new ArrayField$3(new SchemaField$3({
        type: new StringField$4({ required: false }),
        amount: new NumberField$4({ required: false, integer: true }),
        units: new StringField$4({ required: false }),
        qualifier: new StringField$4({ required: false })
      }), { initial: [] })
    };
  }
}
const {
  SchemaField: SchemaField$2,
  NumberField: NumberField$3,
  StringField: StringField$3,
  BooleanField: BooleanField$2,
  ObjectField: ObjectField$1,
  ArrayField: ArrayField$2
} = foundry.data.fields;
class ActionModel extends FFItemDataModel {
  static {
    __name(this, "ActionModel");
  }
  /**
   * Defines the schema for Action items
   * @return {object} The schema definition object
   */
  static defineSchema() {
    return {
      ...super.defineSchema(),
      // Merge with the base model schema
      hasAspected: new BooleanField$2({ required: false, initial: false }),
      aspected: new StringField$3({ required: false, initial: "" }),
      hasRanged: new BooleanField$2({ required: false, initial: false }),
      rangeType: new StringField$3({ required: false, initial: "" }),
      hasTrigger: new BooleanField$2({ required: false, initial: false }),
      trigger: new StringField$3({ required: false, initial: "" }),
      hasTarget: new BooleanField$2({ required: false, initial: false }),
      target: new StringField$3({ required: false, initial: "" }),
      baseEffectHealing: new StringField$3({ required: false, initial: "" }),
      baseEffectHealingType: new StringField$3({ required: false, initial: "" }),
      baseEffectDamage: new StringField$3({ required: false, initial: "" }),
      hasBaseEffect: new BooleanField$2({ required: false, initial: false }),
      hasBaseEffectHealing: new BooleanField$2({ required: false, initial: false }),
      hasBaseEffectDamage: new BooleanField$2({ required: false, initial: false }),
      hasBaseEffectRestoreMP: new BooleanField$2({ required: false, initial: false }),
      baseEffectRestoreMP: new StringField$3({ required: false, initial: "" }),
      hasBaseEffectBarrier: new BooleanField$2({ required: false, initial: false }),
      baseEffectBP: new NumberField$3({ required: false, initial: 0 }),
      hasCheck: new BooleanField$2({ required: false, initial: false }),
      checkAttribute: new StringField$3({ required: false, initial: "" }),
      checkBonus: new NumberField$3({ required: false, initial: 0 }),
      hasCR: new BooleanField$2({ required: false, initial: false }),
      CR: new StringField$3({ required: false, initial: "" }),
      hasDirectHit: new BooleanField$2({ required: false, initial: false }),
      directHitType: new StringField$3({ required: false, initial: "" }),
      directHitDamage: new StringField$3({ required: false, initial: "" }),
      directHitText: new StringField$3({ required: false, initial: "" }),
      directHitCondition: new StringField$3({ required: false, initial: "" }),
      hasLimitation: new BooleanField$2({ required: false, initial: false }),
      limitation: new NumberField$3({ required: false, initial: 0, integer: true, min: 0, max: 3 }),
      limitationUnits: new StringField$3({ required: false, initial: "phase" }),
      uses: new NumberField$3({ required: false, initial: 0, integer: true, min: 0 }),
      type: new StringField$3({
        required: false,
        choices: ["primary", "secondary", "reaction", "limit", "combo"]
      }),
      hasSplitDamage: new BooleanField$2({ required: false, initial: false }),
      hasCostMP: new BooleanField$2({ required: false, initial: false }),
      costMP: new NumberField$3({ required: false, initial: 0 }),
      procTrigger: new NumberField$3({ required: false, initial: null }),
      procs: new SchemaField$2({
        list: new ArrayField$2(
          new ObjectField$1({
            fields: {
              uuid: new StringField$3({ required: true, initial: "" })
            }
          })
        ),
        value: new BooleanField$2({ required: true, initial: false })
      }),
      grants: new SchemaField$2({
        list: new ArrayField$2(
          new ObjectField$1({
            fields: {
              uuid: new StringField$3({ required: true, initial: "" })
            }
          })
        ),
        value: new BooleanField$2({ required: true, initial: false })
      }),
      sourceGrants: new SchemaField$2({
        list: new ArrayField$2(
          new ObjectField$1({
            fields: {
              uuid: new StringField$3({ required: true, initial: "" })
            }
          })
        ),
        value: new BooleanField$2({ required: true, initial: false })
      }),
      requires: new SchemaField$2({
        list: new ArrayField$2(
          new ObjectField$1({
            fields: {
              uuid: new StringField$3({ required: true, initial: "" })
            }
          })
        ),
        value: new BooleanField$2({ required: true, initial: false })
      }),
      sharedLimitation: new SchemaField$2({
        list: new ArrayField$2(
          new ObjectField$1({
            fields: {
              uuid: new StringField$3({ required: true, initial: "" })
            }
          })
        ),
        value: new BooleanField$2({ required: true, initial: false })
      }),
      removes: new SchemaField$2({
        list: new ArrayField$2(
          new ObjectField$1({
            fields: {
              uuid: new StringField$3({ required: true, initial: "" })
            }
          })
        ),
        value: new BooleanField$2({ required: true, initial: false })
      }),
      enables: new SchemaField$2({
        list: new ArrayField$2(
          new ObjectField$1({
            fields: {
              uuid: new StringField$3({ required: true, initial: "" })
            }
          })
        ),
        value: new BooleanField$2({ required: true, initial: false })
      }),
      hasTags: new BooleanField$2({ required: false, initial: false }),
      tags: new ArrayField$2(
        new StringField$3({ required: false, initial: "" })
      ),
      isMagic: new BooleanField$2({ required: false, initial: false })
    };
  }
}
const { NumberField: NumberField$2, StringField: StringField$2 } = foundry.data.fields;
class EquipmentModel extends FFItemDataModel {
  static {
    __name(this, "EquipmentModel");
  }
  /**
   * Defines the schema for Equipment items
   * @return {object} The schema definition object
   */
  static defineSchema() {
    return {
      ...super.defineSchema(),
      // Merge with the base model schema
      quantity: new NumberField$2({ required: false, integer: true, min: 0, initial: 1 }),
      actionType: new StringField$2({
        required: true,
        choices: ["primary", "secondary"],
        initial: "secondary"
      })
    };
  }
}
const {
  SchemaField: SchemaField$1,
  NumberField: NumberField$1,
  StringField: StringField$1,
  BooleanField: BooleanField$1,
  ObjectField,
  ArrayField: ArrayField$1
} = foundry.data.fields;
class JobModel extends FFItemDataModel {
  static {
    __name(this, "JobModel");
  }
  /**
   * Defines the schema for Job items
   * @return {object} The schema definition object
   */
  static defineSchema() {
    return {
      ...super.defineSchema(),
      // Merge with the base model schema
      level: new NumberField$1({ required: true, initial: 0 }),
      role: new StringField$1({ required: true, initial: "" }),
      grants: new SchemaField$1({
        list: new ArrayField$1(
          new ObjectField({
            // Use ObjectField to allow storing objects
            fields: {
              uuid: new StringField$1({ required: true, initial: "" })
            }
          })
        ),
        value: new BooleanField$1({ required: true, initial: false })
      })
    };
  }
}
const {
  SchemaField,
  NumberField,
  StringField,
  BooleanField,
  ArrayField
} = foundry.data.fields;
class TraitModel extends FFItemDataModel {
  static {
    __name(this, "TraitModel");
  }
  /**
   * Defines the schema for Trait items
   * @return {object} The schema definition object
   */
  static defineSchema() {
    return {
      ...super.defineSchema(),
      // Merge with the base model schema
      type: new StringField({ required: false, initial: "" }),
      hasLimitation: new BooleanField({ required: false, initial: false }),
      limitation: new NumberField({ required: false, initial: 0, integer: true, min: 0, max: 3 }),
      limitationUnits: new StringField({ required: false, initial: "phase" }),
      uses: new NumberField({ required: false, initial: 0, integer: true, min: 0 }),
      hasModifier: new BooleanField({ required: false, initial: false }),
      modType: new StringField({ required: false, initial: "" }),
      operator: new StringField({ required: false, initial: "+" }),
      modAmount: new NumberField({ required: false, initial: 0 }),
      hasDamageDiceReroll: new BooleanField({ required: false, initial: false }),
      damageDiceReroll: new NumberField({ required: false, initial: 0, integer: true, min: 0, max: 3 }),
      hasTags: new BooleanField({ required: false, initial: false }),
      tags: new ArrayField(
        new StringField({ required: false, initial: "" })
      ),
      sacrificesMovement: new BooleanField({ required: false, initial: false })
    };
  }
}
function setupModels() {
  CONFIG.Item.dataModels["job"] = JobModel;
  CONFIG.Item.dataModels["action"] = ActionModel;
  CONFIG.Item.dataModels["trait"] = TraitModel;
  CONFIG.Item.dataModels["equipment"] = EquipmentModel;
  CONFIG.Actor.dataModels["PC"] = PCModel;
  CONFIG.Actor.dataModels["NPC"] = NPCModel;
}
__name(setupModels, "setupModels");
function get_each_context$g(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list[i];
  return child_ctx;
}
__name(get_each_context$g, "get_each_context$g");
function create_if_block$l(ctx) {
  let each_1_anchor;
  let each_value = ensure_array_like(
    /*options*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$g(get_each_context$g(ctx, each_value, i));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*options*/
      1) {
        each_value = ensure_array_like(
          /*options*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$g(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$g(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
__name(create_if_block$l, "create_if_block$l");
function create_each_block$g(ctx) {
  let option_1;
  let t0_value = (
    /*option*/
    ctx[20].label + ""
  );
  let t0;
  let t1;
  let option_1_value_value;
  return {
    c() {
      option_1 = element("option");
      t0 = text(t0_value);
      t1 = space();
      option_1.__value = option_1_value_value = /*option*/
      ctx[20].value;
      set_input_value(option_1, option_1.__value);
    },
    m(target, anchor) {
      insert(target, option_1, anchor);
      append(option_1, t0);
      append(option_1, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*options*/
      1 && t0_value !== (t0_value = /*option*/
      ctx2[20].label + ""))
        set_data(t0, t0_value);
      if (dirty & /*options*/
      1 && option_1_value_value !== (option_1_value_value = /*option*/
      ctx2[20].value)) {
        option_1.__value = option_1_value_value;
        set_input_value(option_1, option_1.__value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(option_1);
      }
    }
  };
}
__name(create_each_block$g, "create_each_block$g");
function create_fragment$12(ctx) {
  let select;
  let option_1;
  let t;
  let option_1_selected_value;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*options*/
    ctx[0] && /*options*/
    ctx[0].length && create_if_block$l(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    null
  );
  let select_levels = [
    /*$$restProps*/
    ctx[5],
    { disabled: (
      /*disabled*/
      ctx[1]
    ) }
  ];
  let select_data = {};
  for (let i = 0; i < select_levels.length; i += 1) {
    select_data = assign(select_data, select_levels[i]);
  }
  return {
    c() {
      select = element("select");
      option_1 = element("option");
      t = text("Please select an option");
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      if (default_slot)
        default_slot.c();
      option_1.__value = "";
      set_input_value(option_1, option_1.__value);
      option_1.disabled = true;
      option_1.selected = option_1_selected_value = !/*inputValue*/
      ctx[2];
      set_attributes(select, select_data);
      if (
        /*inputValue*/
        ctx[2] === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[14].call(select)
        ));
      toggle_class(select, "svelte-76qduf", true);
    },
    m(target, anchor) {
      insert(target, select, anchor);
      append(select, option_1);
      append(option_1, t);
      if (if_block)
        if_block.m(select, null);
      append(select, if_block_anchor);
      if (default_slot) {
        default_slot.m(select, null);
      }
      "value" in select_data && (select_data.multiple ? select_options : select_option)(select, select_data.value);
      if (select.autofocus)
        select.focus();
      select_option(
        select,
        /*inputValue*/
        ctx[2],
        true
      );
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[14]
          ),
          listen(
            select,
            "change",
            /*update*/
            ctx[4]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*inputValue, options*/
      5 && option_1_selected_value !== (option_1_selected_value = !/*inputValue*/
      ctx2[2])) {
        option_1.selected = option_1_selected_value;
      }
      if (
        /*options*/
        ctx2[0] && /*options*/
        ctx2[0].length
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$l(ctx2);
          if_block.c();
          if_block.m(select, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(select, select_data = get_spread_update(select_levels, [
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        (!current || dirty & /*disabled*/
        2) && { disabled: (
          /*disabled*/
          ctx2[1]
        ) }
      ]));
      if (dirty & /*$$restProps, disabled*/
      34 && "value" in select_data)
        (select_data.multiple ? select_options : select_option)(select, select_data.value);
      if (dirty & /*inputValue, options*/
      5) {
        select_option(
          select,
          /*inputValue*/
          ctx2[2]
        );
      }
      toggle_class(select, "svelte-76qduf", true);
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(select);
      }
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_fragment$12, "create_fragment$12");
function instance$X($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "options",
    "valuePath",
    "document",
    "preventDefault",
    "disabled",
    "label",
    "callback",
    "handleOwnUpdates"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $doc;
  let { $$slots: slots = {}, $$scope } = $$props;
  const dispatch2 = createEventDispatcher();
  let { options = void 0 } = $$props;
  let { valuePath = "" } = $$props;
  let { document: document2 = false } = $$props;
  let { preventDefault = false } = $$props;
  let { disabled = false } = $$props;
  let { label = "" } = $$props;
  let { callback = void 0 } = $$props;
  let { handleOwnUpdates = true } = $$props;
  let inputValue = null;
  const doc = document2 || getContext("#doc");
  component_subscribe($$self, doc, (value) => $$invalidate(15, $doc = value));
  const update2 = /* @__PURE__ */ __name(async () => {
    if (preventDefault)
      return;
    if (handleOwnUpdates) {
      const updateObj = {};
      foundry.utils.setProperty(updateObj, valuePath, inputValue);
      game.system.log.b("DocSelect:updateObj", updateObj);
      await $doc.update(updateObj);
      game.system.log.b($doc);
      if (callback)
        await callback(inputValue);
    } else {
      dispatch2("change", { value: inputValue, path: valuePath });
    }
  }, "update");
  onMount(() => {
    $$invalidate(2, inputValue = resolveDotpath($doc, valuePath));
  });
  function select_change_handler() {
    inputValue = select_value(this);
    $$invalidate(2, inputValue);
    $$invalidate(0, options);
  }
  __name(select_change_handler, "select_change_handler");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("options" in $$new_props)
      $$invalidate(0, options = $$new_props.options);
    if ("valuePath" in $$new_props)
      $$invalidate(6, valuePath = $$new_props.valuePath);
    if ("document" in $$new_props)
      $$invalidate(7, document2 = $$new_props.document);
    if ("preventDefault" in $$new_props)
      $$invalidate(8, preventDefault = $$new_props.preventDefault);
    if ("disabled" in $$new_props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("label" in $$new_props)
      $$invalidate(9, label = $$new_props.label);
    if ("callback" in $$new_props)
      $$invalidate(10, callback = $$new_props.callback);
    if ("handleOwnUpdates" in $$new_props)
      $$invalidate(11, handleOwnUpdates = $$new_props.handleOwnUpdates);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  return [
    options,
    disabled,
    inputValue,
    doc,
    update2,
    $$restProps,
    valuePath,
    document2,
    preventDefault,
    label,
    callback,
    handleOwnUpdates,
    $$scope,
    slots,
    select_change_handler
  ];
}
__name(instance$X, "instance$X");
class DocSelect extends SvelteComponent {
  static {
    __name(this, "DocSelect");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$X, create_fragment$12, safe_not_equal, {
      options: 0,
      valuePath: 6,
      document: 7,
      preventDefault: 8,
      disabled: 1,
      label: 9,
      callback: 10,
      handleOwnUpdates: 11
    });
  }
  get options() {
    return this.$$.ctx[0];
  }
  set options(options) {
    this.$$set({ options });
    flush();
  }
  get valuePath() {
    return this.$$.ctx[6];
  }
  set valuePath(valuePath) {
    this.$$set({ valuePath });
    flush();
  }
  get document() {
    return this.$$.ctx[7];
  }
  set document(document2) {
    this.$$set({ document: document2 });
    flush();
  }
  get preventDefault() {
    return this.$$.ctx[8];
  }
  set preventDefault(preventDefault) {
    this.$$set({ preventDefault });
    flush();
  }
  get disabled() {
    return this.$$.ctx[1];
  }
  set disabled(disabled) {
    this.$$set({ disabled });
    flush();
  }
  get label() {
    return this.$$.ctx[9];
  }
  set label(label) {
    this.$$set({ label });
    flush();
  }
  get callback() {
    return this.$$.ctx[10];
  }
  set callback(callback) {
    this.$$set({ callback });
    flush();
  }
  get handleOwnUpdates() {
    return this.$$.ctx[11];
  }
  set handleOwnUpdates(handleOwnUpdates) {
    this.$$set({ handleOwnUpdates });
    flush();
  }
}
function create_if_block_3$7(ctx) {
  let div1;
  let div0;
  let input;
  let input_type_value;
  let div1_class_value;
  let mounted;
  let dispose;
  let if_block = (
    /*LABEL*/
    ctx[13] && create_if_block_4$4(ctx)
  );
  let input_levels = [
    /*$$restProps*/
    ctx[20],
    {
      type: input_type_value = /*$$props*/
      ctx[19].type
    },
    { value: (
      /*inputValue*/
      ctx[9]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[1]
    ) },
    { maxlength: (
      /*maxlength*/
      ctx[2]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  return {
    c() {
      div1 = element("div");
      if (if_block)
        if_block.c();
      div0 = element("div");
      input = element("input");
      set_attributes(input, input_data);
      toggle_class(input, "svelte-12ghg75", true);
      attr(div0, "class", "flex5 wide svelte-12ghg75");
      attr(div1, "class", div1_class_value = "flexrow gap-15 " + /*fullWidth*/
      (ctx[8] ? "wide" : "") + " svelte-12ghg75");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      if (if_block)
        if_block.m(div1, null);
      append(div1, div0);
      append(div0, input);
      if ("value" in input_data) {
        input.value = input_data.value;
      }
      if (input.autofocus)
        input.focus();
      ctx[32](input);
      if (!mounted) {
        dispose = [
          listen(input, "keydown", stop_propagation(
            /*handleKeyDown*/
            ctx[16]
          )),
          listen(input, "input", stop_propagation(function() {
            if (is_function(
              /*updateOnInput*/
              ctx[5] ? (
                /*updateDebounce*/
                ctx[15]
              ) : input_handler
            ))
              /*updateOnInput*/
              (ctx[5] ? (
                /*updateDebounce*/
                ctx[15]
              ) : input_handler).apply(this, arguments);
          })),
          listen(input, "blur", stop_propagation(
            /*handleBlur*/
            ctx[17]
          ))
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*LABEL*/
        ctx[13]
      )
        if_block.p(ctx, dirty);
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & /*$$restProps*/
        1048576 && /*$$restProps*/
        ctx[20],
        dirty[0] & /*$$props*/
        524288 && input_type_value !== (input_type_value = /*$$props*/
        ctx[19].type) && { type: input_type_value },
        dirty[0] & /*inputValue*/
        512 && input.value !== /*inputValue*/
        ctx[9] && { value: (
          /*inputValue*/
          ctx[9]
        ) },
        dirty[0] & /*placeholder*/
        2 && { placeholder: (
          /*placeholder*/
          ctx[1]
        ) },
        dirty[0] & /*maxlength*/
        4 && { maxlength: (
          /*maxlength*/
          ctx[2]
        ) }
      ]));
      if ("value" in input_data) {
        input.value = input_data.value;
      }
      toggle_class(input, "svelte-12ghg75", true);
      if (dirty[0] & /*fullWidth*/
      256 && div1_class_value !== (div1_class_value = "flexrow gap-15 " + /*fullWidth*/
      (ctx[8] ? "wide" : "") + " svelte-12ghg75")) {
        attr(div1, "class", div1_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (if_block)
        if_block.d();
      ctx[32](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_if_block_3$7, "create_if_block_3$7");
function create_if_block_4$4(ctx) {
  let div;
  let label_1;
  let t0;
  let t1;
  let label_1_for_value;
  return {
    c() {
      div = element("div");
      label_1 = element("label");
      t0 = text(
        /*label*/
        ctx[3]
      );
      t1 = space();
      attr(label_1, "class", "bold gold");
      attr(label_1, "for", label_1_for_value = /*inputElement*/
      ctx[10]?.id);
      attr(div, "class", "flex1 wide svelte-12ghg75");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label_1);
      append(label_1, t0);
      append(label_1, t1);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*label*/
      8)
        set_data(
          t0,
          /*label*/
          ctx2[3]
        );
      if (dirty[0] & /*inputElement*/
      1024 && label_1_for_value !== (label_1_for_value = /*inputElement*/
      ctx2[10]?.id)) {
        attr(label_1, "for", label_1_for_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
__name(create_if_block_4$4, "create_if_block_4$4");
function create_if_block$k(ctx) {
  let button;
  let div;
  let if_block0_anchor;
  let button_class_value;
  let mounted;
  let dispose;
  let if_block0 = (
    /*LABEL*/
    ctx[13] && create_if_block_2$a(ctx)
  );
  function select_block_type(ctx2, dirty) {
    if (
      /*editable*/
      ctx2[0]
    )
      return create_if_block_1$e;
    return create_else_block$3;
  }
  __name(select_block_type, "select_block_type");
  let current_block_type = select_block_type(ctx);
  let if_block1 = current_block_type(ctx);
  return {
    c() {
      button = element("button");
      div = element("div");
      if (if_block0)
        if_block0.c();
      if_block0_anchor = empty();
      if_block1.c();
      attr(div, "class", "flexrow gap-15 wide doc-input svelte-12ghg75");
      attr(button, "class", button_class_value = "stealth " + /*$$props*/
      (ctx[19]?.class?.includes("widebutton") ? "wide" : " " + /*$$props*/
      ctx[19]?.class?.includes("left") ? "left" : " ") + " svelte-12ghg75");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, div);
      if (if_block0)
        if_block0.m(div, null);
      append(div, if_block0_anchor);
      if_block1.m(div, null);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(
            /*clickType*/
            ctx[4] == "click" ? (
              /*enableInput*/
              ctx[18]
            ) : click_handler
          ))
            /*clickType*/
            (ctx[4] == "click" ? (
              /*enableInput*/
              ctx[18]
            ) : click_handler).apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*LABEL*/
        ctx[13]
      )
        if_block0.p(ctx, dirty);
      if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block1) {
        if_block1.p(ctx, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type(ctx);
        if (if_block1) {
          if_block1.c();
          if_block1.m(div, null);
        }
      }
      if (dirty[0] & /*$$props*/
      524288 && button_class_value !== (button_class_value = "stealth " + /*$$props*/
      (ctx[19]?.class?.includes("widebutton") ? "wide" : " " + /*$$props*/
      ctx[19]?.class?.includes("left") ? "left" : " ") + " svelte-12ghg75")) {
        attr(button, "class", button_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (if_block0)
        if_block0.d();
      if_block1.d();
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block$k, "create_if_block$k");
function create_if_block_2$a(ctx) {
  let div;
  let label_1;
  let t0;
  let t1;
  let label_1_for_value;
  return {
    c() {
      div = element("div");
      label_1 = element("label");
      t0 = text(
        /*label*/
        ctx[3]
      );
      t1 = space();
      attr(label_1, "class", "bold gold");
      attr(label_1, "for", label_1_for_value = /*inputElement*/
      ctx[10]?.id);
      attr(div, "class", "flex1 wide svelte-12ghg75");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label_1);
      append(label_1, t0);
      append(label_1, t1);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*label*/
      8)
        set_data(
          t0,
          /*label*/
          ctx2[3]
        );
      if (dirty[0] & /*inputElement*/
      1024 && label_1_for_value !== (label_1_for_value = /*inputElement*/
      ctx2[10]?.id)) {
        attr(label_1, "for", label_1_for_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
__name(create_if_block_2$a, "create_if_block_2$a");
function create_else_block$3(ctx) {
  let div;
  let t_value = (
    /*inputValue*/
    (ctx[9] ? (
      /*inputValue*/
      ctx[9]
    ) : (
      /*placeholder*/
      ctx[1]
    )) + ""
  );
  let t;
  let div_class_value;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", div_class_value = "output " + /*pulseClass*/
      ctx[11] + " " + /*textClasses*/
      ctx[6] + " svelte-12ghg75");
      toggle_class(
        div,
        "empty",
        /*isEmpty*/
        ctx[12]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*inputValue, placeholder*/
      514 && t_value !== (t_value = /*inputValue*/
      (ctx2[9] ? (
        /*inputValue*/
        ctx2[9]
      ) : (
        /*placeholder*/
        ctx2[1]
      )) + ""))
        set_data(t, t_value);
      if (dirty[0] & /*pulseClass, textClasses*/
      2112 && div_class_value !== (div_class_value = "output " + /*pulseClass*/
      ctx2[11] + " " + /*textClasses*/
      ctx2[6] + " svelte-12ghg75")) {
        attr(div, "class", div_class_value);
      }
      if (dirty[0] & /*pulseClass, textClasses, isEmpty*/
      6208) {
        toggle_class(
          div,
          "empty",
          /*isEmpty*/
          ctx2[12]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
__name(create_else_block$3, "create_else_block$3");
function create_if_block_1$e(ctx) {
  let div;
  let input;
  let input_type_value;
  let mounted;
  let dispose;
  let input_levels = [
    /*$$restProps*/
    ctx[20],
    {
      type: input_type_value = /*$$props*/
      ctx[19].type
    },
    { value: (
      /*inputValue*/
      ctx[9]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[1]
    ) },
    { maxlength: (
      /*maxlength*/
      ctx[2]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  return {
    c() {
      div = element("div");
      input = element("input");
      set_attributes(input, input_data);
      toggle_class(input, "svelte-12ghg75", true);
      attr(div, "class", "flex5 wide svelte-12ghg75");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      if ("value" in input_data) {
        input.value = input_data.value;
      }
      if (input.autofocus)
        input.focus();
      ctx[33](input);
      if (!mounted) {
        dispose = [
          listen(input, "keydown", stop_propagation(
            /*handleKeyDown*/
            ctx[16]
          )),
          listen(input, "input", stop_propagation(function() {
            if (is_function(
              /*updateOnInput*/
              ctx[5] ? (
                /*updateDebounce*/
                ctx[15]
              ) : input_handler_1
            ))
              /*updateOnInput*/
              (ctx[5] ? (
                /*updateDebounce*/
                ctx[15]
              ) : input_handler_1).apply(this, arguments);
          })),
          listen(input, "blur", stop_propagation(
            /*handleBlur*/
            ctx[17]
          ))
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & /*$$restProps*/
        1048576 && /*$$restProps*/
        ctx[20],
        dirty[0] & /*$$props*/
        524288 && input_type_value !== (input_type_value = /*$$props*/
        ctx[19].type) && { type: input_type_value },
        dirty[0] & /*inputValue*/
        512 && input.value !== /*inputValue*/
        ctx[9] && { value: (
          /*inputValue*/
          ctx[9]
        ) },
        dirty[0] & /*placeholder*/
        2 && { placeholder: (
          /*placeholder*/
          ctx[1]
        ) },
        dirty[0] & /*maxlength*/
        4 && { maxlength: (
          /*maxlength*/
          ctx[2]
        ) }
      ]));
      if ("value" in input_data) {
        input.value = input_data.value;
      }
      toggle_class(input, "svelte-12ghg75", true);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      ctx[33](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_if_block_1$e, "create_if_block_1$e");
function create_fragment$11(ctx) {
  let if_block0_anchor;
  let if_block1_anchor;
  let if_block0 = (
    /*alwaysEditable*/
    ctx[7] && create_if_block_3$7(ctx)
  );
  let if_block1 = !/*alwaysEditable*/
  ctx[7] && create_if_block$k(ctx);
  return {
    c() {
      if (if_block0)
        if_block0.c();
      if_block0_anchor = empty();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, if_block0_anchor, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*alwaysEditable*/
        ctx2[7]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_3$7(ctx2);
          if_block0.c();
          if_block0.m(if_block0_anchor.parentNode, if_block0_anchor);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!/*alwaysEditable*/
      ctx2[7]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$k(ctx2);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(if_block0_anchor);
        detach(if_block1_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
    }
  };
}
__name(create_fragment$11, "create_fragment$11");
const input_handler = /* @__PURE__ */ __name(() => {
}, "input_handler");
const input_handler_1 = /* @__PURE__ */ __name(() => {
}, "input_handler_1");
const click_handler = /* @__PURE__ */ __name(() => {
}, "click_handler");
function instance$W($$self, $$props, $$invalidate) {
  let isEmpty;
  const omit_props_names = [
    "placeholder",
    "maxlength",
    "valuePath",
    "label",
    "document",
    "editable",
    "type",
    "clickType",
    "pulse",
    "updateOnInput",
    "enabled",
    "textClasses",
    "alwaysEditable",
    "fullWidth",
    "updateOnBlur",
    "handleOwnUpdates"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $doc;
  const dispatch2 = createEventDispatcher();
  let { placeholder = "--" } = $$props;
  let { maxlength = "40" } = $$props;
  let { valuePath = "" } = $$props;
  let { label = "" } = $$props;
  let { document: document2 = false } = $$props;
  let { editable = false } = $$props;
  let { type = "standard" } = $$props;
  let { clickType = "click" } = $$props;
  let { pulse = false } = $$props;
  let { updateOnInput = false } = $$props;
  let { enabled = false } = $$props;
  let { textClasses = "" } = $$props;
  let { alwaysEditable = false } = $$props;
  let { fullWidth = false } = $$props;
  let { updateOnBlur = false } = $$props;
  let { handleOwnUpdates = true } = $$props;
  let inputValue, LABEL = !!label, inputElement, pulseClass = "", initialRender = true, internalUpdate = false, externalValue;
  const doc = document2 || getContext("#doc");
  component_subscribe($$self, doc, (value) => $$invalidate(31, $doc = value));
  const updateDebounce = Timing.debounce(update2, 500);
  function handleKeyDown(event, index) {
    game.system.log.d("DocInput keydown: " + event.key);
    if (!updateOnBlur && event.key === "Enter") {
      event.preventDefault();
      inputElement.blur();
      $$invalidate(0, editable = false);
      update2(event);
    }
  }
  __name(handleKeyDown, "handleKeyDown");
  function handleBlur(event, index) {
    game.system.log.d("DocInput blurring");
    if (!alwaysEditable) {
      $$invalidate(0, editable = false);
      $$invalidate(21, enabled = false);
    }
    if (updateOnBlur) {
      if (handleOwnUpdates) {
        update2(event);
      } else {
        dispatch2("change", {
          value: event.target.value,
          path: valuePath
        });
      }
    }
  }
  __name(handleBlur, "handleBlur");
  async function enableInput(event) {
    if (enabled || alwaysEditable)
      return;
    $$invalidate(21, enabled = true);
    console.log("enableInput", event);
    if (event.key === "Space") {
      console.log("space");
      event.preventDefault();
      return;
    }
    $$invalidate(0, editable = true);
    await tick();
    inputElement.focus();
    inputElement.select();
  }
  __name(enableInput, "enableInput");
  async function update2(event) {
    $$invalidate(29, internalUpdate = true);
    let val = event.target.value;
    if (type == "number" && $$props.max !== void 0 && val > $$props.max) {
      val = $$props.max;
      ui.notifications.warn(`Value cannot exceed ${$$props.max}`);
    }
    if (type == "number" && $$props.min !== void 0 && val < $$props.min) {
      val = $$props.min;
      ui.notifications.warn(`Value cannot exceed ${$$props.min}`);
    }
    $$invalidate(9, inputValue = type == "number" ? Number(val) : val);
    if (handleOwnUpdates) {
      await $doc.update({ [valuePath]: val });
      if (pulse) {
        $$invalidate(11, pulseClass = "pulse");
        setTimeout(() => $$invalidate(11, pulseClass = ""), 1e3);
      }
      $$invalidate(21, enabled = false);
    } else {
      dispatch2("change", { value: val, path: valuePath });
    }
    $$invalidate(29, internalUpdate = false);
  }
  __name(update2, "update");
  onMount(async () => {
    const resolved = resolveDotpath($doc, valuePath);
    $$invalidate(9, inputValue = resolved ?? "");
    $$invalidate(28, initialRender = false);
    if ($$props.type == "number") {
      $$invalidate(9, inputValue = Number(inputValue));
      if (placeholder == "--") {
        $$invalidate(1, placeholder = 0);
      }
    }
  });
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement = $$value;
      $$invalidate(10, inputElement);
    });
  }
  __name(input_binding, "input_binding");
  function input_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement = $$value;
      $$invalidate(10, inputElement);
    });
  }
  __name(input_binding_1, "input_binding_1");
  $$self.$$set = ($$new_props) => {
    $$invalidate(19, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(20, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("placeholder" in $$new_props)
      $$invalidate(1, placeholder = $$new_props.placeholder);
    if ("maxlength" in $$new_props)
      $$invalidate(2, maxlength = $$new_props.maxlength);
    if ("valuePath" in $$new_props)
      $$invalidate(22, valuePath = $$new_props.valuePath);
    if ("label" in $$new_props)
      $$invalidate(3, label = $$new_props.label);
    if ("document" in $$new_props)
      $$invalidate(23, document2 = $$new_props.document);
    if ("editable" in $$new_props)
      $$invalidate(0, editable = $$new_props.editable);
    if ("type" in $$new_props)
      $$invalidate(24, type = $$new_props.type);
    if ("clickType" in $$new_props)
      $$invalidate(4, clickType = $$new_props.clickType);
    if ("pulse" in $$new_props)
      $$invalidate(25, pulse = $$new_props.pulse);
    if ("updateOnInput" in $$new_props)
      $$invalidate(5, updateOnInput = $$new_props.updateOnInput);
    if ("enabled" in $$new_props)
      $$invalidate(21, enabled = $$new_props.enabled);
    if ("textClasses" in $$new_props)
      $$invalidate(6, textClasses = $$new_props.textClasses);
    if ("alwaysEditable" in $$new_props)
      $$invalidate(7, alwaysEditable = $$new_props.alwaysEditable);
    if ("fullWidth" in $$new_props)
      $$invalidate(8, fullWidth = $$new_props.fullWidth);
    if ("updateOnBlur" in $$new_props)
      $$invalidate(26, updateOnBlur = $$new_props.updateOnBlur);
    if ("handleOwnUpdates" in $$new_props)
      $$invalidate(27, handleOwnUpdates = $$new_props.handleOwnUpdates);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*internalUpdate, valuePath*/
    541065216 | $$self.$$.dirty[1] & /*$doc*/
    1) {
      {
        if (!internalUpdate) {
          $$invalidate(30, externalValue = resolveDotpath($doc, valuePath) ?? "");
        }
      }
    }
    if ($$self.$$.dirty[0] & /*internalUpdate, initialRender, externalValue, inputValue, type*/
    1895825920) {
      {
        if (!internalUpdate && !initialRender && externalValue !== inputValue) {
          $$invalidate(9, inputValue = type == "number" ? Number(externalValue) : externalValue);
        }
      }
    }
    if ($$self.$$.dirty[0] & /*inputValue*/
    512)
      ;
    if ($$self.$$.dirty[0] & /*inputValue*/
    512) {
      $$invalidate(12, isEmpty = inputValue === "");
    }
    if ($$self.$$.dirty[0] & /*inputElement, document*/
    8389632) {
      inputElement === document2.activeElement;
    }
    if ($$self.$$.dirty[0] & /*alwaysEditable, editable*/
    129) {
      $$invalidate(0, editable = alwaysEditable || editable);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    editable,
    placeholder,
    maxlength,
    label,
    clickType,
    updateOnInput,
    textClasses,
    alwaysEditable,
    fullWidth,
    inputValue,
    inputElement,
    pulseClass,
    isEmpty,
    LABEL,
    doc,
    updateDebounce,
    handleKeyDown,
    handleBlur,
    enableInput,
    $$props,
    $$restProps,
    enabled,
    valuePath,
    document2,
    type,
    pulse,
    updateOnBlur,
    handleOwnUpdates,
    initialRender,
    internalUpdate,
    externalValue,
    $doc,
    input_binding,
    input_binding_1
  ];
}
__name(instance$W, "instance$W");
class DocInput extends SvelteComponent {
  static {
    __name(this, "DocInput");
  }
  constructor(options) {
    super();
    init$1(
      this,
      options,
      instance$W,
      create_fragment$11,
      safe_not_equal,
      {
        placeholder: 1,
        maxlength: 2,
        valuePath: 22,
        label: 3,
        document: 23,
        editable: 0,
        type: 24,
        clickType: 4,
        pulse: 25,
        updateOnInput: 5,
        enabled: 21,
        textClasses: 6,
        alwaysEditable: 7,
        fullWidth: 8,
        updateOnBlur: 26,
        handleOwnUpdates: 27
      },
      null,
      [-1, -1]
    );
  }
}
function get_each_context$f(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[15] = list[i];
  child_ctx[17] = i;
  return child_ctx;
}
__name(get_each_context$f, "get_each_context$f");
function create_each_block$f(ctx) {
  let tr;
  let td0;
  let docinput0;
  let td1;
  let docselect;
  let td2;
  let docinput1;
  let td3;
  let button;
  let current;
  let mounted;
  let dispose;
  function change_handler(...args) {
    return (
      /*change_handler*/
      ctx[10](
        /*i*/
        ctx[17],
        ...args
      )
    );
  }
  __name(change_handler, "change_handler");
  docinput0 = new DocInput({
    props: {
      valuePath: `changes[${/*i*/
      ctx[17]}].key`,
      alwaysEditable: true,
      updateOnBlur: true,
      handleOwnUpdates: false
    }
  });
  docinput0.$on("change", change_handler);
  function change_handler_1(...args) {
    return (
      /*change_handler_1*/
      ctx[11](
        /*i*/
        ctx[17],
        ...args
      )
    );
  }
  __name(change_handler_1, "change_handler_1");
  docselect = new DocSelect({
    props: {
      valuePath: `changes[${/*i*/
      ctx[17]}].mode`,
      options: activeEffectModes,
      handleOwnUpdates: false
    }
  });
  docselect.$on("change", change_handler_1);
  function change_handler_2(...args) {
    return (
      /*change_handler_2*/
      ctx[12](
        /*i*/
        ctx[17],
        ...args
      )
    );
  }
  __name(change_handler_2, "change_handler_2");
  docinput1 = new DocInput({
    props: {
      valuePath: `changes[${/*i*/
      ctx[17]}].value`,
      alwaysEditable: true,
      updateOnBlur: true,
      handleOwnUpdates: false
    }
  });
  docinput1.$on("change", change_handler_2);
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[13](
        /*i*/
        ctx[17]
      )
    );
  }
  __name(click_handler_1, "click_handler_1");
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      create_component(docinput0.$$.fragment);
      td1 = element("td");
      create_component(docselect.$$.fragment);
      td2 = element("td");
      create_component(docinput1.$$.fragment);
      td3 = element("td");
      button = element("button");
      button.innerHTML = `<i class="fa fa-trash"></i>`;
      attr(td1, "class", "shrink");
      attr(button, "class", "stealth");
      attr(td3, "class", "buttons");
      attr(tr, "class", "svelte-9qqs1");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      mount_component(docinput0, td0, null);
      append(tr, td1);
      mount_component(docselect, td1, null);
      append(tr, td2);
      mount_component(docinput1, td2, null);
      append(tr, td3);
      append(td3, button);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", click_handler_1);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    i(local) {
      if (current)
        return;
      transition_in(docinput0.$$.fragment, local);
      transition_in(docselect.$$.fragment, local);
      transition_in(docinput1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(docinput0.$$.fragment, local);
      transition_out(docselect.$$.fragment, local);
      transition_out(docinput1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(tr);
      }
      destroy_component(docinput0);
      destroy_component(docselect);
      destroy_component(docinput1);
      mounted = false;
      dispose();
    }
  };
}
__name(create_each_block$f, "create_each_block$f");
function create_fragment$10(ctx) {
  let div2;
  let div1;
  let h1;
  let table;
  let thead;
  let tr;
  let th0;
  let th1;
  let th2;
  let th3;
  let button0;
  let tbody;
  let div0;
  let button1;
  let t4_value = localize$1("Instructions.SaveChanges") + "";
  let t4;
  let button1_class_value;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*pendingChanges*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$f(get_each_context$f(ctx, each_value, i));
  }
  const out = /* @__PURE__ */ __name((i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  }), "out");
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      h1 = element("h1");
      h1.textContent = "Changes";
      table = element("table");
      thead = element("thead");
      tr = element("tr");
      th0 = element("th");
      th0.textContent = `${localize$1("EFFECT.Change.Key")}`;
      th1 = element("th");
      th1.textContent = `${localize$1("EFFECT.Change.Mode")}`;
      th2 = element("th");
      th2.textContent = `${localize$1("EFFECT.Change.Value")}`;
      th3 = element("th");
      button0 = element("button");
      button0.innerHTML = `<i class="fa fa-plus"></i>`;
      tbody = element("tbody");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      div0 = element("div");
      button1 = element("button");
      t4 = text(t4_value);
      attr(h1, "class", "font-cinzel center");
      attr(th0, "class", "left expand");
      attr(th0, "scope", "col");
      attr(th1, "class", "shrink left fixed");
      attr(th1, "scope", "col");
      attr(th2, "class", "left expand");
      attr(th2, "scope", "col");
      attr(button0, "class", "stealth");
      attr(th3, "class", "buttons");
      attr(th3, "scope", "col");
      attr(tr, "class", "gold svelte-9qqs1");
      attr(table, "class", "borderless svelte-9qqs1");
      attr(button1, "class", button1_class_value = "glossy-button gold-light hover-shine " + /*buttonAnimation*/
      ctx[1] + " svelte-9qqs1");
      attr(div0, "class", "flexrow mt-sm");
      attr(div1, "class", "flexcol flex3 left high wide mb-md");
      attr(div2, "class", "item-sheet details overflow wide inset mt-sm svelte-9qqs1");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, h1);
      append(div1, table);
      append(table, thead);
      append(thead, tr);
      append(tr, th0);
      append(tr, th1);
      append(tr, th2);
      append(tr, th3);
      append(th3, button0);
      append(table, tbody);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(tbody, null);
        }
      }
      append(div1, div0);
      append(div0, button1);
      append(button1, t4);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[9]
          ),
          listen(
            button1,
            "click",
            /*save*/
            ctx[8]
          ),
          listen(
            button1,
            "mouseleave",
            /*handleMouseLeave*/
            ctx[4]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*deleteChange, handleInputChange, handleSelectChange, pendingChanges*/
      105) {
        each_value = ensure_array_like(
          /*pendingChanges*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$f(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$f(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(tbody, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & /*buttonAnimation*/
      2 && button1_class_value !== (button1_class_value = "glossy-button gold-light hover-shine " + /*buttonAnimation*/
      ctx2[1] + " svelte-9qqs1")) {
        attr(button1, "class", button1_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_fragment$10, "create_fragment$10");
function instance$V($$self, $$props, $$invalidate) {
  let $doc;
  const doc = getContext("#doc");
  component_subscribe($$self, doc, (value) => $$invalidate(14, $doc = value));
  let pendingChanges = [];
  let buttonAnimation = "";
  onMount(() => {
    $$invalidate(0, pendingChanges = ($doc.changes || []).map((change) => ({ ...change })));
  });
  function handleInputChange(event, index, field) {
    const { value } = event.detail;
    $$invalidate(0, pendingChanges[index][field] = value, pendingChanges);
    $$invalidate(0, pendingChanges = [...pendingChanges]);
  }
  __name(handleInputChange, "handleInputChange");
  function handleMouseLeave() {
    if (buttonAnimation) {
      $$invalidate(1, buttonAnimation = "");
    }
    game.system.log.b("mouse leave");
  }
  __name(handleMouseLeave, "handleMouseLeave");
  function handleSelectChange(event, index) {
    const { value } = event.detail;
    $$invalidate(0, pendingChanges[index].mode = value, pendingChanges);
    $$invalidate(0, pendingChanges = [...pendingChanges]);
  }
  __name(handleSelectChange, "handleSelectChange");
  function deleteChange(index) {
    $$invalidate(0, pendingChanges = pendingChanges.filter((_, i) => i !== index));
  }
  __name(deleteChange, "deleteChange");
  function addChange() {
    $$invalidate(0, pendingChanges = [...pendingChanges, { key: "", mode: null, value: "" }]);
  }
  __name(addChange, "addChange");
  function save() {
    if (pendingChanges.length === 0) {
      $doc.update({ changes: [] });
      $$invalidate(1, buttonAnimation = "success-glow hover-disabled");
      return;
    }
    for (const change of pendingChanges) {
      if (!change.key || (change.mode < 0 || change.mode > 5) || !change.value) {
        game.system.log.b(pendingChanges);
        ui.notifications.warn("Please complete all fields");
        $$invalidate(1, buttonAnimation = "error-shake hover-disabled ");
        return;
      }
      change.priority = 1;
    }
    game.system.log.g("Saving...", pendingChanges);
    $doc.update({ changes: pendingChanges });
    game.system.log.g("Changes saved");
    $$invalidate(1, buttonAnimation = "success-glow hover-disabled");
  }
  __name(save, "save");
  onMount(async () => {
    console.log("Changes", $doc);
  });
  const click_handler2 = /* @__PURE__ */ __name(() => addChange(), "click_handler");
  const change_handler = /* @__PURE__ */ __name((i, e) => handleInputChange(e, i, "key"), "change_handler");
  const change_handler_1 = /* @__PURE__ */ __name((i, e) => handleSelectChange(e, i), "change_handler_1");
  const change_handler_2 = /* @__PURE__ */ __name((i, e) => handleInputChange(e, i, "value"), "change_handler_2");
  const click_handler_1 = /* @__PURE__ */ __name((i) => deleteChange(i), "click_handler_1");
  return [
    pendingChanges,
    buttonAnimation,
    doc,
    handleInputChange,
    handleMouseLeave,
    handleSelectChange,
    deleteChange,
    addChange,
    save,
    click_handler2,
    change_handler,
    change_handler_1,
    change_handler_2,
    click_handler_1
  ];
}
__name(instance$V, "instance$V");
class Changes extends SvelteComponent {
  static {
    __name(this, "Changes");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$V, create_fragment$10, safe_not_equal, {});
  }
}
function get_each_context$e(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i];
  return child_ctx;
}
__name(get_each_context$e, "get_each_context$e");
function get_each_context_1$3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i];
  return child_ctx;
}
__name(get_each_context_1$3, "get_each_context_1$3");
function create_if_block_2$9(ctx) {
  let img;
  let img_src_value;
  let img_alt_value;
  return {
    c() {
      img = element("img");
      attr(img, "class", "tab-icon svelte-cf8qmp");
      if (!src_url_equal(img.src, img_src_value = /*tab*/
      ctx[5].img))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*tab*/
      ctx[5].label + " tab icon");
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*tabs*/
      2 && !src_url_equal(img.src, img_src_value = /*tab*/
      ctx2[5].img)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*tabs*/
      2 && img_alt_value !== (img_alt_value = /*tab*/
      ctx2[5].label + " tab icon")) {
        attr(img, "alt", img_alt_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
__name(create_if_block_2$9, "create_if_block_2$9");
function create_if_block_1$d(ctx) {
  let span;
  let t_value = (
    /*tab*/
    ctx[5].label + ""
  );
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*tabs*/
      2 && t_value !== (t_value = /*tab*/
      ctx2[5].label + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
__name(create_if_block_1$d, "create_if_block_1$d");
function create_each_block_1$3(ctx) {
  let button;
  let button_class_value;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (!/*tab*/
    ctx2[5].img && !/*tab*/
    ctx2[5].icon)
      return create_if_block_1$d;
    if (
      /*tab*/
      ctx2[5].img
    )
      return create_if_block_2$9;
  }
  __name(select_block_type, "select_block_type");
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type && current_block_type(ctx);
  function click_handler2() {
    return (
      /*click_handler*/
      ctx[4](
        /*tab*/
        ctx[5]
      )
    );
  }
  __name(click_handler2, "click_handler");
  return {
    c() {
      button = element("button");
      if (if_block)
        if_block.c();
      attr(button, "class", button_class_value = "short gold " + /*tab*/
      (ctx[5].id === /*activeTab*/
      ctx[0] ? "active" : "") + " svelte-cf8qmp");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (if_block)
        if_block.m(button, null);
      if (!mounted) {
        dispose = listen(button, "click", prevent_default(click_handler2));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
        if_block.p(ctx, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx);
        if (if_block) {
          if_block.c();
          if_block.m(button, null);
        }
      }
      if (dirty & /*tabs, activeTab*/
      3 && button_class_value !== (button_class_value = "short gold " + /*tab*/
      (ctx[5].id === /*activeTab*/
      ctx[0] ? "active" : "") + " svelte-cf8qmp")) {
        attr(button, "class", button_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (if_block) {
        if_block.d();
      }
      mounted = false;
      dispose();
    }
  };
}
__name(create_each_block_1$3, "create_each_block_1$3");
function create_if_block$j(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*tab*/
    ctx[5].component
  );
  function switch_props(ctx2, dirty) {
    return { props: { sheet: (
      /*sheet*/
      ctx2[2]
    ) } };
  }
  __name(switch_props, "switch_props");
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*tabs*/
      2 && switch_value !== (switch_value = /*tab*/
      ctx2[5].component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*sheet*/
        4)
          switch_instance_changes.sheet = /*sheet*/
          ctx2[2];
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
__name(create_if_block$j, "create_if_block$j");
function create_each_block$e(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*tab*/
    ctx[5].id === /*activeTab*/
    ctx[0] && create_if_block$j(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*tab*/
        ctx2[5].id === /*activeTab*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*tabs, activeTab*/
          3) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$j(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
__name(create_each_block$e, "create_each_block$e");
function create_fragment$$(ctx) {
  let div2;
  let div0;
  let div1;
  let div1_class_value;
  let current;
  let each_value_1 = ensure_array_like(
    /*tabs*/
    ctx[1]
  );
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks_1[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
  }
  let each_value = ensure_array_like(
    /*tabs*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$e(get_each_context$e(ctx, each_value, i));
  }
  const out = /* @__PURE__ */ __name((i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  }), "out");
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      div1 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "tabs-list svelte-cf8qmp");
      attr(div1, "class", div1_class_value = null_to_empty(`tab-content ${/*$$props*/
      ctx[3]?.class?.includes("small") ? "tab-content--small" : ""} ${/*$$props*/
      ctx[3]?.class?.includes("tall") ? "tab-content--tall" : ""}`) + " svelte-cf8qmp");
      attr(div2, "class", "tabs svelte-cf8qmp");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(div0, null);
        }
      }
      append(div2, div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div1, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*tabs, activeTab*/
      3) {
        each_value_1 = ensure_array_like(
          /*tabs*/
          ctx2[1]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1$3(ctx2, each_value_1, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_1$3(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(div0, null);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_1.length;
      }
      if (dirty & /*tabs, sheet, activeTab*/
      7) {
        each_value = ensure_array_like(
          /*tabs*/
          ctx2[1]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$e(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$e(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div1, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & /*$$props*/
      8 && div1_class_value !== (div1_class_value = null_to_empty(`tab-content ${/*$$props*/
      ctx2[3]?.class?.includes("small") ? "tab-content--small" : ""} ${/*$$props*/
      ctx2[3]?.class?.includes("tall") ? "tab-content--tall" : ""}`) + " svelte-cf8qmp")) {
        attr(div1, "class", div1_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
    }
  };
}
__name(create_fragment$$, "create_fragment$$");
function instance$U($$self, $$props, $$invalidate) {
  let { tabs = [] } = $$props;
  let { sheet = void 0 } = $$props;
  let { activeTab: activeTab2 = void 0 } = $$props;
  onMount(() => {
    $$invalidate(0, activeTab2 = tabs[0].id);
    game.system.log.d("Tabs", tabs);
  });
  const click_handler2 = /* @__PURE__ */ __name((tab) => $$invalidate(0, activeTab2 = tab.id), "click_handler");
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("tabs" in $$new_props)
      $$invalidate(1, tabs = $$new_props.tabs);
    if ("sheet" in $$new_props)
      $$invalidate(2, sheet = $$new_props.sheet);
    if ("activeTab" in $$new_props)
      $$invalidate(0, activeTab2 = $$new_props.activeTab);
  };
  $$props = exclude_internal_props($$props);
  return [activeTab2, tabs, sheet, $$props, click_handler2];
}
__name(instance$U, "instance$U");
class Tabs extends SvelteComponent {
  static {
    __name(this, "Tabs");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$U, create_fragment$$, safe_not_equal, { tabs: 1, sheet: 2, activeTab: 0 });
  }
}
function create_if_block$i(ctx) {
  let label_1;
  let t_value = (
    /*$$props*/
    ctx[6].label + ""
  );
  let t;
  let label_1_for_value;
  return {
    c() {
      label_1 = element("label");
      t = text(t_value);
      attr(label_1, "class", "flex1");
      attr(label_1, "for", label_1_for_value = /*inputElement*/
      ctx[2].id);
    },
    m(target, anchor) {
      insert(target, label_1, anchor);
      append(label_1, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*$$props*/
      64 && t_value !== (t_value = /*$$props*/
      ctx2[6].label + ""))
        set_data(t, t_value);
      if (dirty & /*inputElement*/
      4 && label_1_for_value !== (label_1_for_value = /*inputElement*/
      ctx2[2].id)) {
        attr(label_1, "for", label_1_for_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(label_1);
      }
    }
  };
}
__name(create_if_block$i, "create_if_block$i");
function create_fragment$_(ctx) {
  let div;
  let t;
  let input;
  let input_disabled_value;
  let div_class_value;
  let mounted;
  let dispose;
  let if_block = (
    /*$$props*/
    ctx[6].label && create_if_block$i(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      input = element("input");
      attr(input, "id", "doc-checkbox");
      attr(input, "type", "checkbox");
      input.disabled = input_disabled_value = /*disabled*/
      ctx[0] || !/*$doc*/
      ctx[3].isOwner;
      attr(div, "class", div_class_value = null_to_empty(
        /*$$props*/
        ctx[6].class
      ) + " svelte-8l8ndv");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append(div, t);
      append(div, input);
      ctx[12](input);
      input.checked = /*inputValue*/
      ctx[1];
      if (!mounted) {
        dispose = [
          listen(
            input,
            "change",
            /*input_change_handler*/
            ctx[13]
          ),
          listen(
            input,
            "change",
            /*change_handler*/
            ctx[11]
          ),
          listen(
            input,
            "change",
            /*update*/
            ctx[5]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*$$props*/
        ctx2[6].label
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$i(ctx2);
          if_block.c();
          if_block.m(div, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*disabled, $doc*/
      9 && input_disabled_value !== (input_disabled_value = /*disabled*/
      ctx2[0] || !/*$doc*/
      ctx2[3].isOwner)) {
        input.disabled = input_disabled_value;
      }
      if (dirty & /*inputValue*/
      2) {
        input.checked = /*inputValue*/
        ctx2[1];
      }
      if (dirty & /*$$props*/
      64 && div_class_value !== (div_class_value = null_to_empty(
        /*$$props*/
        ctx2[6].class
      ) + " svelte-8l8ndv")) {
        attr(div, "class", div_class_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block)
        if_block.d();
      ctx[12](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_fragment$_, "create_fragment$_");
function instance$T($$self, $$props, $$invalidate) {
  let $doc;
  let { valuePath = "" } = $$props;
  let { document: document2 = false } = $$props;
  let { preventDefault = false } = $$props;
  let { disabled = false } = $$props;
  let { label = "" } = $$props;
  let inputValue, inputElement;
  const doc = document2 || getContext("#doc");
  component_subscribe($$self, doc, (value) => $$invalidate(3, $doc = value));
  const update2 = /* @__PURE__ */ __name(async () => {
    game.system.log.d("DocCheckBox internal default update method");
    if (preventDefault)
      return;
    await $doc.update({ [valuePath]: Boolean(inputValue) });
    game.system.log.d("valuePath", valuePath);
    game.system.log.d($doc);
  }, "update");
  onMount(() => {
    $$invalidate(1, inputValue = resolveDotpath($doc, valuePath));
  });
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  __name(change_handler, "change_handler");
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement = $$value;
      $$invalidate(2, inputElement);
    });
  }
  __name(input_binding, "input_binding");
  function input_change_handler() {
    inputValue = this.checked;
    $$invalidate(1, inputValue);
  }
  __name(input_change_handler, "input_change_handler");
  $$self.$$set = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("valuePath" in $$new_props)
      $$invalidate(7, valuePath = $$new_props.valuePath);
    if ("document" in $$new_props)
      $$invalidate(8, document2 = $$new_props.document);
    if ("preventDefault" in $$new_props)
      $$invalidate(9, preventDefault = $$new_props.preventDefault);
    if ("disabled" in $$new_props)
      $$invalidate(0, disabled = $$new_props.disabled);
    if ("label" in $$new_props)
      $$invalidate(10, label = $$new_props.label);
  };
  $$props = exclude_internal_props($$props);
  return [
    disabled,
    inputValue,
    inputElement,
    $doc,
    doc,
    update2,
    $$props,
    valuePath,
    document2,
    preventDefault,
    label,
    change_handler,
    input_binding,
    input_change_handler
  ];
}
__name(instance$T, "instance$T");
class DocCheckbox extends SvelteComponent {
  static {
    __name(this, "DocCheckbox");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$T, create_fragment$_, safe_not_equal, {
      valuePath: 7,
      document: 8,
      preventDefault: 9,
      disabled: 0,
      label: 10
    });
  }
  get valuePath() {
    return this.$$.ctx[7];
  }
  set valuePath(valuePath) {
    this.$$set({ valuePath });
    flush();
  }
  get document() {
    return this.$$.ctx[8];
  }
  set document(document2) {
    this.$$set({ document: document2 });
    flush();
  }
  get preventDefault() {
    return this.$$.ctx[9];
  }
  set preventDefault(preventDefault) {
    this.$$set({ preventDefault });
    flush();
  }
  get disabled() {
    return this.$$.ctx[0];
  }
  set disabled(disabled) {
    this.$$set({ disabled });
    flush();
  }
  get label() {
    return this.$$.ctx[10];
  }
  set label(label) {
    this.$$set({ label });
    flush();
  }
}
class FoundryStyles {
  static {
    __name(this, "FoundryStyles");
  }
  static #sheet = void 0;
  /** @type {Map<string, {[key: string]: string}>} */
  static #sheetMap = /* @__PURE__ */ new Map();
  static #initialized = false;
  /**
   * Called once on initialization / first usage. Parses the core foundry style sheet.
   */
  static #initialize() {
    this.#initialized = true;
    const styleSheets = Array.from(document.styleSheets).filter((entry) => entry.href !== null);
    let sheet;
    const foundryStyleSheet = globalThis.foundry.utils.getRoute("/css/style.css");
    for (const styleSheet of styleSheets) {
      let url;
      try {
        url = new URL(styleSheet.href);
      } catch (err) {
        continue;
      }
      if (typeof url.pathname === "string" && url.pathname === foundryStyleSheet) {
        this.#sheet = sheet = styleSheet;
        break;
      }
    }
    if (!sheet) {
      return;
    }
    for (const rule of sheet.cssRules) {
      if (!(rule instanceof CSSStyleRule)) {
        continue;
      }
      const obj = {};
      for (const entry of rule.style.cssText.split(";")) {
        const parts = entry.split(":");
        if (parts.length < 2) {
          continue;
        }
        obj[parts[0].trim()] = parts[1].trim();
      }
      this.#sheetMap.set(rule.selectorText, obj);
    }
  }
  /**
   * Gets the properties object associated with the selector. Try and use a direct match otherwise all keys
   * are iterated to find a selector string that includes the `selector`.
   *
   * @param {string}   selector - Selector to find.
   *
   * @returns { {[key: string]: string} } Properties object.
   */
  static getProperties(selector) {
    if (!this.#initialized) {
      this.#initialize();
    }
    if (this.#sheetMap.has(selector)) {
      return this.#sheetMap.get(selector);
    }
    for (const key of this.#sheetMap.keys()) {
      if (key.includes(selector)) {
        return this.#sheetMap.get(key);
      }
    }
    return void 0;
  }
  /**
   * Gets a specific property value from the given `selector` and `property` key. Try and use a direct selector
   * match otherwise all keys are iterated to find a selector string that includes `selector`.
   *
   * @param {string}   selector - Selector to find.
   *
   * @param {string}   property - Specific property to locate.
   *
   * @returns {string|undefined} Property value.
   */
  static getProperty(selector, property) {
    if (!this.#initialized) {
      this.#initialize();
    }
    if (this.#sheetMap.has(selector)) {
      const data = this.#sheetMap.get(selector);
      return isObject(data) && property in data ? data[property] : void 0;
    }
    for (const key of this.#sheetMap.keys()) {
      if (key.includes(selector)) {
        const data = this.#sheetMap.get(key);
        if (isObject(data) && property in data) {
          return data[property];
        }
      }
    }
    return void 0;
  }
}
class FVTTConfigure {
  static {
    __name(this, "FVTTConfigure");
  }
  static #initialized = false;
  static initialize() {
    if (this.#initialized) {
      return;
    }
    const cssVariables2 = new TJSStyleManager({ docKey: "#__tjs-root-styles", version: 1.1 });
    this.#initialized = true;
    cssVariables2.setProperties({
      // For components w/ transparent background checkered pattern.
      "--tjs-checkerboard-background-dark": "rgb(205, 205, 205)",
      "--tjs-checkerboard-background-10": `url('data:image/svg+xml;utf8,<svg preserveAspectRatio="none"  viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><rect x="0" y="0" width="5" height="5" fill="transparent" /><rect x="5" y="5" width="5" height="5" fill="transparent" /><rect x="5" y="0" width="5" height="5" fill="white" /><rect x="0" y="5" width="5" height="5" fill="white" /></svg>') 0 0 / 10px 10px, var(--tjs-checkerboard-background-dark, rgb(205, 205, 205))`
    }, false);
    cssVariables2.setProperties({
      "--tjs-action-ripple-background": "rgba(0, 0, 0, 0.35)"
    }, false);
    cssVariables2.setProperties({
      "--tjs-icon-button-background-hover": "rgba(0, 0, 0, 0.10)",
      "--tjs-icon-button-background-selected": "rgba(0, 0, 0, 0.20)"
    }, false);
    {
      const props = FoundryStyles.getProperties('input[type="text"], input[type="number"]');
      if (isObject(props)) {
        cssVariables2.setProperties({
          "--tjs-input-background": "background" in props ? props.background : "rgba(0, 0, 0, 0.05)",
          "--tjs-input-border": "border" in props ? props.border : "1px solid var(--color-border-light-tertiary)",
          "--tjs-input-border-radius": "border-radius" in props ? props["border-radius"] : "3px",
          "--tjs-input-height": "height" in props ? props.height : "var(--form-field-height)",
          "--tjs-input-min-width": "min-width" in props ? props["min-width"] : "20px",
          "--tjs-input-padding": "padding" in props ? props["padding"] : "1px 3px",
          "--tjs-input-width": "width" in props ? props.width : "calc(100% - 2px)",
          // Set default values that are only to be referenced and not set.
          "--_tjs-default-input-height": "height" in props ? props.height : "var(--form-field-height)",
          // Set directly / no lookup:
          "--tjs-input-border-color": "var(--color-border-light-tertiary)"
        }, false);
      }
    }
    {
      const propsTrack = FoundryStyles.getProperties('input[type="range"]::-webkit-slider-runnable-track');
      const propsTrackFocus = FoundryStyles.getProperties('input[type="range"]:focus::-webkit-slider-runnable-track');
      const propsThumb = FoundryStyles.getProperties('input[type="range"]::-webkit-slider-thumb');
      const propsThumbFocus = FoundryStyles.getProperties('input[type="range"]:focus::-webkit-slider-thumb');
      if (isObject(propsTrack)) {
        cssVariables2.setProperties({
          "--tjs-input-range-slider-track-box-shadow": "box-shadow" in propsTrack ? propsTrack["box-shadow"] : "1px 1px 1px #000000, 0px 0px 1px #0d0d0d"
        }, false);
      }
      if (isObject(propsTrackFocus)) {
        cssVariables2.setProperties({
          "--tjs-input-range-slider-track-box-shadow-focus": "box-shadow" in propsTrackFocus ? propsTrackFocus["box-shadow"] : "1px 1px 1px #000000, 0px 0px 1px #0d0d0d"
        }, false);
      }
      if (isObject(propsThumb)) {
        cssVariables2.setProperties({
          "--tjs-input-range-slider-thumb-box-shadow": "box-shadow" in propsThumb ? propsThumb["box-shadow"] : "0 0 5px var(--color-shadow-primary)"
        }, false);
      }
      if (isObject(propsThumbFocus)) {
        cssVariables2.setProperties({
          "--tjs-input-range-slider-thumb-box-shadow-focus": "box-shadow" in propsThumbFocus ? propsThumbFocus["box-shadow"] : "0 0 5px var(--color-shadow-primary)"
        }, false);
      }
    }
    cssVariables2.setProperties({
      // `popup` is for components that are slightly elevated, but connected to an application;
      // see: TJSMenu / TJSContextMenu / TJSColordPicker
      "--tjs-default-popup-background": "var(--color-text-dark-header, #23221d)",
      "--tjs-default-popup-border": "1px solid var(--color-border-dark, #000)",
      "--tjs-default-popup-box-shadow": "0 0 2px var(--color-shadow-dark, #000)",
      "--tjs-default-popup-primary-color": "var(--color-text-light-primary, #b5b3a4)",
      "--tjs-default-popup-highlight-color": "var(--color-text-light-highlight, #f0f0e0)",
      // `popover` is for components that are elevated and independent; see: TJSContextMenu
      "--tjs-default-popover-border": "1px solid var(--color-border-dark, #000)",
      "--tjs-default-popover-box-shadow": "0 0 10px var(--color-shadow-dark, #000)"
    }, false);
    Hooks.on("PopOut:loading", (app, popout) => {
      if (app instanceof SvelteApplication) {
        popout.document.addEventListener("DOMContentLoaded", () => cssVariables2.clone(popout.document));
      }
    });
  }
}
FVTTConfigure.initialize();
function create_fragment$Z(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = `${localize(`EDITOR.${/*revealed*/
      ctx[2] ? "Hide" : "Reveal"}`)}`;
      attr(button, "type", "button");
      attr(button, "class", "reveal svelte-1e62bm0");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
__name(create_fragment$Z, "create_fragment$Z");
function instance$S($$self, $$props, $$invalidate) {
  let { onUpdateRevealButtons = void 0 } = $$props;
  let { sectionEl = void 0 } = $$props;
  const revealed = sectionEl.classList.contains("revealed");
  const click_handler2 = /* @__PURE__ */ __name(() => onUpdateRevealButtons(!revealed, sectionEl.id), "click_handler");
  $$self.$$set = ($$props2) => {
    if ("onUpdateRevealButtons" in $$props2)
      $$invalidate(0, onUpdateRevealButtons = $$props2.onUpdateRevealButtons);
    if ("sectionEl" in $$props2)
      $$invalidate(1, sectionEl = $$props2.sectionEl);
  };
  return [onUpdateRevealButtons, sectionEl, revealed, click_handler2];
}
__name(instance$S, "instance$S");
class RevealSecretButton extends SvelteComponent {
  static {
    __name(this, "RevealSecretButton");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$S, create_fragment$Z, safe_not_equal, { onUpdateRevealButtons: 0, sectionEl: 1 });
  }
}
function processHTML({ html, process, selector, containerElement = "div", firstMatchOnly = false, namespaceURI }) {
  if (typeof html !== "string") {
    throw new TypeError(`processHTML error: 'html' is not a string.`);
  }
  if (typeof process !== "function") {
    throw new TypeError(`processHTML error: 'process' is not a function.`);
  }
  if (typeof selector !== "string") {
    throw new TypeError(`processHTML error: 'selector' is not a string.`);
  }
  if (typeof containerElement !== "string") {
    throw new TypeError(`processHTML error: 'containerElement' is not a string.`);
  }
  if (typeof firstMatchOnly !== "boolean") {
    throw new TypeError(`processHTML error: 'firstMatchOnly' is not a boolean.`);
  }
  if (namespaceURI !== void 0 && typeof namespaceURI !== "string") {
    throw new TypeError(`processHTML error: 'namespaceURI' is not a string.`);
  }
  const resolveSelector = namespaceURI ? `${namespaceURI}|${selector}` : selector;
  const container = document.createElement(containerElement);
  container.innerHTML = html;
  if (firstMatchOnly) {
    const element2 = container.querySelector(resolveSelector);
    if (element2) {
      process(element2);
    }
  } else {
    const elements = container.querySelectorAll(resolveSelector);
    if (elements) {
      for (const element2 of elements) {
        process(element2);
      }
    }
  }
  return container.innerHTML;
}
__name(processHTML, "processHTML");
function createMountRevealSecretButtons(doc, options) {
  function onUpdateRevealButtons(revealed, id) {
    const foundryDoc = doc.get();
    if (foundryDoc && typeof options?.fieldName === "string") {
      const html = safeAccess(foundryDoc, options?.fieldName);
      if (typeof html === "string") {
        const newContent = processHTML({
          html,
          process: (element2) => element2.classList[`${revealed ? "add" : "remove"}`]("revealed"),
          selector: `section.secret[id=${id}]`,
          firstMatchOnly: true
        });
        foundryDoc.update({ [options?.fieldName]: newContent });
      }
    }
  }
  __name(onUpdateRevealButtons, "onUpdateRevealButtons");
  return (node) => {
    const components = [];
    function destroyComponents() {
      for (const component of components) {
        component.$destroy();
      }
      components.length = 0;
    }
    __name(destroyComponents, "destroyComponents");
    function mountComponents() {
      nextAnimationFrame().then(() => {
        destroyComponents();
        const secretSections = node.querySelectorAll("section.secret[id]");
        for (const sectionEl of secretSections) {
          components.push(new RevealSecretButton({
            target: sectionEl,
            anchor: sectionEl.firstChild,
            props: {
              onUpdateRevealButtons,
              sectionEl
            }
          }));
        }
      });
    }
    __name(mountComponents, "mountComponents");
    return {
      /**
       * On update if the external parameter `mountRevealButtons` is true and a document / fieldName is defined
       * mount the secret reveal buttons otherwise destroy any existing buttons.
       *
       * Note: In the editor components `enrichedContent` is also passed, but unused, but it will trigger an update
       * whenever the content changes.
       *
       * @param mountRevealButtons
       */
      update({ mountRevealButtons }) {
        if (mountRevealButtons && doc.get() && typeof options?.fieldName === "string") {
          mountComponents();
        } else {
          destroyComponents();
        }
      },
      destroy() {
        destroyComponents();
      }
    };
  };
}
__name(createMountRevealSecretButtons, "createMountRevealSecretButtons");
class PMImpl {
  static {
    __name(this, "PMImpl");
  }
  /**
   * Handles `options.initialSelection`: Sets the initial cursor / selection range to the start, end, or selects
   * all text.
   *
   * @param {globalThis.EditorView}  view - PM editor view.
   *
   * @param {object}  options - TJSProseMirror options.
   */
  static setInitialSelection(view, options) {
    const tr = view.state.tr;
    const doc = tr.doc;
    const initialSelection = options.initialSelection;
    const type = initialSelection === "all" || initialSelection === "end" || initialSelection === "start" ? initialSelection : "start";
    const minPos = globalThis.ProseMirror.TextSelection.atStart(doc).from;
    const maxPos = globalThis.ProseMirror.TextSelection.atEnd(doc).to;
    let transaction;
    switch (type) {
      case "all": {
        const resolvedFrom = clamp(0, minPos, maxPos);
        const resolvedEnd = clamp(doc.content.size, minPos, maxPos);
        transaction = tr.setSelection(globalThis.ProseMirror.TextSelection.create(doc, resolvedFrom, resolvedEnd));
        break;
      }
      case "end": {
        const resolvedFrom = clamp(doc.content.size, minPos, maxPos);
        const resolvedEnd = clamp(doc.content.size, minPos, maxPos);
        transaction = tr.setSelection(globalThis.ProseMirror.TextSelection.create(doc, resolvedFrom, resolvedEnd));
        break;
      }
      case "start": {
        const resolvedFrom = clamp(0, minPos, maxPos);
        const resolvedEnd = clamp(0, minPos, maxPos);
        transaction = tr.setSelection(globalThis.ProseMirror.TextSelection.create(doc, resolvedFrom, resolvedEnd));
        break;
      }
    }
    if (transaction) {
      transaction.scrollIntoView();
      view.dispatch(transaction);
    }
  }
}
const ProseMirrorKeyMaps = globalThis.ProseMirror ? globalThis.ProseMirror.ProseMirrorKeyMaps : class {
};
class TJSKeyMaps extends ProseMirrorKeyMaps {
  static {
    __name(this, "TJSKeyMaps");
  }
  /** @type {Function} */
  #onQuit;
  /**
   * @param {globalThis.Schema}   schema - The ProseMirror schema to build keymaps for.
   *
   * @param {object}   [options] - Additional options to configure the plugin's behaviour.
   *
   * @param {Function} [options.onSave] - A function to call when Ctrl+S is pressed.
   *
   * @param {Function} [options.onQuit] - A function to call when Ctrl+Q is pressed.
   */
  constructor(schema, options) {
    super(schema, options);
    if (typeof options.onQuit === "function") {
      this.#onQuit = options.onQuit;
    }
  }
  // eslint-disable-next jsdoc/check-types
  /**
   * Swaps the Foundry default `Escape` / selectParentNode to `Mod-p` and enables `onQuit` function for `Escape`.
   *
   * @returns { {[key: string]: globalThis.ProseMirrorCommand} } ProseMirror keymap data.
   */
  buildMapping() {
    const mapping = super.buildMapping();
    if (this.#onQuit) {
      if (mapping["Escape"]) {
        mapping["Mod-p"] = mapping["Escape"];
      }
      mapping["Escape"] = () => this.#onQuit();
    }
    return mapping;
  }
}
const Plugin = globalThis.ProseMirror ? globalThis.ProseMirror.Plugin : class {
};
const PluginKey = globalThis.ProseMirror ? globalThis.ProseMirror.PluginKey : class {
};
class TJSPasteUUID {
  static {
    __name(this, "TJSPasteUUID");
  }
  /**
   * Defines a regex to check for the shape of a raw Foundry document UUID.
   *
   * @type {RegExp}
   */
  static #s_UUID_REGEX = /(\.).*([a-zA-Z0-9]{16})/;
  /**
   * @returns {Plugin} PM Plugin.
   */
  static build() {
    const instance2 = new this();
    return new Plugin({
      key: new PluginKey("tjsPasteRawUUID"),
      props: {
        transformPastedText: (text2) => instance2.#transformUUID(text2)
      }
    });
  }
  /**
   * Transforms pasted text. Check if pasted test matches the shape of a raw UUID. If so do a lookup and if a
   * document is retrieved transform it to a document link.
   *
   * @param {string}   text - pasted text to transform.
   *
   * @returns {string} Potentially transformed pasted text.
   */
  #transformUUID(text2) {
    if (typeof text2 === "string") {
      try {
        if (TJSPasteUUID.#s_UUID_REGEX.test(text2)) {
          const uuidDoc = globalThis.fromUuidSync(text2);
          if (uuidDoc) {
            text2 = `@UUID[${text2}]{${typeof uuidDoc.name === "string" ? uuidDoc.name : "Unknown"}}`;
          }
        }
      } catch (err) {
      }
    }
    return text2;
  }
}
function create_if_block_1$c(ctx) {
  let a;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      a.innerHTML = `<i class="fas fa-edit"></i>`;
      attr(a, "class", "editor-edit svelte-yxbnoz");
      attr(a, "role", "button");
      attr(a, "tabindex", "-1");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      if (!mounted) {
        dispose = listen(
          a,
          "click",
          /*click_handler*/
          ctx[19]
        );
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(a);
      }
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block_1$c, "create_if_block_1$c");
function create_else_block$2(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "editor-enriched svelte-yxbnoz");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      div.innerHTML = /*enrichedContent*/
      ctx[1];
    },
    p(ctx2, dirty) {
      if (dirty & /*enrichedContent*/
      2)
        div.innerHTML = /*enrichedContent*/
        ctx2[1];
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
__name(create_else_block$2, "create_else_block$2");
function create_if_block$h(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "editor-content svelte-yxbnoz");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      ctx[20](div);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      ctx[20](null);
    }
  };
}
__name(create_if_block$h, "create_if_block$h");
function create_fragment$Y(ctx) {
  let div;
  let t;
  let div_class_value;
  let applyStyles_action;
  let mountRevealSecretButtons_action;
  let mounted;
  let dispose;
  let if_block0 = (
    /*editorButton*/
    ctx[6] && create_if_block_1$c(ctx)
  );
  function select_block_type(ctx2, dirty) {
    if (
      /*editorActive*/
      ctx2[4]
    )
      return create_if_block$h;
    return create_else_block$2;
  }
  __name(select_block_type, "select_block_type");
  let current_block_type = select_block_type(ctx);
  let if_block1 = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t = space();
      if_block1.c();
      attr(div, "class", div_class_value = "editor prosemirror tjs-editor " + (Array.isArray(
        /*options*/
        ctx[0]?.classes
      ) ? (
        /*options*/
        ctx[0].classes.join(" ")
      ) : "") + " svelte-yxbnoz");
      attr(div, "role", "textbox");
      attr(div, "tabindex", "0");
      toggle_class(
        div,
        "click-to-edit",
        /*clickToEdit*/
        ctx[2]
      );
      toggle_class(
        div,
        "editor-active",
        /*editorActive*/
        ctx[4]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t);
      if_block1.m(div, null);
      ctx[21](div);
      if (!mounted) {
        dispose = [
          action_destroyer(applyStyles_action = applyStyles.call(
            null,
            div,
            /*options*/
            ctx[0]?.styles
          )),
          action_destroyer(mountRevealSecretButtons_action = /*mountRevealSecretButtons*/
          ctx[10].call(null, div, {
            mountRevealButtons: !/*editorActive*/
            ctx[4] && /*editable*/
            ctx[3],
            enrichedContent: (
              /*enrichedContent*/
              ctx[1]
            )
          })),
          listen(
            div,
            "click",
            /*onClick*/
            ctx[12]
          ),
          listen(
            div,
            "keydown",
            /*onKeydown*/
            ctx[13]
          ),
          listen(
            div,
            "keyup",
            /*onKeyup*/
            ctx[14]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*editorButton*/
        ctx2[6]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1$c(ctx2);
          if_block0.c();
          if_block0.m(div, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(div, null);
        }
      }
      if (dirty & /*options*/
      1 && div_class_value !== (div_class_value = "editor prosemirror tjs-editor " + (Array.isArray(
        /*options*/
        ctx2[0]?.classes
      ) ? (
        /*options*/
        ctx2[0].classes.join(" ")
      ) : "") + " svelte-yxbnoz")) {
        attr(div, "class", div_class_value);
      }
      if (applyStyles_action && is_function(applyStyles_action.update) && dirty & /*options*/
      1)
        applyStyles_action.update.call(
          null,
          /*options*/
          ctx2[0]?.styles
        );
      if (mountRevealSecretButtons_action && is_function(mountRevealSecretButtons_action.update) && dirty & /*editorActive, editable, enrichedContent*/
      26)
        mountRevealSecretButtons_action.update.call(null, {
          mountRevealButtons: !/*editorActive*/
          ctx2[4] && /*editable*/
          ctx2[3],
          enrichedContent: (
            /*enrichedContent*/
            ctx2[1]
          )
        });
      if (dirty & /*options, clickToEdit*/
      5) {
        toggle_class(
          div,
          "click-to-edit",
          /*clickToEdit*/
          ctx2[2]
        );
      }
      if (dirty & /*options, editorActive*/
      17) {
        toggle_class(
          div,
          "editor-active",
          /*editorActive*/
          ctx2[4]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block0)
        if_block0.d();
      if_block1.d();
      ctx[21](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_fragment$Y, "create_fragment$Y");
function instance$R($$self, $$props, $$invalidate) {
  let $doc;
  let $applicationActiveWindow;
  let { content = "" } = $$props;
  let { enrichedContent = "" } = $$props;
  let { options = {} } = $$props;
  const application = getContext("#external")?.application;
  const applicationActiveWindow = application?.reactive?.storeUIState?.activeWindow ?? writable(globalThis);
  component_subscribe($$self, applicationActiveWindow, (value) => $$invalidate(18, $applicationActiveWindow = value));
  const dispatch2 = createEventDispatcher();
  const doc = new TJSDocument({ delete: onDocumentDeleted });
  component_subscribe($$self, doc, (value) => $$invalidate(17, $doc = value));
  const mountRevealSecretButtons = createMountRevealSecretButtons(doc, options);
  let activeWindow = $applicationActiveWindow;
  let clickToEdit;
  let editable = true;
  let editorContentEl;
  let editor;
  let editorActive = false;
  let editorButton;
  let editorEl;
  let keyCode;
  let keyFocused = false;
  onDestroy(() => {
    if (editorActive) {
      saveEditor({
        remove: typeof options?.button === "boolean" ? options.button : true
      });
    } else {
      destroyEditor();
    }
  });
  onMount(() => {
    if (editable && !editorButton && !clickToEdit) {
      initEditor();
    }
  });
  function destroyEditor(fireCancel = true) {
    if (editor) {
      editor.destroy();
      editor = void 0;
      setTimeout(
        () => {
          $$invalidate(4, editorActive = false);
        },
        0
      );
      if (keyFocused) {
        keyFocused = false;
        setTimeout(
          () => {
            if (CrossWindow.isHTMLElement(editorEl) && editorEl?.isConnected) {
              editorEl.focus();
            }
          },
          100
        );
      }
      if (fireCancel) {
        dispatch2("editor:cancel");
      }
    }
  }
  __name(destroyEditor, "destroyEditor");
  async function initEditor() {
    const remove = typeof options?.button === "boolean" ? options.button : true;
    const editorOptions = {
      ...options,
      plugins: {
        ...ProseMirror.defaultPlugins,
        menu: ProseMirror.ProseMirrorMenu.build(ProseMirror.defaultSchema, {
          compact: typeof options?.menuCompact === "boolean" ? options.menuCompact : false,
          destroyOnSave: remove,
          onSave: () => saveEditor({ remove })
        }),
        keyMaps: TJSKeyMaps.build(ProseMirror.defaultSchema, {
          onSave: () => saveEditor({ remove }),
          onQuit: () => destroyEditor()
        }),
        tjsPasteRawUUID: TJSPasteUUID.build(),
        ...isObject(options?.plugins) ? options.plugins : {}
      }
    };
    $$invalidate(4, editorActive = true);
    await tick();
    editor = await ProseMirrorEditor.create(editorContentEl, content, editorOptions);
    const containerEl = editorEl.querySelector(".editor-container");
    if (containerEl) {
      containerEl.style = "margin: var(--tjs-editor-container-margin, 0)";
    }
    editor.view.focus();
    PMImpl.setInitialSelection(editor.view, options);
    dispatch2("editor:start");
  }
  __name(initEditor, "initEditor");
  function onClick() {
    if (!editorActive && clickToEdit) {
      initEditor();
    }
  }
  __name(onClick, "onClick");
  async function onContentChanged(content2, enrichContent) {
    if (typeof content2 === "string") {
      if (enrichContent) {
        const isOwner = $doc?.isOwner ?? false;
        const relativeTo = $doc ?? void 0;
        const enrichOptions = isObject(options?.enrichOptions) ? {
          secrets: globalThis.game.user.isGM || isOwner,
          relativeTo,
          ...options.enrichOptions,
          async: true
        } : {
          async: true,
          relativeTo,
          secrets: globalThis.game.user.isGM || isOwner
        };
        $$invalidate(1, enrichedContent = await TextEditor.enrichHTML(content2, enrichOptions));
      } else {
        $$invalidate(1, enrichedContent = content2);
      }
    } else {
      $$invalidate(1, enrichedContent = "");
    }
    dispatch2("editor:enrichedContent", { enrichedContent });
  }
  __name(onContentChanged, "onContentChanged");
  function onDocumentDeleted(document2) {
    if (isObject(options)) {
      $$invalidate(0, options.document = void 0, options);
    }
    destroyEditor();
    dispatch2("editor:document:deleted", { document: document2 });
    $$invalidate(15, content = "");
    $$invalidate(1, enrichedContent = "");
  }
  __name(onDocumentDeleted, "onDocumentDeleted");
  function onKeydown(event) {
    if (editorActive) {
      if (event.code === "Escape" || event.code === "KeyS" && (event.ctrlKey || event.metaKey)) {
        event.preventDefault();
        event.stopPropagation();
      }
    } else {
      if (event.code === keyCode) {
        event.preventDefault();
        event.stopPropagation();
      }
    }
  }
  __name(onKeydown, "onKeydown");
  function onKeyup(event) {
    if (event.code === keyCode) {
      if (!editorActive) {
        keyFocused = true;
        initEditor();
      }
      event.preventDefault();
      event.stopPropagation();
    }
  }
  __name(onKeyup, "onKeyup");
  function saveEditor({ remove = true } = {}) {
    if (editor) {
      if (editor.isDirty()) {
        let data = ProseMirror.dom.serializeString(editor.view.state.doc);
        if ($doc && typeof options?.fieldName === "string") {
          $doc.update({ [options.fieldName]: data });
        } else {
          $$invalidate(15, content = data);
        }
        dispatch2("editor:save", { content: data });
      }
      if (remove) {
        destroyEditor(false);
      }
    }
  }
  __name(saveEditor, "saveEditor");
  const click_handler2 = /* @__PURE__ */ __name(() => initEditor(), "click_handler");
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      editorContentEl = $$value;
      $$invalidate(5, editorContentEl);
    });
  }
  __name(div_binding, "div_binding");
  function div_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      editorEl = $$value;
      $$invalidate(7, editorEl);
    });
  }
  __name(div_binding_1, "div_binding_1");
  $$self.$$set = ($$props2) => {
    if ("content" in $$props2)
      $$invalidate(15, content = $$props2.content);
    if ("enrichedContent" in $$props2)
      $$invalidate(1, enrichedContent = $$props2.enrichedContent);
    if ("options" in $$props2)
      $$invalidate(0, options = $$props2.options);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*activeWindow, $applicationActiveWindow, editorActive*/
    327696) {
      if (activeWindow !== $applicationActiveWindow) {
        if (editorActive) {
          saveEditor();
        }
        $$invalidate(16, activeWindow = $applicationActiveWindow);
      }
    }
    if ($$self.$$.dirty & /*options, $doc, editable*/
    131081) {
      {
        if (typeof options?.editable === "boolean") {
          $$invalidate(3, editable = options.editable);
        } else {
          $$invalidate(3, editable = game.user.isGM || (($doc ?? options.document)?.isOwner ?? false));
        }
        if (!editable) {
          destroyEditor();
        }
      }
    }
    if ($$self.$$.dirty & /*editorActive, editable, options*/
    25) {
      $$invalidate(2, clickToEdit = !editorActive && editable && (typeof options?.clickToEdit === "boolean" ? options.clickToEdit : false));
    }
    if ($$self.$$.dirty & /*editorActive, editable, options, clickToEdit*/
    29) {
      $$invalidate(6, editorButton = !editorActive && editable && (typeof options?.button === "boolean" ? options.button : true) && !clickToEdit);
    }
    if ($$self.$$.dirty & /*options*/
    1) {
      keyCode = typeof options?.keyCode === "string" ? options.keyCode : "Enter";
    }
    if ($$self.$$.dirty & /*options, $doc*/
    131073) {
      if (options?.document !== void 0) {
        if (!(options.document instanceof globalThis.foundry.abstract.Document)) {
          throw new TypeError(`TJSProseMirror error: 'options.document' is not a Foundry document.`);
        }
        if (typeof options?.fieldName !== "string") {
          throw new TypeError(`TJSProseMirror error: 'options.document' is defined, but 'options.fieldName' is not a string.`);
        }
        if (options.document !== $doc) {
          $$invalidate(1, enrichedContent = "");
          $$invalidate(15, content = "");
          destroyEditor();
          doc.set(options.document);
        }
      } else {
        if ($doc) {
          $$invalidate(1, enrichedContent = "");
          $$invalidate(15, content = "");
          destroyEditor();
          doc.set(void 0);
        }
      }
    }
    if ($$self.$$.dirty & /*$doc, options, content*/
    163841) {
      {
        $$invalidate(15, content = $doc !== void 0 && typeof options?.fieldName === "string" ? globalThis.foundry.utils.getProperty($doc, options.fieldName) : typeof content === "string" ? content : "");
        onContentChanged(content, typeof options?.enrichContent === "boolean" ? options.enrichContent : true);
      }
    }
  };
  return [
    options,
    enrichedContent,
    clickToEdit,
    editable,
    editorActive,
    editorContentEl,
    editorButton,
    editorEl,
    applicationActiveWindow,
    doc,
    mountRevealSecretButtons,
    initEditor,
    onClick,
    onKeydown,
    onKeyup,
    content,
    activeWindow,
    $doc,
    $applicationActiveWindow,
    click_handler2,
    div_binding,
    div_binding_1
  ];
}
__name(instance$R, "instance$R");
class TJSProseMirror extends SvelteComponent {
  static {
    __name(this, "TJSProseMirror");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$R, create_fragment$Y, safe_not_equal, {
      content: 15,
      enrichedContent: 1,
      options: 0
    });
  }
}
function create_fragment$X(ctx) {
  let tjsprosemirror;
  let updating_content;
  let updating_enrichedContent;
  let current;
  const tjsprosemirror_spread_levels = [
    { options: (
      /*options*/
      ctx[3]
    ) },
    /*$$restProps*/
    ctx[4]
  ];
  function tjsprosemirror_content_binding(value) {
    ctx[8](value);
  }
  __name(tjsprosemirror_content_binding, "tjsprosemirror_content_binding");
  function tjsprosemirror_enrichedContent_binding(value) {
    ctx[9](value);
  }
  __name(tjsprosemirror_enrichedContent_binding, "tjsprosemirror_enrichedContent_binding");
  let tjsprosemirror_props = {};
  for (let i = 0; i < tjsprosemirror_spread_levels.length; i += 1) {
    tjsprosemirror_props = assign(tjsprosemirror_props, tjsprosemirror_spread_levels[i]);
  }
  if (
    /*content*/
    ctx[0] !== void 0
  ) {
    tjsprosemirror_props.content = /*content*/
    ctx[0];
  }
  if (
    /*enrichedContent*/
    ctx[1] !== void 0
  ) {
    tjsprosemirror_props.enrichedContent = /*enrichedContent*/
    ctx[1];
  }
  tjsprosemirror = new TJSProseMirror({ props: tjsprosemirror_props });
  binding_callbacks.push(() => bind(tjsprosemirror, "content", tjsprosemirror_content_binding));
  binding_callbacks.push(() => bind(tjsprosemirror, "enrichedContent", tjsprosemirror_enrichedContent_binding));
  tjsprosemirror.$on(
    "editor:cancel",
    /*editor_cancel_handler*/
    ctx[10]
  );
  tjsprosemirror.$on("editor:enrichedContent", doSomethingWithEnrichedContent);
  tjsprosemirror.$on(
    "editor:save",
    /*editor_save_handler*/
    ctx[11]
  );
  tjsprosemirror.$on(
    "editor:start",
    /*editor_start_handler*/
    ctx[12]
  );
  return {
    c() {
      create_component(tjsprosemirror.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tjsprosemirror, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const tjsprosemirror_changes = dirty & /*options, $$restProps*/
      24 ? get_spread_update(tjsprosemirror_spread_levels, [
        dirty & /*options*/
        8 && { options: (
          /*options*/
          ctx2[3]
        ) },
        dirty & /*$$restProps*/
        16 && get_spread_object(
          /*$$restProps*/
          ctx2[4]
        )
      ]) : {};
      if (!updating_content && dirty & /*content*/
      1) {
        updating_content = true;
        tjsprosemirror_changes.content = /*content*/
        ctx2[0];
        add_flush_callback(() => updating_content = false);
      }
      if (!updating_enrichedContent && dirty & /*enrichedContent*/
      2) {
        updating_enrichedContent = true;
        tjsprosemirror_changes.enrichedContent = /*enrichedContent*/
        ctx2[1];
        add_flush_callback(() => updating_enrichedContent = false);
      }
      tjsprosemirror.$set(tjsprosemirror_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjsprosemirror.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjsprosemirror.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tjsprosemirror, detaching);
    }
  };
}
__name(create_fragment$X, "create_fragment$X");
function doSomethingWithEnrichedContent(event) {
}
__name(doSomethingWithEnrichedContent, "doSomethingWithEnrichedContent");
function instance$Q($$self, $$props, $$invalidate) {
  const omit_props_names = ["content", "attr", "classes", "editable"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $doc;
  let { content = "" } = $$props;
  let { attr: attr2 = "" } = $$props;
  let { classes = "" } = $$props;
  let { editable = "" } = $$props;
  const doc = getContext("#doc");
  component_subscribe($$self, doc, (value) => $$invalidate(13, $doc = value));
  const options = {
    document: $doc,
    // An item to edit description; note: replace w/ valid doc.
    fieldName: attr2,
    // Path to data in `a.b.c`; note: this is a v10 field name.
    // collaborate: false,                             // Enables collaboration; requires document.
    // button: true      // Show edit button to launch editor when hovered; when false editor is open by default.
    classes,
    // clickToEdit: false,  // Clicking editor content initializes the editor; hides the edit button.
    // DOMPurify,        // You can pass DOMPurify from `@typhonjs-fvtt/runtime/dompurify though ProseMirror does
    // essential client side sanitation; IE stripping `<script>` tags, etc.
    editable
  };
  let enrichedContent;
  function tjsprosemirror_content_binding(value) {
    content = value;
    $$invalidate(0, content);
  }
  __name(tjsprosemirror_content_binding, "tjsprosemirror_content_binding");
  function tjsprosemirror_enrichedContent_binding(value) {
    enrichedContent = value;
    $$invalidate(1, enrichedContent);
  }
  __name(tjsprosemirror_enrichedContent_binding, "tjsprosemirror_enrichedContent_binding");
  const editor_cancel_handler = /* @__PURE__ */ __name(() => console.log("! event - editor:cancel"), "editor_cancel_handler");
  const editor_save_handler = /* @__PURE__ */ __name((event) => console.log(`! event - editor:save - ${event.detail.content}`), "editor_save_handler");
  const editor_start_handler = /* @__PURE__ */ __name(() => console.log("! event - editor:start"), "editor_start_handler");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("content" in $$new_props)
      $$invalidate(0, content = $$new_props.content);
    if ("attr" in $$new_props)
      $$invalidate(5, attr2 = $$new_props.attr);
    if ("classes" in $$new_props)
      $$invalidate(6, classes = $$new_props.classes);
    if ("editable" in $$new_props)
      $$invalidate(7, editable = $$new_props.editable);
  };
  return [
    content,
    enrichedContent,
    doc,
    options,
    $$restProps,
    attr2,
    classes,
    editable,
    tjsprosemirror_content_binding,
    tjsprosemirror_enrichedContent_binding,
    editor_cancel_handler,
    editor_save_handler,
    editor_start_handler
  ];
}
__name(instance$Q, "instance$Q");
let ProseMirror$1 = class ProseMirror2 extends SvelteComponent {
  static {
    __name(this, "ProseMirror");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$Q, create_fragment$X, safe_not_equal, {
      content: 0,
      attr: 5,
      classes: 6,
      editable: 7
    });
  }
  get content() {
    return this.$$.ctx[0];
  }
  set content(content) {
    this.$$set({ content });
    flush();
  }
  get attr() {
    return this.$$.ctx[5];
  }
  set attr(attr2) {
    this.$$set({ attr: attr2 });
    flush();
  }
  get classes() {
    return this.$$.ctx[6];
  }
  set classes(classes) {
    this.$$set({ classes });
    flush();
  }
  get editable() {
    return this.$$.ctx[7];
  }
  set editable(editable) {
    this.$$set({ editable });
    flush();
  }
};
function getPropertyCompat(object, key) {
  const foundryVersion = (game?.version ?? game?.data?.version) || "0.0";
  const [majorVersion] = foundryVersion.split(".").map((v) => parseInt(v, 10) || 0);
  if (majorVersion >= 12 && foundry?.utils?.getProperty) {
    return foundry.utils.getProperty(object, key);
  }
  return globalThis.getProperty(object, key);
}
__name(getPropertyCompat, "getPropertyCompat");
function get_each_context$d(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i];
  return child_ctx;
}
__name(get_each_context$d, "get_each_context$d");
function get_each_context_1$2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i];
  return child_ctx;
}
__name(get_each_context_1$2, "get_each_context_1$2");
function create_each_block_1$2(ctx) {
  let option;
  let t_value = localize$1(`statusEffects.${/*tag*/
  ctx[10]}.name`) + "";
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = /*tag*/
      ctx[10];
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*availableUnselectedTags*/
      8 && t_value !== (t_value = localize$1(`statusEffects.${/*tag*/
      ctx2[10]}.name`) + ""))
        set_data(t, t_value);
      if (dirty & /*availableUnselectedTags*/
      8 && option_value_value !== (option_value_value = /*tag*/
      ctx2[10])) {
        option.__value = option_value_value;
        set_input_value(option, option.__value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
__name(create_each_block_1$2, "create_each_block_1$2");
function create_each_block$d(ctx) {
  let div;
  let tag_1;
  let current;
  tag_1 = new Tag({
    props: {
      tag: (
        /*tag*/
        ctx[10]
      ),
      path: (
        /*tagsPath*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      div = element("div");
      create_component(tag_1.$$.fragment);
      attr(div, "class", "flex0");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(tag_1, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const tag_1_changes = {};
      if (dirty & /*currentTags*/
      2)
        tag_1_changes.tag = /*tag*/
        ctx2[10];
      if (dirty & /*tagsPath*/
      1)
        tag_1_changes.path = /*tagsPath*/
        ctx2[0];
      tag_1.$set(tag_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tag_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tag_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(tag_1);
    }
  };
}
__name(create_each_block$d, "create_each_block$d");
function create_fragment$W(ctx) {
  let div0;
  let select;
  let option;
  let div1;
  let current;
  let mounted;
  let dispose;
  let each_value_1 = ensure_array_like(
    /*availableUnselectedTags*/
    ctx[3]
  );
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks_1[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
  }
  let each_value = ensure_array_like(
    /*currentTags*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$d(get_each_context$d(ctx, each_value, i));
  }
  const out = /* @__PURE__ */ __name((i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  }), "out");
  return {
    c() {
      div0 = element("div");
      select = element("select");
      option = element("option");
      option.textContent = `${localize$1("EFFECT.Label.SelectTag")}`;
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      div1 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      option.__value = "";
      set_input_value(option, option.__value);
      attr(select, "class", "tag-select svelte-sprb3l");
      if (
        /*selectedTag*/
        ctx[2] === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[8].call(select)
        ));
      attr(div0, "class", "flexcol");
      attr(div1, "class", "flexrow gap-4 mt-sm wrap justify-vertical svelte-sprb3l");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, select);
      append(select, option);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(select, null);
        }
      }
      select_option(
        select,
        /*selectedTag*/
        ctx[2],
        true
      );
      insert(target, div1, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div1, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[8]
          ),
          listen(
            select,
            "change",
            /*addTag*/
            ctx[5]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*availableUnselectedTags*/
      8) {
        each_value_1 = ensure_array_like(
          /*availableUnselectedTags*/
          ctx2[3]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1$2(ctx2, each_value_1, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_1$2(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(select, null);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_1.length;
      }
      if (dirty & /*selectedTag, availableUnselectedTags*/
      12) {
        select_option(
          select,
          /*selectedTag*/
          ctx2[2]
        );
      }
      if (dirty & /*currentTags, tagsPath*/
      3) {
        each_value = ensure_array_like(
          /*currentTags*/
          ctx2[1]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$d(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$d(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div1, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(div1);
      }
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_fragment$W, "create_fragment$W");
function instance$P($$self, $$props, $$invalidate) {
  let currentTags;
  let availableUnselectedTags;
  let $doc;
  const doc = getContext("#doc");
  component_subscribe($$self, doc, (value) => $$invalidate(7, $doc = value));
  let { availableTags = [] } = $$props;
  let { tagsPath = "system.tags" } = $$props;
  let selectedTag = "";
  async function addTag() {
    if (!selectedTag)
      return;
    const tags = new Set(currentTags);
    if (tags.has(selectedTag)) {
      ui.notifications.error(localize$1("Errors.DuplicateTag"));
      $$invalidate(2, selectedTag = "");
      return;
    }
    tags.add(selectedTag);
    const newTags = Array.from(tags);
    if (tagsPath.startsWith("flags")) {
      await $doc.setFlag(SYSTEM_ID, tagsPath, newTags);
    } else {
      await $doc.update({ [tagsPath]: newTags });
    }
    $$invalidate(2, selectedTag = "");
  }
  __name(addTag, "addTag");
  onMount(() => {
    if (!currentTags.length) {
      if (tagsPath.startsWith("flags")) {
        $doc.setFlag(SYSTEM_ID, tagsPath, []);
      } else {
        $doc.update({ [tagsPath]: [] });
      }
    }
  });
  function select_change_handler() {
    selectedTag = select_value(this);
    $$invalidate(2, selectedTag);
    $$invalidate(3, availableUnselectedTags), $$invalidate(6, availableTags), $$invalidate(1, currentTags), $$invalidate(0, tagsPath), $$invalidate(7, $doc);
  }
  __name(select_change_handler, "select_change_handler");
  $$self.$$set = ($$props2) => {
    if ("availableTags" in $$props2)
      $$invalidate(6, availableTags = $$props2.availableTags);
    if ("tagsPath" in $$props2)
      $$invalidate(0, tagsPath = $$props2.tagsPath);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*tagsPath, $doc*/
    129) {
      $$invalidate(1, currentTags = (() => {
        const tags = tagsPath.startsWith("flags") ? $doc.getFlag(SYSTEM_ID, tagsPath) || [] : getPropertyCompat($doc, tagsPath) || [];
        return Array.isArray(tags) ? tags : Array.from(tags);
      })());
    }
    if ($$self.$$.dirty & /*availableTags, currentTags*/
    66) {
      $$invalidate(3, availableUnselectedTags = availableTags.filter((tag) => !currentTags.includes(tag)));
    }
  };
  return [
    tagsPath,
    currentTags,
    selectedTag,
    availableUnselectedTags,
    doc,
    addTag,
    availableTags,
    $doc,
    select_change_handler
  ];
}
__name(instance$P, "instance$P");
class TagSelect extends SvelteComponent {
  static {
    __name(this, "TagSelect");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$P, create_fragment$W, safe_not_equal, { availableTags: 6, tagsPath: 0 });
  }
}
function create_fragment$V(ctx) {
  let div37;
  let div36;
  let div5;
  let div1;
  let div0;
  let h1;
  let div4;
  let div2;
  let label0;
  let div3;
  let docinput;
  let div30;
  let div8;
  let div6;
  let label1;
  let div7;
  let doccheckbox0;
  let div10;
  let div9;
  let p0;
  let div13;
  let div11;
  let label2;
  let div12;
  let doccheckbox1;
  let div15;
  let div14;
  let p1;
  let div18;
  let div16;
  let label3;
  let div17;
  let docselect;
  let div20;
  let div19;
  let p2;
  let div23;
  let div21;
  let label4;
  let div22;
  let doccheckbox2;
  let div25;
  let div24;
  let p3;
  let div27;
  let div26;
  let label5;
  let div29;
  let div28;
  let tagselect;
  let div35;
  let div32;
  let div31;
  let label6;
  let div34;
  let div33;
  let prosemirror;
  let current;
  docinput = new DocInput({
    props: {
      name: "name",
      valuePath: "name",
      fullWidth: true,
      placeholder: "Effect Name",
      alwaysEditable: true,
      updateOnBlur: true
    }
  });
  doccheckbox0 = new DocCheckbox({
    props: { name: "transfer", valuePath: "transfer" }
  });
  doccheckbox1 = new DocCheckbox({
    props: {
      name: "overlay",
      valuePath: `flags.${SYSTEM_ID}.overlay`
    }
  });
  docselect = new DocSelect({
    props: {
      class: "wide right",
      id: "stackable",
      name: "stackable",
      options: (
        /*stackingOptions*/
        ctx[2]
      ),
      valuePath: `flags.${SYSTEM_ID}.stackable`,
      defaultValue: "differentSource"
    }
  });
  doccheckbox2 = new DocCheckbox({
    props: { name: "suspended", valuePath: `disabled` }
  });
  tagselect = new TagSelect({
    props: {
      availableTags: (
        /*statusOptions*/
        ctx[0]
      ),
      tagsPath: "statuses"
    }
  });
  prosemirror = new ProseMirror$1({
    props: {
      id: "description",
      name: "description",
      attr: "description"
    }
  });
  return {
    c() {
      div37 = element("div");
      div36 = element("div");
      div5 = element("div");
      div1 = element("div");
      div0 = element("div");
      h1 = element("h1");
      h1.textContent = `${localize$1("Config")}`;
      div4 = element("div");
      div2 = element("div");
      label0 = element("label");
      label0.textContent = `${localize$1("Name")}`;
      div3 = element("div");
      create_component(docinput.$$.fragment);
      div30 = element("div");
      div8 = element("div");
      div6 = element("div");
      label1 = element("label");
      label1.textContent = `${localize$1("EFFECT.TransferEffectToActor.Label")}`;
      div7 = element("div");
      create_component(doccheckbox0.$$.fragment);
      div10 = element("div");
      div9 = element("div");
      p0 = element("p");
      p0.textContent = `${localize$1("EFFECT.TransferEffectToActor.Caption")}`;
      div13 = element("div");
      div11 = element("div");
      label2 = element("label");
      label2.textContent = `${localize$1("EFFECT.Overlay.Label")}`;
      div12 = element("div");
      create_component(doccheckbox1.$$.fragment);
      div15 = element("div");
      div14 = element("div");
      p1 = element("p");
      p1.textContent = `${localize$1("EFFECT.Overlay.Caption")}`;
      div18 = element("div");
      div16 = element("div");
      label3 = element("label");
      label3.textContent = `${localize$1("EFFECT.Stackable.Label")}`;
      div17 = element("div");
      create_component(docselect.$$.fragment);
      div20 = element("div");
      div19 = element("div");
      p2 = element("p");
      p2.textContent = `${localize$1("EFFECT.Stackable.Caption")}`;
      div23 = element("div");
      div21 = element("div");
      label4 = element("label");
      label4.textContent = `${localize$1("EFFECT.Suspended.Label")}`;
      div22 = element("div");
      create_component(doccheckbox2.$$.fragment);
      div25 = element("div");
      div24 = element("div");
      p3 = element("p");
      p3.textContent = `${localize$1("EFFECT.Suspended.Caption")}`;
      div27 = element("div");
      div26 = element("div");
      label5 = element("label");
      label5.textContent = `${localize$1("EFFECT.Label.Statuses")}`;
      div29 = element("div");
      div28 = element("div");
      create_component(tagselect.$$.fragment);
      div35 = element("div");
      div32 = element("div");
      div31 = element("div");
      label6 = element("label");
      label6.textContent = `${localize$1("EFFECT.Description.Label")}`;
      div34 = element("div");
      div33 = element("div");
      create_component(prosemirror.$$.fragment);
      attr(h1, "class", "center");
      attr(div0, "class", "flex4");
      attr(div1, "class", "flexrow justify-vertical");
      attr(label0, "class", "gold svelte-16c3i1w");
      attr(label0, "for", "name");
      attr(div2, "class", "flex1");
      attr(div3, "class", "flex4 right");
      attr(div4, "class", "flexrow justify-vertical");
      attr(div5, "class", "flex0");
      attr(label1, "class", "gold svelte-16c3i1w");
      attr(label1, "for", "transfer");
      attr(div6, "class", "flex4");
      attr(div7, "class", "flex0 right");
      attr(div8, "class", "flexrow justify-vertical");
      attr(p0, "class", "caption");
      attr(div9, "class", "flex4");
      attr(div10, "class", "flexrow justify-vertical");
      attr(label2, "class", "gold svelte-16c3i1w");
      attr(label2, "for", "overlay");
      attr(div11, "class", "flex4");
      attr(div12, "class", "flex0 right");
      attr(div13, "class", "flexrow justify-vertical");
      attr(p1, "class", "caption");
      attr(div14, "class", "flex4");
      attr(div15, "class", "flexrow justify-vertical");
      attr(label3, "class", "gold svelte-16c3i1w");
      attr(label3, "for", "stackable");
      attr(div16, "class", "flex4");
      attr(div17, "class", "flex4 right");
      attr(div18, "class", "flexrow justify-vertical");
      attr(p2, "class", "caption");
      attr(div19, "class", "flex4");
      attr(div20, "class", "flexrow justify-vertical");
      attr(label4, "class", "gold svelte-16c3i1w");
      attr(label4, "for", "suspended");
      attr(div21, "class", "flex4");
      attr(div22, "class", "flex0 right");
      attr(div23, "class", "flexrow justify-vertical");
      attr(p3, "class", "caption");
      attr(div24, "class", "flex4");
      attr(div25, "class", "flexrow justify-vertical");
      attr(label5, "class", "gold svelte-16c3i1w");
      attr(label5, "for", "statuses");
      attr(div26, "class", "flex4");
      attr(div27, "class", "flexrow justify-vertical");
      attr(div28, "class", "flex2 left");
      attr(div29, "class", "flexcol sheet-row justify-vertical");
      attr(div30, "class", "flex0 mt-sm");
      attr(label6, "class", "gold svelte-16c3i1w");
      attr(label6, "for", "description");
      attr(div31, "class", "flex4");
      attr(div32, "class", "flexrow justify-vertical");
      attr(div33, "class", "flex2 left prose high short");
      attr(div34, "class", "flexcol sheet-row justify-vertical high");
      attr(div35, "class", "flex1 mb-xl");
      attr(div36, "class", "flexcol flex3 left high wide mb-md");
      attr(div37, "class", "item-sheet details overflow wide inset mt-sm high svelte-16c3i1w");
    },
    m(target, anchor) {
      insert(target, div37, anchor);
      append(div37, div36);
      append(div36, div5);
      append(div5, div1);
      append(div1, div0);
      append(div0, h1);
      append(div5, div4);
      append(div4, div2);
      append(div2, label0);
      append(div4, div3);
      mount_component(docinput, div3, null);
      append(div36, div30);
      append(div30, div8);
      append(div8, div6);
      append(div6, label1);
      append(div8, div7);
      mount_component(doccheckbox0, div7, null);
      append(div30, div10);
      append(div10, div9);
      append(div9, p0);
      append(div30, div13);
      append(div13, div11);
      append(div11, label2);
      append(div13, div12);
      mount_component(doccheckbox1, div12, null);
      append(div30, div15);
      append(div15, div14);
      append(div14, p1);
      append(div30, div18);
      append(div18, div16);
      append(div16, label3);
      append(div18, div17);
      mount_component(docselect, div17, null);
      append(div30, div20);
      append(div20, div19);
      append(div19, p2);
      append(div30, div23);
      append(div23, div21);
      append(div21, label4);
      append(div23, div22);
      mount_component(doccheckbox2, div22, null);
      append(div30, div25);
      append(div25, div24);
      append(div24, p3);
      append(div30, div27);
      append(div27, div26);
      append(div26, label5);
      append(div30, div29);
      append(div29, div28);
      mount_component(tagselect, div28, null);
      append(div36, div35);
      append(div35, div32);
      append(div32, div31);
      append(div31, label6);
      append(div35, div34);
      append(div34, div33);
      mount_component(prosemirror, div33, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const tagselect_changes = {};
      if (dirty & /*statusOptions*/
      1)
        tagselect_changes.availableTags = /*statusOptions*/
        ctx2[0];
      tagselect.$set(tagselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(docinput.$$.fragment, local);
      transition_in(doccheckbox0.$$.fragment, local);
      transition_in(doccheckbox1.$$.fragment, local);
      transition_in(docselect.$$.fragment, local);
      transition_in(doccheckbox2.$$.fragment, local);
      transition_in(tagselect.$$.fragment, local);
      transition_in(prosemirror.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(docinput.$$.fragment, local);
      transition_out(doccheckbox0.$$.fragment, local);
      transition_out(doccheckbox1.$$.fragment, local);
      transition_out(docselect.$$.fragment, local);
      transition_out(doccheckbox2.$$.fragment, local);
      transition_out(tagselect.$$.fragment, local);
      transition_out(prosemirror.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div37);
      }
      destroy_component(docinput);
      destroy_component(doccheckbox0);
      destroy_component(doccheckbox1);
      destroy_component(docselect);
      destroy_component(doccheckbox2);
      destroy_component(tagselect);
      destroy_component(prosemirror);
    }
  };
}
__name(create_fragment$V, "create_fragment$V");
function instance$O($$self, $$props, $$invalidate) {
  let statusOptions;
  let $doc;
  const doc = getContext("#doc");
  component_subscribe($$self, doc, (value) => $$invalidate(3, $doc = value));
  const stackingOptions = [
    {
      value: "differentSource",
      label: localize$1("EFFECT.Stackable.Options.differentSource")
    },
    {
      value: "anySource",
      label: localize$1("EFFECT.Stackable.Options.anySource")
    },
    {
      value: "replaces",
      label: localize$1("EFFECT.Stackable.Options.replaces")
    }
  ];
  onMount(async () => {
    console.log("ActiveEffectSheet Config", $doc);
  });
  $$invalidate(0, statusOptions = getDefaultStatusEffects().map((status) => status.id));
  return [statusOptions, doc, stackingOptions];
}
__name(instance$O, "instance$O");
class Config extends SvelteComponent {
  static {
    __name(this, "Config");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$O, create_fragment$V, safe_not_equal, {});
  }
}
function create_fragment$U(ctx) {
  let div19;
  let div18;
  let h3;
  let div2;
  let div0;
  let label0;
  let div1;
  let docselect;
  let div5;
  let div3;
  let label1;
  let div4;
  let docinput0;
  let div8;
  let div6;
  let label2;
  let div7;
  let docinput1;
  let div11;
  let div9;
  let label3;
  let div10;
  let docinput2;
  let div14;
  let div12;
  let label4;
  let div13;
  let docinput3;
  let div17;
  let div15;
  let label5;
  let div16;
  let docinput4;
  let current;
  docselect = new DocSelect({
    props: {
      class: "right",
      id: "durationType",
      options: (
        /*durationTypeOptions*/
        ctx[0]
      ),
      valuePath: "duration.type"
    }
  });
  docinput0 = new DocInput({
    props: {
      class: "wide",
      id: "startTime",
      valuePath: "duration.startTime"
    }
  });
  docinput1 = new DocInput({
    props: {
      class: "wide",
      id: "turns",
      valuePath: "duration.turns"
    }
  });
  docinput2 = new DocInput({
    props: {
      class: "wide",
      id: "rounds",
      valuePath: "duration.rounds"
    }
  });
  docinput3 = new DocInput({
    props: {
      class: "wide",
      id: "startRound",
      valuePath: "duration.startRound"
    }
  });
  docinput4 = new DocInput({
    props: {
      class: "wide",
      id: "startTurn",
      valuePath: "duration.startTurn"
    }
  });
  return {
    c() {
      div19 = element("div");
      div18 = element("div");
      h3 = element("h3");
      h3.textContent = `${localize$1("EFFECT.Duration.Title")}`;
      div2 = element("div");
      div0 = element("div");
      label0 = element("label");
      label0.textContent = `${localize$1("EFFECT.Duration.Type")}`;
      div1 = element("div");
      create_component(docselect.$$.fragment);
      div5 = element("div");
      div3 = element("div");
      label1 = element("label");
      label1.textContent = `${localize$1("EFFECT.Duration.StartTime")}`;
      div4 = element("div");
      create_component(docinput0.$$.fragment);
      div8 = element("div");
      div6 = element("div");
      label2 = element("label");
      label2.textContent = `${localize$1("EFFECT.Duration.Turns")}`;
      div7 = element("div");
      create_component(docinput1.$$.fragment);
      div11 = element("div");
      div9 = element("div");
      label3 = element("label");
      label3.textContent = `${localize$1("EFFECT.Duration.Rounds")}`;
      div10 = element("div");
      create_component(docinput2.$$.fragment);
      div14 = element("div");
      div12 = element("div");
      label4 = element("label");
      label4.textContent = `${localize$1("EFFECT.Duration.StartRound")}`;
      div13 = element("div");
      create_component(docinput3.$$.fragment);
      div17 = element("div");
      div15 = element("div");
      label5 = element("label");
      label5.textContent = `${localize$1("EFFECT.Duration.StartTurn")}`;
      div16 = element("div");
      create_component(docinput4.$$.fragment);
      attr(h3, "class", "left");
      attr(label0, "for", "durationType");
      attr(label0, "class", "svelte-qerul5");
      attr(div0, "class", "flex1");
      attr(div1, "class", "flex4 right wide");
      attr(div2, "class", "flexrow sheet-row justify-vertical wide");
      attr(label1, "for", "startTime");
      attr(label1, "class", "svelte-qerul5");
      attr(div3, "class", "flex1");
      attr(div4, "class", "flex4 right wide");
      attr(div5, "class", "flexrow sheet-row justify-vertical wide");
      attr(label2, "for", "turns");
      attr(label2, "class", "svelte-qerul5");
      attr(div6, "class", "flex1");
      attr(div7, "class", "flex4 right wide");
      attr(div8, "class", "flexrow sheet-row justify-vertical wide");
      attr(label3, "for", "rounds");
      attr(label3, "class", "svelte-qerul5");
      attr(div9, "class", "flex1");
      attr(div10, "class", "flex4 right wide");
      attr(div11, "class", "flexrow sheet-row justify-vertical wide");
      attr(label4, "for", "startRound");
      attr(label4, "class", "svelte-qerul5");
      attr(div12, "class", "flex1");
      attr(div13, "class", "flex4 right wide");
      attr(div14, "class", "flexrow sheet-row justify-vertical wide");
      attr(label5, "for", "startTurn");
      attr(label5, "class", "svelte-qerul5");
      attr(div15, "class", "flex1");
      attr(div16, "class", "flex4 right wide");
      attr(div17, "class", "flexrow sheet-row justify-vertical wide");
      attr(div18, "class", "flexcol flex3 left high wide");
      attr(div19, "class", "item-sheet details overflow svelte-qerul5");
    },
    m(target, anchor) {
      insert(target, div19, anchor);
      append(div19, div18);
      append(div18, h3);
      append(div18, div2);
      append(div2, div0);
      append(div0, label0);
      append(div2, div1);
      mount_component(docselect, div1, null);
      append(div18, div5);
      append(div5, div3);
      append(div3, label1);
      append(div5, div4);
      mount_component(docinput0, div4, null);
      append(div18, div8);
      append(div8, div6);
      append(div6, label2);
      append(div8, div7);
      mount_component(docinput1, div7, null);
      append(div18, div11);
      append(div11, div9);
      append(div9, label3);
      append(div11, div10);
      mount_component(docinput2, div10, null);
      append(div18, div14);
      append(div14, div12);
      append(div12, label4);
      append(div14, div13);
      mount_component(docinput3, div13, null);
      append(div18, div17);
      append(div17, div15);
      append(div15, label5);
      append(div17, div16);
      mount_component(docinput4, div16, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const docselect_changes = {};
      if (dirty & /*durationTypeOptions*/
      1)
        docselect_changes.options = /*durationTypeOptions*/
        ctx2[0];
      docselect.$set(docselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(docselect.$$.fragment, local);
      transition_in(docinput0.$$.fragment, local);
      transition_in(docinput1.$$.fragment, local);
      transition_in(docinput2.$$.fragment, local);
      transition_in(docinput3.$$.fragment, local);
      transition_in(docinput4.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(docselect.$$.fragment, local);
      transition_out(docinput0.$$.fragment, local);
      transition_out(docinput1.$$.fragment, local);
      transition_out(docinput2.$$.fragment, local);
      transition_out(docinput3.$$.fragment, local);
      transition_out(docinput4.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div19);
      }
      destroy_component(docselect);
      destroy_component(docinput0);
      destroy_component(docinput1);
      destroy_component(docinput2);
      destroy_component(docinput3);
      destroy_component(docinput4);
    }
  };
}
__name(create_fragment$U, "create_fragment$U");
function instance$N($$self, $$props, $$invalidate) {
  let durationTypeOptions;
  let $doc;
  const doc = getContext("#doc");
  component_subscribe($$self, doc, (value) => $$invalidate(2, $doc = value));
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$doc*/
    4) {
      $doc.duration || {};
    }
  };
  $$invalidate(0, durationTypeOptions = getDurationTypeOptions());
  return [durationTypeOptions, doc, $doc];
}
__name(instance$N, "instance$N");
let Duration$1 = class Duration extends SvelteComponent {
  static {
    __name(this, "Duration");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$N, create_fragment$U, safe_not_equal, {});
  }
};
function create_default_slot_1$2(ctx) {
  let tabs_1;
  let updating_activeTab;
  let current;
  function tabs_1_activeTab_binding(value) {
    ctx[4](value);
  }
  __name(tabs_1_activeTab_binding, "tabs_1_activeTab_binding");
  let tabs_1_props = {
    class: "tabs small wide",
    tabs: (
      /*tabs*/
      ctx[2]
    )
  };
  if (
    /*activeTab*/
    ctx[1] !== void 0
  ) {
    tabs_1_props.activeTab = /*activeTab*/
    ctx[1];
  }
  tabs_1 = new Tabs({ props: tabs_1_props });
  binding_callbacks.push(() => bind(tabs_1, "activeTab", tabs_1_activeTab_binding));
  return {
    c() {
      create_component(tabs_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tabs_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tabs_1_changes = {};
      if (!updating_activeTab && dirty & /*activeTab*/
      2) {
        updating_activeTab = true;
        tabs_1_changes.activeTab = /*activeTab*/
        ctx2[1];
        add_flush_callback(() => updating_activeTab = false);
      }
      tabs_1.$set(tabs_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tabs_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tabs_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tabs_1, detaching);
    }
  };
}
__name(create_default_slot_1$2, "create_default_slot_1$2");
function create_default_slot$f(ctx) {
  let div2;
  let div1;
  let section;
  let div0;
  let portraitframe;
  let current;
  portraitframe = new PortraitFrame({
    props: {
      class: "high frame wide",
      $$slots: { default: [create_default_slot_1$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      section = element("section");
      div0 = element("div");
      create_component(portraitframe.$$.fragment);
      attr(div0, "class", "flex1 portrait-frame svelte-maqqt9");
      attr(section, "class", "mt-sm high");
      attr(div1, "class", "flex4 wide mr-sm high");
      attr(div2, "class", "flexrow gap-15 wide high no-overflow nowrap");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, section);
      append(section, div0);
      mount_component(portraitframe, div0, null);
      current = true;
    },
    p(ctx2, dirty) {
      const portraitframe_changes = {};
      if (dirty & /*$$scope, activeTab*/
      130) {
        portraitframe_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portraitframe.$set(portraitframe_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(portraitframe.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(portraitframe.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(portraitframe);
    }
  };
}
__name(create_default_slot$f, "create_default_slot$f");
function create_fragment$T(ctx) {
  let applicationshell;
  let updating_elementRoot;
  let current;
  function applicationshell_elementRoot_binding(value) {
    ctx[5](value);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  let applicationshell_props = {
    $$slots: { default: [create_default_slot$f] },
    $$scope: { ctx }
  };
  if (
    /*elementRoot*/
    ctx[0] !== void 0
  ) {
    applicationshell_props.elementRoot = /*elementRoot*/
    ctx[0];
  }
  applicationshell = new ApplicationShell({ props: applicationshell_props });
  binding_callbacks.push(() => bind(applicationshell, "elementRoot", applicationshell_elementRoot_binding));
  return {
    c() {
      create_component(applicationshell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(applicationshell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const applicationshell_changes = {};
      if (dirty & /*$$scope, activeTab*/
      130) {
        applicationshell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_elementRoot && dirty & /*elementRoot*/
      1) {
        updating_elementRoot = true;
        applicationshell_changes.elementRoot = /*elementRoot*/
        ctx2[0];
        add_flush_callback(() => updating_elementRoot = false);
      }
      applicationshell.$set(applicationshell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applicationshell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applicationshell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applicationshell, detaching);
    }
  };
}
__name(create_fragment$T, "create_fragment$T");
function instance$M($$self, $$props, $$invalidate) {
  let { elementRoot = void 0 } = $$props;
  let { doc } = $$props;
  getContext("#external").application;
  setContext("#doc", doc);
  let activeTab2 = "config";
  const tabs = [
    {
      label: localize$1("EFFECT.Config"),
      id: "config",
      component: Config,
      img: "/systems/foundryvtt-final-fantasy/assets/icons/tabs/cog.webp"
    },
    {
      label: localize$1("Duration.Title"),
      id: "duration",
      component: Duration$1,
      img: "/systems/foundryvtt-final-fantasy/assets/icons/tabs/duration.webp"
    },
    {
      label: localize$1("EFFECT.Changes"),
      id: "changes",
      component: Changes,
      img: "/systems/foundryvtt-final-fantasy/assets/icons/tabs/list.webp"
    }
  ];
  onMount(() => {
  });
  function tabs_1_activeTab_binding(value) {
    activeTab2 = value;
    $$invalidate(1, activeTab2);
  }
  __name(tabs_1_activeTab_binding, "tabs_1_activeTab_binding");
  function applicationshell_elementRoot_binding(value) {
    elementRoot = value;
    $$invalidate(0, elementRoot);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  $$self.$$set = ($$props2) => {
    if ("elementRoot" in $$props2)
      $$invalidate(0, elementRoot = $$props2.elementRoot);
    if ("doc" in $$props2)
      $$invalidate(3, doc = $$props2.doc);
  };
  return [
    elementRoot,
    activeTab2,
    tabs,
    doc,
    tabs_1_activeTab_binding,
    applicationshell_elementRoot_binding
  ];
}
__name(instance$M, "instance$M");
class FFActiveEffectShell extends SvelteComponent {
  static {
    __name(this, "FFActiveEffectShell");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$M, create_fragment$T, safe_not_equal, { elementRoot: 0, doc: 3 });
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(elementRoot) {
    this.$$set({ elementRoot });
    flush();
  }
  get doc() {
    return this.$$.ctx[3];
  }
  set doc(doc) {
    this.$$set({ doc });
    flush();
  }
}
class FFActiveEffectSheet extends SvelteApplication {
  static {
    __name(this, "FFActiveEffectSheet");
  }
  #doc = new TJSDocument(void 0, { delete: this.close.bind(this) });
  #storeUnsubscribe;
  /**
   * Initializes the sheet with default options
   * @param {object} object - The object to initialize with
   */
  constructor(object) {
    super(object);
    Object.defineProperty(this.reactive, "document", {
      get: () => this.#doc.get(),
      set: (document2) => {
        this.#doc.set(document2);
      }
    });
    this.reactive.document = object;
    game.system.log.d("isEditing", this.reactive.document.system.isEditing);
  }
  /**
   * Default Application options
   * @return {object} options - Application options.
   * @see https://foundryvtt.com/api/Application.html#options
   */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      id: `${SYSTEM_ID}--active-effect-sheet-${generateRandomElementId()}`,
      width: 594,
      height: 428,
      minHeight: 180,
      minWidth: 282,
      resizable: true,
      minimizable: true,
      classes: [SYSTEM_CODE, "sheet", "active-effect-config"],
      svelte: {
        class: FFActiveEffectShell,
        target: document.body,
        props: {
          doc: null
        }
      }
    });
  }
  /**
   * Gets the document associated with this sheet
   * @return {TJSDocument} Returns the document instance associated with this sheet
   */
  get document() {
    return this.#doc;
  }
  /**
   * Injects HTML content into the application
   * @param {HTMLElement} html - The HTML content to inject
   * @return {Promise<void>} Returns a promise that resolves when the HTML has been injected
   */
  async _injectHTML(html) {
    this.options.svelte.props.doc = this.document;
    return super._injectHTML(html);
  }
  /**
   * Renders the application
   * @param {boolean} force - Whether to force a re-render
   * @param {object} options - Additional rendering options
   * @return {Promise<void>} Returns a promise that resolves when the application has been rendered
   */
  render(force = false, options = {}) {
    if (!this.#storeUnsubscribe) {
      this.#storeUnsubscribe = this.#doc.subscribe(this.#handleDocUpdate.bind(this));
    }
    return super.render(force, options);
  }
  /**
   * Closes the application and performs cleanup
   * @param {object} [options={}] - Options which configure the closing behavior
   * @return {Promise<void>} Returns a promise that resolves when the application has closed
   */
  async close(options = {}) {
    if (this.#storeUnsubscribe) {
      this.#storeUnsubscribe();
      this.#storeUnsubscribe = void 0;
    }
    return super.close(options);
  }
  /**
   * Handles document updates
   * @param {object} doc - The updated document
   * @private
   * @return {void}
   */
  #handleDocUpdate(doc) {
    if (doc) {
      this.reactive.title = `${game.i18n.localize("FFXIV.EFFECT.ConfigTitle")}: ${doc.name || ""}`;
    }
  }
}
function createFilterQuery(properties, { caseSensitive = false, store } = {}) {
  let keyword = "";
  let regex;
  if (store !== void 0 && !isWritableStore(store)) {
    throw new TypeError(`createFilterQuery error: 'store' is not a writable store.`);
  }
  const storeKeyword = store ? store : writable(keyword);
  if (store) {
    const current = get_store_value(store);
    if (typeof current === "string") {
      keyword = Strings.normalize(current);
      game.system.log.d("keyword", keyword);
      regex = new RegExp(RegExp.escape(keyword), caseSensitive ? "" : "i");
      game.system.log.d("keyword", regex);
    } else {
      store.set(keyword);
    }
  }
  function filterQuery(data) {
    if (keyword === "" || !regex) {
      game.system.log.d("No keyword or regex, returning true");
      return true;
    }
    if (isIterable(properties)) {
      for (const property of properties) {
        const value = data?.[property];
        if (value !== void 0) {
          if (typeof value === "boolean") {
            if (value.toString() === keyword) {
              return true;
            }
          } else {
            const normalizedValue = Strings.normalize(value);
            if (regex.test(normalizedValue)) {
              return true;
            }
          }
        }
      }
      return false;
    } else {
      const steps = stepwiseResolveDotpath(data, properties);
      const value = steps[steps.length - 1].val;
      if (value !== void 0) {
        if (typeof value === "boolean") {
          return value.toString() === keyword;
        }
        const normalizedValue = Strings.normalize(value);
        return regex.test(normalizedValue);
      }
      return false;
    }
  }
  __name(filterQuery, "filterQuery");
  filterQuery.subscribe = (handler) => {
    return storeKeyword.subscribe(handler);
  };
  filterQuery.set = (value) => {
    game.system.log.d("value", value);
    if (Array.isArray(value)) {
      const pattern = value.map((v) => RegExp.escape(Strings.normalize(v))).join("|");
      keyword = value.join(", ");
      regex = new RegExp(pattern, caseSensitive ? "" : "i");
    } else if (typeof value === "string") {
      keyword = Strings.normalize(value);
      game.system.log.d("keyword", keyword);
      regex = new RegExp(RegExp.escape(keyword), caseSensitive ? "" : "i");
    } else if (typeof value === "boolean") {
      keyword = value.toString();
      regex = new RegExp(keyword, caseSensitive ? "" : "i");
    }
    storeKeyword.set(keyword);
  };
  return filterQuery;
}
__name(createFilterQuery, "createFilterQuery");
function create_fragment$S(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", div_class_value = "badge " + /*badgeClasses*/
      ctx[0] + " svelte-qkzukj");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*badgeClasses*/
      1 && div_class_value !== (div_class_value = "badge " + /*badgeClasses*/
      ctx2[0] + " svelte-qkzukj")) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
__name(create_fragment$S, "create_fragment$S");
function instance$L($$self, $$props, $$invalidate) {
  let badgeClasses;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { type = "" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("type" in $$props2)
      $$invalidate(1, type = $$props2.type);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*type*/
    2) {
      $$invalidate(0, badgeClasses = type ? `badge-${type}` : "");
    }
  };
  return [badgeClasses, type, $$scope, slots];
}
__name(instance$L, "instance$L");
class Badge extends SvelteComponent {
  static {
    __name(this, "Badge");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$L, create_fragment$S, safe_not_equal, { type: 1 });
  }
}
function get_each_context$c(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i];
  child_ctx[23] = i;
  return child_ctx;
}
__name(get_each_context$c, "get_each_context$c");
function get_each_context_1$1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[24] = list[i];
  return child_ctx;
}
__name(get_each_context_1$1, "get_each_context_1$1");
function create_if_block_4$3(ctx) {
  let h1;
  let table;
  let tr;
  let th0;
  let img;
  let img_src_value;
  let img_alt_value;
  let th1;
  let t1_value = ucfirst(
    /*$Actor*/
    ctx[0].system.job?.name
  ) + "";
  let t1;
  let th2;
  let t2_value = (
    /*$Actor*/
    ctx[0].system.job?.level + ""
  );
  let t2;
  let th3;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      h1 = element("h1");
      h1.textContent = `${localize$1("Job")}`;
      table = element("table");
      tr = element("tr");
      th0 = element("th");
      img = element("img");
      th1 = element("th");
      t1 = text(t1_value);
      th2 = element("th");
      t2 = text(t2_value);
      th3 = element("th");
      button = element("button");
      button.innerHTML = `<i class="fa-solid fa-trash"></i>`;
      attr(h1, "class", "left gold");
      attr(img, "class", "icon svelte-1tqlt0i");
      if (!src_url_equal(img.src, img_src_value = /*$Actor*/
      ctx[0].system.job?.img))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*$Actor*/
      ctx[0].system.job?.img);
      attr(th0, "class", "img shrink");
      attr(th0, "scope", "col");
      attr(th1, "class", "left expand gold larger");
      attr(th1, "scope", "col");
      attr(th1, "role", "button");
      attr(th2, "class", "expand scaleup kerned glow gold largerer");
      attr(th2, "scope", "col");
      attr(button, "class", "stealth");
      attr(th3, "class", "buttons");
      attr(th3, "scope", "col");
      attr(table, "class", "borderless");
    },
    m(target, anchor) {
      insert(target, h1, anchor);
      insert(target, table, anchor);
      append(table, tr);
      append(tr, th0);
      append(th0, img);
      append(tr, th1);
      append(th1, t1);
      append(tr, th2);
      append(th2, t2);
      append(tr, th3);
      append(th3, button);
      if (!mounted) {
        dispose = [
          listen(th1, "click", function() {
            if (is_function(showItemSheet$4(
              /*$Actor*/
              ctx[0].system.job
            )))
              showItemSheet$4(
                /*$Actor*/
                ctx[0].system.job
              ).apply(this, arguments);
          }),
          listen(
            button,
            "click",
            /*deleteJob*/
            ctx[15]
          )
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$Actor*/
      1 && !src_url_equal(img.src, img_src_value = /*$Actor*/
      ctx[0].system.job?.img)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*$Actor*/
      1 && img_alt_value !== (img_alt_value = /*$Actor*/
      ctx[0].system.job?.img)) {
        attr(img, "alt", img_alt_value);
      }
      if (dirty & /*$Actor*/
      1 && t1_value !== (t1_value = ucfirst(
        /*$Actor*/
        ctx[0].system.job?.name
      ) + ""))
        set_data(t1, t1_value);
      if (dirty & /*$Actor*/
      1 && t2_value !== (t2_value = /*$Actor*/
      ctx[0].system.job?.level + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching) {
        detach(h1);
        detach(table);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_if_block_4$3, "create_if_block_4$3");
function create_if_block_3$6(ctx) {
  let div;
  let badge;
  let current;
  badge = new Badge({
    props: {
      type: (
        /*badgeType*/
        ctx[16](
          /*item*/
          ctx[21]
        )
      ),
      $$slots: { default: [create_default_slot$e] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(badge.$$.fragment);
      attr(div, "class", "flex0 right ml-sm pt-s svelte-1tqlt0i");
      attr(div, "data-tooltip-class", "FFXIV-tooltip");
      attr(div, "data-tooltip", localize$1("Types.Item.Types.action.UsesRemaining"));
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(badge, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const badge_changes = {};
      if (dirty & /*items*/
      32)
        badge_changes.type = /*badgeType*/
        ctx2[16](
          /*item*/
          ctx2[21]
        );
      if (dirty & /*$$scope, items*/
      134217760) {
        badge_changes.$$scope = { dirty, ctx: ctx2 };
      }
      badge.$set(badge_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(badge.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(badge.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(badge);
    }
  };
}
__name(create_if_block_3$6, "create_if_block_3$6");
function create_default_slot$e(ctx) {
  let t_value = (
    /*item*/
    ctx[21].usesRemaining + ""
  );
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*items*/
      32 && t_value !== (t_value = /*item*/
      ctx2[21].usesRemaining + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
__name(create_default_slot$e, "create_default_slot$e");
function create_if_block_2$8(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = ensure_array_like(
    /*item*/
    ctx[21].system.tags
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
  }
  const out = /* @__PURE__ */ __name((i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  }), "out");
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*items*/
      32) {
        each_value_1 = ensure_array_like(
          /*item*/
          ctx2[21].system.tags
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1$1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_1$1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
__name(create_if_block_2$8, "create_if_block_2$8");
function create_each_block_1$1(ctx) {
  let tag_1;
  let current;
  tag_1 = new Tag({
    props: {
      class: "badge small square",
      tag: (
        /*tag*/
        ctx[24]
      ),
      remover: false
    }
  });
  return {
    c() {
      create_component(tag_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tag_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tag_1_changes = {};
      if (dirty & /*items*/
      32)
        tag_1_changes.tag = /*tag*/
        ctx2[24];
      tag_1.$set(tag_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tag_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tag_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tag_1, detaching);
    }
  };
}
__name(create_each_block_1$1, "create_each_block_1$1");
function create_if_block_1$b(ctx) {
  let button0;
  let button1;
  let button2;
  let mounted;
  let dispose;
  return {
    c() {
      button0 = element("button");
      button0.innerHTML = `<i class="left fa fa-edit svelte-1tqlt0i" role="button"></i>`;
      button1 = element("button");
      button1.innerHTML = `<i class="left fa fa-copy svelte-1tqlt0i" role="button"></i>`;
      button2 = element("button");
      button2.innerHTML = `<i class="left fa fa-trash svelte-1tqlt0i" role="button"></i>`;
      attr(button0, "class", "stealth svelte-1tqlt0i");
      attr(button0, "data-tooltip-class", "FFXIV-tooltip");
      attr(button0, "data-tooltip", localize$1("Types.Actor.ActionButtons.Edit"));
      attr(button1, "class", "stealth svelte-1tqlt0i");
      attr(button1, "data-tooltip-class", "FFXIV-tooltip");
      attr(button1, "data-tooltip", localize$1("Types.Actor.ActionButtons.Duplicate"));
      attr(button2, "class", "stealth svelte-1tqlt0i");
      attr(button2, "data-tooltip-class", "FFXIV-tooltip");
      attr(button2, "data-tooltip", localize$1("Types.Actor.ActionButtons.Delete"));
    },
    m(target, anchor) {
      insert(target, button0, anchor);
      insert(target, button1, anchor);
      insert(target, button2, anchor);
      if (!mounted) {
        dispose = [
          listen(button0, "click", function() {
            if (is_function(editItem$3(
              /*item*/
              ctx[21]
            )))
              editItem$3(
                /*item*/
                ctx[21]
              ).apply(this, arguments);
          }),
          listen(button1, "click", function() {
            if (is_function(
              /*duplicateItem*/
              ctx[10](
                /*index*/
                ctx[23],
                /*item*/
                ctx[21]
              )
            ))
              ctx[10](
                /*index*/
                ctx[23],
                /*item*/
                ctx[21]
              ).apply(this, arguments);
          }),
          listen(button2, "click", function() {
            if (is_function(
              /*deleteItem*/
              ctx[11](
                /*index*/
                ctx[23],
                /*item*/
                ctx[21]
              )
            ))
              ctx[11](
                /*index*/
                ctx[23],
                /*item*/
                ctx[21]
              ).apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching) {
        detach(button0);
        detach(button1);
        detach(button2);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_if_block_1$b, "create_if_block_1$b");
function create_each_block$c(ctx) {
  let tr;
  let td0;
  let img;
  let img_src_value;
  let img_alt_value;
  let td1;
  let div1;
  let div0;
  let a;
  let t_value = (
    /*item*/
    ctx[21].name + ""
  );
  let t;
  let a_class_value;
  let div0_data_tooltip_value;
  let td2;
  let td3;
  let button;
  let i;
  let i_class_value;
  let td4;
  let tr_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*item*/
    ctx[21].system.hasLimitation && game.combat && create_if_block_3$6(ctx)
  );
  let if_block1 = (
    /*item*/
    ctx[21].system.tags && create_if_block_2$8(ctx)
  );
  let if_block2 = !/*$doc*/
  ctx[1].system.inventoryLocked && create_if_block_1$b(ctx);
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      img = element("img");
      td1 = element("td");
      div1 = element("div");
      div0 = element("div");
      a = element("a");
      t = text(t_value);
      if (if_block0)
        if_block0.c();
      td2 = element("td");
      if (if_block1)
        if_block1.c();
      td3 = element("td");
      button = element("button");
      i = element("i");
      td4 = element("td");
      if (if_block2)
        if_block2.c();
      attr(img, "class", "icon svelte-1tqlt0i");
      if (!src_url_equal(img.src, img_src_value = /*item*/
      ctx[21].img))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*item*/
      ctx[21].name);
      attr(td0, "class", "img svelte-1tqlt0i");
      attr(td0, "data-tooltip-class", "FFXIV-tooltip");
      attr(td0, "data-tooltip", localize$1("Use"));
      attr(td0, "role", "button");
      attr(a, "class", a_class_value = "stealth link " + /*item*/
      (ctx[21].system.isMagic ? "pulse" : "") + " svelte-1tqlt0i");
      attr(a, "role", "button");
      attr(div0, "class", "flex3 left svelte-1tqlt0i");
      attr(div0, "data-tooltip-class", "FFXIV-tooltip wordy");
      attr(div0, "data-tooltip", div0_data_tooltip_value = /*item*/
      ctx[21].system.description);
      attr(div1, "class", "flexrow svelte-1tqlt0i");
      attr(td1, "class", "left text ellipsis svelte-1tqlt0i");
      attr(td2, "class", "right no-wrap svelte-1tqlt0i");
      attr(i, "class", i_class_value = "fa-bookmark " + /*item*/
      (ctx[21].system.favourite === true ? "fa-solid" : "fa-regular") + " svelte-1tqlt0i");
      attr(i, "role", "button");
      attr(button, "class", "stealth svelte-1tqlt0i");
      attr(td3, "class", "shrink svelte-1tqlt0i");
      attr(td3, "data-tooltip-class", "FFXIV-tooltip");
      attr(td3, "data-tooltip", localize$1("Bookmark"));
      attr(td4, "class", "min buttons right svelte-1tqlt0i");
      attr(tr, "class", tr_class_value = null_to_empty(
        /*actionTypeClass*/
        ctx[17](
          /*item*/
          ctx[21]
        )
      ) + " svelte-1tqlt0i");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, img);
      append(tr, td1);
      append(td1, div1);
      append(div1, div0);
      append(div0, a);
      append(a, t);
      if (if_block0)
        if_block0.m(div1, null);
      append(tr, td2);
      if (if_block1)
        if_block1.m(td2, null);
      append(tr, td3);
      append(td3, button);
      append(button, i);
      append(tr, td4);
      if (if_block2)
        if_block2.m(td4, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(td0, "click", function() {
            if (is_function(
              /*RollCalc*/
              ctx[8].ability(
                /*item*/
                ctx[21].type,
                /*item*/
                ctx[21]
              )
            ))
              ctx[8].ability(
                /*item*/
                ctx[21].type,
                /*item*/
                ctx[21]
              ).apply(this, arguments);
          }),
          listen(a, "click", function() {
            if (is_function(showItemSheet$4(
              /*item*/
              ctx[21]
            )))
              showItemSheet$4(
                /*item*/
                ctx[21]
              ).apply(this, arguments);
          }),
          listen(button, "click", function() {
            if (is_function(toggleBookmark(
              /*item*/
              ctx[21]
            )))
              toggleBookmark(
                /*item*/
                ctx[21]
              ).apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty & /*items*/
      32 && !src_url_equal(img.src, img_src_value = /*item*/
      ctx[21].img)) {
        attr(img, "src", img_src_value);
      }
      if (!current || dirty & /*items*/
      32 && img_alt_value !== (img_alt_value = /*item*/
      ctx[21].name)) {
        attr(img, "alt", img_alt_value);
      }
      if ((!current || dirty & /*items*/
      32) && t_value !== (t_value = /*item*/
      ctx[21].name + ""))
        set_data(t, t_value);
      if (!current || dirty & /*items*/
      32 && a_class_value !== (a_class_value = "stealth link " + /*item*/
      (ctx[21].system.isMagic ? "pulse" : "") + " svelte-1tqlt0i")) {
        attr(a, "class", a_class_value);
      }
      if (!current || dirty & /*items*/
      32 && div0_data_tooltip_value !== (div0_data_tooltip_value = /*item*/
      ctx[21].system.description)) {
        attr(div0, "data-tooltip", div0_data_tooltip_value);
      }
      if (
        /*item*/
        ctx[21].system.hasLimitation && game.combat
      ) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
          if (dirty & /*items*/
          32) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3$6(ctx);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*item*/
        ctx[21].system.tags
      ) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
          if (dirty & /*items*/
          32) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2$8(ctx);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(td2, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*items*/
      32 && i_class_value !== (i_class_value = "fa-bookmark " + /*item*/
      (ctx[21].system.favourite === true ? "fa-solid" : "fa-regular") + " svelte-1tqlt0i")) {
        attr(i, "class", i_class_value);
      }
      if (!/*$doc*/
      ctx[1].system.inventoryLocked) {
        if (if_block2) {
          if_block2.p(ctx, dirty);
        } else {
          if_block2 = create_if_block_1$b(ctx);
          if_block2.c();
          if_block2.m(td4, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (!current || dirty & /*items*/
      32 && tr_class_value !== (tr_class_value = null_to_empty(
        /*actionTypeClass*/
        ctx[17](
          /*item*/
          ctx[21]
        )
      ) + " svelte-1tqlt0i")) {
        attr(tr, "class", tr_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(tr);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_each_block$c, "create_each_block$c");
function create_if_block$g(ctx) {
  let button0;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      button0 = element("button");
      button0.textContent = `${localize$1("Instructions.RemoveAll")}`;
      button1 = element("button");
      button1.textContent = `${localize$1("Instructions.ResetUses")}`;
      attr(button0, "class", "mt-sm glossy-button gold-light hover-shine");
      attr(button1, "class", "glossy-button gold-light hover-shine ml-sm");
    },
    m(target, anchor) {
      insert(target, button0, anchor);
      insert(target, button1, anchor);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*removeAllItems*/
            ctx[12]
          ),
          listen(
            button1,
            "click",
            /*resetAllUses*/
            ctx[13]
          )
        ];
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(button0);
        detach(button1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_if_block$g, "create_if_block$g");
function create_fragment$R(ctx) {
  let div1;
  let div0;
  let h1;
  let table;
  let tr;
  let th0;
  let th1;
  let th2;
  let th3;
  let button;
  let i;
  let i_class_value;
  let button_class_value;
  let th3_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*$Actor*/
    ctx[0].system.job?.name && create_if_block_4$3(ctx)
  );
  let each_value = ensure_array_like(
    /*items*/
    ctx[5]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$c(get_each_context$c(ctx, each_value, i2));
  }
  const out = /* @__PURE__ */ __name((i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  }), "out");
  let if_block1 = (
    /*hasItems*/
    ctx[2] && create_if_block$g(ctx)
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      h1 = element("h1");
      h1.textContent = `${localize$1("Abilities")}`;
      table = element("table");
      tr = element("tr");
      th0 = element("th");
      th1 = element("th");
      th1.textContent = `${localize$1("Name")}`;
      th2 = element("th");
      th2.textContent = `${localize$1("Tags")}`;
      th3 = element("th");
      button = element("button");
      i = element("i");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      if (if_block1)
        if_block1.c();
      attr(h1, "class", "gold");
      attr(th0, "class", "img shrink");
      attr(th0, "scope", "col");
      attr(th1, "class", "left expand ml-sm");
      attr(th1, "scope", "col");
      attr(th2, "scope", "col");
      attr(th2, "colspan", "1");
      attr(i, "class", i_class_value = "fa " + /*faLockCSS*/
      ctx[3] + " svelte-1tqlt0i");
      attr(button, "class", button_class_value = "stealth " + /*lockCSS*/
      ctx[4] + " svelte-1tqlt0i");
      attr(th3, "class", th3_class_value = "buttons " + /*lockCSS*/
      ctx[4] + " svelte-1tqlt0i");
      attr(th3, "scope", "col");
      attr(th3, "colspan", "2");
      attr(tr, "class", "gold");
      attr(table, "class", "borderless even svelte-1tqlt0i");
      attr(div0, "class", "padded svelte-1tqlt0i");
      attr(div1, "class", "panel overflow containerx svelte-1tqlt0i");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append(div0, h1);
      append(div0, table);
      append(table, tr);
      append(tr, th0);
      append(tr, th1);
      append(tr, th2);
      append(tr, th3);
      append(th3, button);
      append(button, i);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(table, null);
        }
      }
      if (if_block1)
        if_block1.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*toggleLock*/
          ctx[14]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*$Actor*/
        ctx2[0].system.job?.name
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_4$3(ctx2);
          if_block0.c();
          if_block0.m(div0, h1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!current || dirty & /*faLockCSS*/
      8 && i_class_value !== (i_class_value = "fa " + /*faLockCSS*/
      ctx2[3] + " svelte-1tqlt0i")) {
        attr(i, "class", i_class_value);
      }
      if (!current || dirty & /*lockCSS*/
      16 && button_class_value !== (button_class_value = "stealth " + /*lockCSS*/
      ctx2[4] + " svelte-1tqlt0i")) {
        attr(button, "class", button_class_value);
      }
      if (!current || dirty & /*lockCSS*/
      16 && th3_class_value !== (th3_class_value = "buttons " + /*lockCSS*/
      ctx2[4] + " svelte-1tqlt0i")) {
        attr(th3, "class", th3_class_value);
      }
      if (dirty & /*actionTypeClass, items, deleteItem, duplicateItem, editItem, $doc, badgeType, game, showItemSheet, RollCalc*/
      199970) {
        each_value = ensure_array_like(
          /*items*/
          ctx2[5]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$c(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$c(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(table, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (
        /*hasItems*/
        ctx2[2]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$g(ctx2);
          if_block1.c();
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (if_block0)
        if_block0.d();
      destroy_each(each_blocks, detaching);
      if (if_block1)
        if_block1.d();
      mounted = false;
      dispose();
    }
  };
}
__name(create_fragment$R, "create_fragment$R");
function editItem$3(item) {
  item.sheet.render(true);
}
__name(editItem$3, "editItem$3");
function showItemSheet$4(item) {
  item.sheet.render(true);
}
__name(showItemSheet$4, "showItemSheet$4");
function instance$K($$self, $$props, $$invalidate) {
  let items;
  let lockCSS;
  let faLockCSS;
  let hasItems;
  let $Actor;
  let $doc;
  let $wildcard;
  const Actor2 = getContext("#doc");
  component_subscribe($$self, Actor2, (value) => $$invalidate(0, $Actor = value));
  const doc = new TJSDocument($Actor);
  component_subscribe($$self, doc, (value) => $$invalidate(1, $doc = value));
  const RollCalc2 = new CONFIG.FFXIV.RollCalcActor({ actor: $Actor });
  const typeSearch = createFilterQuery("type");
  typeSearch.set(["trait", "action"]);
  onMount(() => {
  });
  const wildcard = doc.embedded.create(Item, {
    name: "wildcard",
    filters: [typeSearch],
    sort: (a, b) => {
      const typeOrder = ["primary", "secondary", "reaction"];
      if (a.type === b.type) {
        if (a.system.type === b.system.type) {
          return a.name.localeCompare(b.name);
        }
        return typeOrder.indexOf(a.system.type) - typeOrder.indexOf(b.system.type);
      }
      return a.type.localeCompare(b.type);
    }
  });
  component_subscribe($$self, wildcard, (value) => $$invalidate(18, $wildcard = value));
  function duplicateItem(item) {
    const itemData = item.toObject();
    delete itemData._id;
    $Actor.sheet._onDropItemCreate(itemData);
  }
  __name(duplicateItem, "duplicateItem");
  function deleteItem(index, item) {
    let okToDelete = true;
    if (game.settings.get(SYSTEM_ID, "confirmBeforeDeletingActorItem")) {
      okToDelete = confirm(game.i18n.localize("Types.Actor.Abilities.confirmDeleteItem"));
    }
    if (okToDelete) {
      item.delete();
    }
  }
  __name(deleteItem, "deleteItem");
  async function removeAllItems() {
    await Dialog.confirm({
      title: localize$1("Types.Actor.Abilities.confirmDeleteAllTitle"),
      content: localize$1("Types.Actor.Abilities.confirmDeleteAll"),
      yes: async () => {
        await $Actor.deleteAllItems(["trait", "action"]);
      },
      no: () => {
      }
    });
  }
  __name(removeAllItems, "removeAllItems");
  async function resetAllUses() {
    const items2 = $Actor.items.filter((item) => item.system.hasLimitation);
    for (const item of items2) {
      await item.update({ "system.uses": 0 });
    }
  }
  __name(resetAllUses, "resetAllUses");
  function toggleLock(event) {
    game.system.log.d("a");
    event.stopPropagation();
    event.preventDefault();
    $doc.update(
      {
        ["system.inventoryLocked"]: !$doc.system.inventoryLocked
      },
      {
        diff: true,
        diffData: true,
        diffSystem: true
      }
    );
  }
  __name(toggleLock, "toggleLock");
  async function deleteJob() {
    if (!$doc.system.job.uuid) {
      return;
    }
    await Dialog.confirm({
      title: localize$1("Types.Actor.Abilities.confirmDeleteJobTitle"),
      content: localize$1("Types.Actor.Abilities.confirmDeleteJob"),
      yes: async () => {
        const job = await fromUuid($doc.system.job.uuid);
        const grants = job?.system?.grants;
        if (grants) {
          const grantedItems = [];
          for (let grant of grants.list) {
            const item = await fromUuid(grant.uuid);
            if (item)
              grantedItems.push(item);
          }
          const actorItems = $doc.items.filter((x) => ["action", "trait"].includes(x.type));
          for (let grantedItem of grantedItems) {
            const matchingItems = actorItems.filter((x) => x.name === grantedItem.name && x.type === grantedItem.type);
            for (let item of matchingItems) {
              game.system.log.d("Deleting item:", item);
              await item.delete();
            }
          }
        }
        await $doc.update({
          system: {
            job: {
              uuid: "",
              name: "",
              grants: [],
              level: null,
              img: null,
              role: ""
            }
          }
        });
      },
      no: () => {
      }
    });
  }
  __name(deleteJob, "deleteJob");
  onMount(async () => {
  });
  const badgeType = /* @__PURE__ */ __name((item) => {
    return item.system.uses >= item.system.limitation ? "danger" : "success";
  }, "badgeType");
  const actionTypeClass = /* @__PURE__ */ __name((item) => {
    return item.type === "action" ? item.system?.type : "trait";
  }, "actionTypeClass");
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$wildcard*/
    262144) {
      $$invalidate(5, items = [...$wildcard]);
    }
    if ($$self.$$.dirty & /*$doc*/
    2) {
      $$invalidate(4, lockCSS = $doc.system.inventoryLocked ? "lock" : "lock-open");
    }
    if ($$self.$$.dirty & /*$doc*/
    2) {
      $$invalidate(3, faLockCSS = $doc.system.inventoryLocked ? "fa-lock negative" : "fa-lock-open positive");
    }
    if ($$self.$$.dirty & /*$Actor*/
    1) {
      $$invalidate(2, hasItems = $Actor.items.some((x) => ["action", "trait"].includes(x.type)));
    }
  };
  return [
    $Actor,
    $doc,
    hasItems,
    faLockCSS,
    lockCSS,
    items,
    Actor2,
    doc,
    RollCalc2,
    wildcard,
    duplicateItem,
    deleteItem,
    removeAllItems,
    resetAllUses,
    toggleLock,
    deleteJob,
    badgeType,
    actionTypeClass,
    $wildcard
  ];
}
__name(instance$K, "instance$K");
let Abilities$1 = class Abilities extends SvelteComponent {
  static {
    __name(this, "Abilities");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$K, create_fragment$R, safe_not_equal, {});
  }
};
function create_if_block$f(ctx) {
  let div;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button = element("button");
      button.innerHTML = `<i class="fas fa-dice"></i>`;
      attr(button, "class", "wide stealth flex dice svelte-3qeig2");
      attr(div, "class", "flex0");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(
            /*onclick*/
            ctx[2](
              /*key*/
              ctx[1],
              /*code*/
              ctx[0]
            )
          ))
            ctx[2](
              /*key*/
              ctx[1],
              /*code*/
              ctx[0]
            ).apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block$f, "create_if_block$f");
function create_fragment$Q(ctx) {
  let div4;
  let div3;
  let div2;
  let button;
  let div0;
  let t0;
  let t1;
  let div1;
  let t2;
  let t3;
  let button_class_value;
  let button_data_tooltip_value;
  let mounted;
  let dispose;
  let if_block = !/*isEditing*/
  ctx[3] && create_if_block$f(ctx);
  return {
    c() {
      div4 = element("div");
      div3 = element("div");
      if (if_block)
        if_block.c();
      div2 = element("div");
      button = element("button");
      div0 = element("div");
      t0 = text(
        /*label*/
        ctx[7]
      );
      t1 = space();
      div1 = element("div");
      t2 = text(
        /*sign*/
        ctx[6]
      );
      t3 = text(
        /*value*/
        ctx[4]
      );
      attr(div0, "class", "flex2 header svelte-3qeig2");
      attr(div1, "class", "flex0 header svelte-3qeig2");
      attr(button, "class", button_class_value = "left wide tall stealth flexrow " + /*disabled*/
      ctx[5] + " svelte-3qeig2");
      attr(button, "data-tooltip", button_data_tooltip_value = /*isEditing*/
      ctx[3] ? localize(`${SYSTEM_CODE}.Types.Actor.EditAttribute.Tooltip`) : void 0);
      attr(div2, "class", "flex3 left");
      attr(div3, "class", "underscore flexrow justify-vertical svelte-3qeig2");
      attr(div4, "class", "attribute svelte-3qeig2");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div3);
      if (if_block)
        if_block.m(div3, null);
      append(div3, div2);
      append(div2, button);
      append(button, div0);
      append(div0, t0);
      append(div0, t1);
      append(button, div1);
      append(div1, t2);
      append(div1, t3);
      if (!mounted) {
        dispose = [
          listen(
            button,
            "click",
            /*add*/
            ctx[10]
          ),
          listen(
            button,
            "contextmenu",
            /*remove*/
            ctx[11]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!/*isEditing*/
      ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$f(ctx2);
          if_block.c();
          if_block.m(div3, div2);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*label*/
      128)
        set_data(
          t0,
          /*label*/
          ctx2[7]
        );
      if (dirty & /*sign*/
      64)
        set_data(
          t2,
          /*sign*/
          ctx2[6]
        );
      if (dirty & /*value*/
      16)
        set_data(
          t3,
          /*value*/
          ctx2[4]
        );
      if (dirty & /*disabled*/
      32 && button_class_value !== (button_class_value = "left wide tall stealth flexrow " + /*disabled*/
      ctx2[5] + " svelte-3qeig2")) {
        attr(button, "class", button_class_value);
      }
      if (dirty & /*isEditing*/
      8 && button_data_tooltip_value !== (button_data_tooltip_value = /*isEditing*/
      ctx2[3] ? localize(`${SYSTEM_CODE}.Types.Actor.EditAttribute.Tooltip`) : void 0)) {
        attr(button, "data-tooltip", button_data_tooltip_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_fragment$Q, "create_fragment$Q");
function instance$J($$self, $$props, $$invalidate) {
  let label;
  let value;
  let isEditing;
  let sign;
  let disabled;
  let $width;
  let $actor;
  let { code } = $$props;
  let { key } = $$props;
  let { abbreviateLabel = false } = $$props;
  let { showSign = false } = $$props;
  let { onclick = /* @__PURE__ */ __name(() => {
    console.log("default onclick");
  }, "onclick") } = $$props;
  const actor = getContext("#doc");
  component_subscribe($$self, actor, (value2) => $$invalidate(15, $actor = value2));
  const application = getContext("#external").application;
  const { width } = application.position.stores;
  component_subscribe($$self, width, (value2) => $$invalidate(14, $width = value2));
  const add = /* @__PURE__ */ __name(() => {
    if (!isEditing)
      return;
    $actor.update({
      system: {
        attributes: { [key]: { [code]: { val: value + 1 } } }
      }
    });
  }, "add");
  const remove = /* @__PURE__ */ __name(() => {
    if (!isEditing)
      return;
    $actor.update({
      system: {
        attributes: { [key]: { [code]: { val: value - 1 } } }
      }
    });
  }, "remove");
  onMount(() => {
  });
  $$self.$$set = ($$props2) => {
    if ("code" in $$props2)
      $$invalidate(0, code = $$props2.code);
    if ("key" in $$props2)
      $$invalidate(1, key = $$props2.key);
    if ("abbreviateLabel" in $$props2)
      $$invalidate(12, abbreviateLabel = $$props2.abbreviateLabel);
    if ("showSign" in $$props2)
      $$invalidate(13, showSign = $$props2.showSign);
    if ("onclick" in $$props2)
      $$invalidate(2, onclick = $$props2.onclick);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$width*/
    16384) {
      $$invalidate(12, abbreviateLabel = $width <= 600);
    }
    if ($$self.$$.dirty & /*abbreviateLabel, key, code*/
    4099) {
      $$invalidate(7, label = abbreviateLabel ? localize(`${SYSTEM_CODE}.Types.Actor.Types.PC.Attributes.${key}.${code}.Abbreviation`) : localize(`${SYSTEM_CODE}.Types.Actor.Types.PC.Attributes.${key}.${code}.Label`));
    }
    if ($$self.$$.dirty & /*$actor, key, code*/
    32771) {
      $$invalidate(4, value = $actor?.system?.attributes?.[key]?.[code]?.val);
    }
    if ($$self.$$.dirty & /*$actor*/
    32768) {
      $$invalidate(3, isEditing = $actor?.system?.isEditing);
    }
    if ($$self.$$.dirty & /*showSign, value*/
    8208) {
      $$invalidate(6, sign = showSign ? value > 0 ? "+" : value < 0 ? "" : "" : "");
    }
    if ($$self.$$.dirty & /*isEditing*/
    8) {
      $$invalidate(5, disabled = isEditing ? "" : "disabled");
    }
  };
  return [
    code,
    key,
    onclick,
    isEditing,
    value,
    disabled,
    sign,
    label,
    actor,
    width,
    add,
    remove,
    abbreviateLabel,
    showSign,
    $width,
    $actor
  ];
}
__name(instance$J, "instance$J");
class Attribute extends SvelteComponent {
  static {
    __name(this, "Attribute");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$J, create_fragment$Q, safe_not_equal, {
      code: 0,
      key: 1,
      abbreviateLabel: 12,
      showSign: 13,
      onclick: 2
    });
  }
}
function get_each_context$b(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i].code;
  child_ctx[7] = i;
  return child_ctx;
}
__name(get_each_context$b, "get_each_context$b");
function create_each_block$b(ctx) {
  let attribute;
  let current;
  attribute = new Attribute({
    props: {
      showSign: (
        /*showSign*/
        ctx[3]
      ),
      abbreviateLabel: (
        /*abbreviateLabel*/
        ctx[1]
      ),
      key: (
        /*key*/
        ctx[2]
      ),
      code: (
        /*code*/
        ctx[5]
      ),
      onclick: (
        /*onclick*/
        ctx[4]
      )
    }
  });
  return {
    c() {
      create_component(attribute.$$.fragment);
    },
    m(target, anchor) {
      mount_component(attribute, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const attribute_changes = {};
      if (dirty & /*showSign*/
      8)
        attribute_changes.showSign = /*showSign*/
        ctx2[3];
      if (dirty & /*abbreviateLabel*/
      2)
        attribute_changes.abbreviateLabel = /*abbreviateLabel*/
        ctx2[1];
      if (dirty & /*key*/
      4)
        attribute_changes.key = /*key*/
        ctx2[2];
      if (dirty & /*data*/
      1)
        attribute_changes.code = /*code*/
        ctx2[5];
      if (dirty & /*onclick*/
      16)
        attribute_changes.onclick = /*onclick*/
        ctx2[4];
      attribute.$set(attribute_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(attribute.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(attribute.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(attribute, detaching);
    }
  };
}
__name(create_each_block$b, "create_each_block$b");
function create_fragment$P(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like(
    /*data*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$b(get_each_context$b(ctx, each_value, i));
  }
  const out = /* @__PURE__ */ __name((i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  }), "out");
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "component");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*showSign, abbreviateLabel, key, data, onclick*/
      31) {
        each_value = ensure_array_like(
          /*data*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$b(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$b(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
__name(create_fragment$P, "create_fragment$P");
function instance$I($$self, $$props, $$invalidate) {
  let { data } = $$props;
  let { abbreviateLabel = false } = $$props;
  let { key } = $$props;
  let { showSign = false } = $$props;
  let { onclick } = $$props;
  onMount(() => {
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("abbreviateLabel" in $$props2)
      $$invalidate(1, abbreviateLabel = $$props2.abbreviateLabel);
    if ("key" in $$props2)
      $$invalidate(2, key = $$props2.key);
    if ("showSign" in $$props2)
      $$invalidate(3, showSign = $$props2.showSign);
    if ("onclick" in $$props2)
      $$invalidate(4, onclick = $$props2.onclick);
  };
  return [data, abbreviateLabel, key, showSign, onclick];
}
__name(instance$I, "instance$I");
let AttributeCol$1 = class AttributeCol extends SvelteComponent {
  static {
    __name(this, "AttributeCol");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$I, create_fragment$P, safe_not_equal, {
      data: 0,
      abbreviateLabel: 1,
      key: 2,
      showSign: 3,
      onclick: 4
    });
  }
};
function create_fragment$O(ctx) {
  let div1;
  let div0;
  let attributecol;
  let current;
  attributecol = new AttributeCol$1({
    props: {
      key: "primary",
      showSign: true,
      abbreviateLabel: true,
      data: (
        /*data*/
        ctx[1]
      ),
      onclick: (
        /*onclick*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      div0.textContent = `${localize$1("Primary")} ${localize$1("Attributes")}`;
      create_component(attributecol.$$.fragment);
      attr(div0, "class", "flexrow header underscore mb-md svelte-1noexin");
      attr(div1, "class", "molecule svelte-1noexin");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(attributecol, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const attributecol_changes = {};
      if (dirty & /*onclick*/
      1)
        attributecol_changes.onclick = /*onclick*/
        ctx2[0];
      attributecol.$set(attributecol_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(attributecol.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(attributecol.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(attributecol);
    }
  };
}
__name(create_fragment$O, "create_fragment$O");
function instance$H($$self, $$props, $$invalidate) {
  let { onclick } = $$props;
  let data = [
    { code: "str" },
    { code: "dex" },
    { code: "vit" },
    { code: "int" },
    { code: "mnd" }
  ];
  $$self.$$set = ($$props2) => {
    if ("onclick" in $$props2)
      $$invalidate(0, onclick = $$props2.onclick);
  };
  return [onclick, data];
}
__name(instance$H, "instance$H");
let PrimaryAttributes$1 = class PrimaryAttributes extends SvelteComponent {
  static {
    __name(this, "PrimaryAttributes");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$H, create_fragment$O, safe_not_equal, { onclick: 0 });
  }
};
function create_fragment$N(ctx) {
  let div1;
  let div0;
  let attributecol;
  let current;
  attributecol = new AttributeCol$1({
    props: {
      key: "secondary",
      data: (
        /*data*/
        ctx[1]
      ),
      onclick: (
        /*onclick*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      div0.textContent = `${localize$1("Secondary")} ${localize$1("Attributes")}`;
      create_component(attributecol.$$.fragment);
      attr(div0, "class", "flexrow header underscore mb-md svelte-9f9n3s");
      attr(div1, "class", "molecule svelte-9f9n3s");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(attributecol, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const attributecol_changes = {};
      if (dirty & /*onclick*/
      1)
        attributecol_changes.onclick = /*onclick*/
        ctx2[0];
      attributecol.$set(attributecol_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(attributecol.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(attributecol.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(attributecol);
    }
  };
}
__name(create_fragment$N, "create_fragment$N");
function instance$G($$self, $$props, $$invalidate) {
  let { onclick } = $$props;
  let data = [{ code: "def" }, { code: "mag" }, { code: "vig" }, { code: "spd" }];
  $$self.$$set = ($$props2) => {
    if ("onclick" in $$props2)
      $$invalidate(0, onclick = $$props2.onclick);
  };
  return [onclick, data];
}
__name(instance$G, "instance$G");
let SecondaryAttributes$1 = class SecondaryAttributes extends SvelteComponent {
  static {
    __name(this, "SecondaryAttributes");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$G, create_fragment$N, safe_not_equal, { onclick: 0 });
  }
};
function create_fragment$M(ctx) {
  let div2;
  let div0;
  let primaryattributes;
  let div1;
  let secondaryattributes;
  let current;
  primaryattributes = new PrimaryAttributes$1({ props: { onclick: (
    /*onclick*/
    ctx[1]
  ) } });
  secondaryattributes = new SecondaryAttributes$1({ props: { onclick: (
    /*onclick*/
    ctx[1]
  ) } });
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      create_component(primaryattributes.$$.fragment);
      div1 = element("div");
      create_component(secondaryattributes.$$.fragment);
      attr(div0, "class", "flex");
      attr(div1, "class", "flex");
      attr(div2, "class", "molecule flexrow svelte-xanq5m");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      mount_component(primaryattributes, div0, null);
      append(div2, div1);
      mount_component(secondaryattributes, div1, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(primaryattributes.$$.fragment, local);
      transition_in(secondaryattributes.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(primaryattributes.$$.fragment, local);
      transition_out(secondaryattributes.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(primaryattributes);
      destroy_component(secondaryattributes);
    }
  };
}
__name(create_fragment$M, "create_fragment$M");
function instance$F($$self, $$props, $$invalidate) {
  let $actor;
  const actor = getContext("#doc");
  component_subscribe($$self, actor, (value) => $$invalidate(2, $actor = value));
  const RollCalc2 = new CONFIG.FFXIV.RollCalcActor({ actor: $actor });
  const onclick = /* @__PURE__ */ __name(async (key, code) => {
    await RollCalc2.attribute(key, code);
  }, "onclick");
  return [actor, onclick];
}
__name(instance$F, "instance$F");
let AttributeBlock$1 = class AttributeBlock extends SvelteComponent {
  static {
    __name(this, "AttributeBlock");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$F, create_fragment$M, safe_not_equal, {});
  }
};
function create_fragment$L(ctx) {
  let div9;
  let div8;
  let div6;
  let div5;
  let div1;
  let div0;
  let button;
  let div4;
  let div2;
  let div3;
  let t2;
  let div7;
  let t3;
  let t4;
  let t5;
  let mounted;
  let dispose;
  return {
    c() {
      div9 = element("div");
      div8 = element("div");
      div6 = element("div");
      div5 = element("div");
      div1 = element("div");
      div0 = element("div");
      button = element("button");
      button.innerHTML = `<img class="rest-icon svelte-1ab4iud" src="/systems/foundryvtt-final-fantasy/assets/icons/tabs/tent.webp" alt="${localize$1("TitleBlock.Rest")}"/>`;
      div4 = element("div");
      div2 = element("div");
      div2.textContent = `${localize$1("LV")} `;
      div3 = element("div");
      t2 = text(
        /*level*/
        ctx[0]
      );
      div7 = element("div");
      t3 = text(
        /*roleName*/
        ctx[1]
      );
      t4 = text(" /  ");
      t5 = text(
        /*jobName*/
        ctx[2]
      );
      attr(button, "class", "stealth");
      attr(button, "data-tooltip", localize$1("TitleBlock.Rest"));
      attr(button, "aria-label", localize$1("TitleBlock.Rest"));
      attr(div0, "class", "left mt-xxs");
      attr(div1, "class", "flex1 rest-button svelte-1ab4iud");
      attr(div2, "class", "scaleup");
      attr(div3, "class", "scaleup");
      attr(div4, "class", "flex4 nowrap font-inter lvcontainer glow svelte-1ab4iud");
      attr(div5, "class", "flexrow no-wrap");
      attr(div6, "class", "flex4 no-wrap");
      attr(div7, "class", "flex4 no-wrap font-cinzel job svelte-1ab4iud");
      attr(div8, "class", "flexrow");
      attr(div9, "class", "px-sm panel pt-xs containerx wide svelte-1ab4iud");
    },
    m(target, anchor) {
      insert(target, div9, anchor);
      append(div9, div8);
      append(div8, div6);
      append(div6, div5);
      append(div5, div1);
      append(div1, div0);
      append(div0, button);
      append(div5, div4);
      append(div4, div2);
      append(div4, div3);
      append(div3, t2);
      append(div8, div7);
      append(div7, t3);
      append(div7, t4);
      append(div7, t5);
      if (!mounted) {
        dispose = listen(button, "click", prevent_default(
          /*rest*/
          ctx[4]
        ));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*level*/
      1)
        set_data(
          t2,
          /*level*/
          ctx2[0]
        );
      if (dirty & /*roleName*/
      2)
        set_data(
          t3,
          /*roleName*/
          ctx2[1]
        );
      if (dirty & /*jobName*/
      4)
        set_data(
          t5,
          /*jobName*/
          ctx2[2]
        );
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div9);
      }
      mounted = false;
      dispose();
    }
  };
}
__name(create_fragment$L, "create_fragment$L");
function instance$E($$self, $$props, $$invalidate) {
  let jobName;
  let roleName;
  let level;
  let $actor;
  const actor = getContext("#doc");
  component_subscribe($$self, actor, (value) => $$invalidate(5, $actor = value));
  onMount(() => {
  });
  async function rest(event) {
    await Dialog.confirm({
      title: "",
      content: localize$1("TitleBlock.ConfirmRest"),
      yes: async () => {
        await $actor.update({
          system: {
            points: {
              MP: { val: $actor.system.points.MP.max },
              HP: { val: $actor.system.points.HP.max }
            },
            BP: { val: $actor.system.points.BP.max }
          }
        });
        ui.notifications.info(localize$1("TitleBlock.PointsRestored"));
      },
      no: () => {
      }
    });
  }
  __name(rest, "rest");
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$actor*/
    32) {
      $$invalidate(2, jobName = $actor.system.job?.name.split(" ")[0].toUpperCase());
    }
    if ($$self.$$.dirty & /*$actor*/
    32) {
      $$invalidate(1, roleName = $actor.system.job?.role.toUpperCase());
    }
    if ($$self.$$.dirty & /*$actor*/
    32) {
      $$invalidate(0, level = $actor.system.job?.level || "");
    }
    if ($$self.$$.dirty & /*$actor*/
    32) {
      $actor.system.job?.name ? true : false;
    }
  };
  return [level, roleName, jobName, actor, rest, $actor];
}
__name(instance$E, "instance$E");
class TitleBlock extends SvelteComponent {
  static {
    __name(this, "TitleBlock");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$E, create_fragment$L, safe_not_equal, {});
  }
}
function create_fragment$K(ctx) {
  let section;
  let div4;
  let div0;
  let titleblock;
  let div3;
  let div1;
  let attributeblock;
  let div2;
  let portraitframe;
  let current;
  titleblock = new TitleBlock({});
  attributeblock = new AttributeBlock$1({});
  portraitframe = new PortraitFrame({
    props: {
      img: true,
      imgSrc: (
        /*$documentStore*/
        ctx[0]?.img
      ),
      onclick: (
        /*_editToken*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      section = element("section");
      div4 = element("div");
      div0 = element("div");
      create_component(titleblock.$$.fragment);
      div3 = element("div");
      div1 = element("div");
      create_component(attributeblock.$$.fragment);
      div2 = element("div");
      create_component(portraitframe.$$.fragment);
      attr(div0, "class", "texture svelte-89vfdl");
      attr(div1, "class", "flex2");
      attr(div2, "class", "flex1 portrait-frame svelte-89vfdl");
      attr(div3, "class", "flexrow panel borderless");
      attr(div4, "class", "flexcol background svelte-89vfdl");
      attr(section, "class", "organism");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, div4);
      append(div4, div0);
      mount_component(titleblock, div4, null);
      append(div4, div3);
      append(div3, div1);
      mount_component(attributeblock, div1, null);
      append(div3, div2);
      mount_component(portraitframe, div2, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const portraitframe_changes = {};
      if (dirty & /*$documentStore*/
      1)
        portraitframe_changes.imgSrc = /*$documentStore*/
        ctx2[0]?.img;
      portraitframe.$set(portraitframe_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(titleblock.$$.fragment, local);
      transition_in(attributeblock.$$.fragment, local);
      transition_in(portraitframe.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(titleblock.$$.fragment, local);
      transition_out(attributeblock.$$.fragment, local);
      transition_out(portraitframe.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      destroy_component(titleblock);
      destroy_component(attributeblock);
      destroy_component(portraitframe);
    }
  };
}
__name(create_fragment$K, "create_fragment$K");
function instance$D($$self, $$props, $$invalidate) {
  let $documentStore;
  const application = getContext("#external").application;
  const documentStore = getContext("#doc");
  component_subscribe($$self, documentStore, (value) => $$invalidate(0, $documentStore = value));
  let _filePickerInstance = {};
  function _launchStandardProfileEditor(event) {
    const current = $documentStore.img;
    if (_filePickerInstance instanceof FilePicker && !_filePickerInstance?.rendered) {
      _filePickerInstance.render(true);
      return;
    }
    _filePickerInstance = new FilePicker({
      type: "image",
      current,
      callback: (path) => {
        $documentStore.update({ img: path });
      },
      top: application.position.top + 40,
      left: application.position.left + 10
    });
    return _filePickerInstance.browse();
  }
  __name(_launchStandardProfileEditor, "_launchStandardProfileEditor");
  function _editToken(event) {
    if (game.modules.has("vtta-tokenizer") && typeof Tokenizer !== "undefined") {
      _launchTokenizer();
    } else {
      _launchStandardProfileEditor();
    }
  }
  __name(_editToken, "_editToken");
  function _launchTokenizer() {
    if (game.modules.has("vtta-tokenizer") && typeof Tokenizer !== "undefined") {
      Tokenizer.tokenizeActor($documentStore);
    }
  }
  __name(_launchTokenizer, "_launchTokenizer");
  return [$documentStore, documentStore, _editToken];
}
__name(instance$D, "instance$D");
let AttributeSection$1 = class AttributeSection extends SvelteComponent {
  static {
    __name(this, "AttributeSection");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$D, create_fragment$K, safe_not_equal, {});
  }
};
function create_fragment$J(ctx) {
  let div13;
  let div4;
  let div1;
  let div0;
  let div3;
  let div2;
  let div9;
  let div6;
  let div8;
  let div7;
  let docinput0;
  let div12;
  let div11;
  let div10;
  let docinput1;
  let current;
  docinput0 = new DocInput({
    props: {
      class: "wide",
      clickType: "click",
      pulse: true,
      type: "number",
      name: "HP",
      min: "0",
      valuePath: "system.points.HP.max"
    }
  });
  docinput1 = new DocInput({
    props: {
      class: "wide",
      clickType: "click",
      pulse: true,
      type: "number",
      name: "HP",
      min: "0",
      max: (
        /*$actor*/
        ctx[0].system.points.HP.max
      ),
      valuePath: "system.points.HP.val"
    }
  });
  return {
    c() {
      div13 = element("div");
      div4 = element("div");
      div1 = element("div");
      div0 = element("div");
      div0.textContent = `${localize$1("Types.Actor.Points.HP.short")}`;
      div3 = element("div");
      div2 = element("div");
      div2.textContent = `${localize$1("Types.Actor.Points.HP.Label")}`;
      div9 = element("div");
      div6 = element("div");
      div6.innerHTML = `<div class="header svelte-rxqier">Max</div>`;
      div8 = element("div");
      div7 = element("div");
      create_component(docinput0.$$.fragment);
      div12 = element("div");
      div11 = element("div");
      div10 = element("div");
      create_component(docinput1.$$.fragment);
      attr(div0, "class", "header svelte-rxqier");
      attr(div1, "class", "header svelte-rxqier");
      attr(div2, "class", "header svelte-rxqier");
      attr(div3, "class", "sub-header svelte-rxqier");
      attr(div4, "class", "flex3");
      attr(div6, "class", "flex sub-header svelte-rxqier");
      attr(div7, "class", "header svelte-rxqier");
      attr(div8, "class", "flex max header svelte-rxqier");
      attr(div9, "class", "flex2");
      attr(div10, "class", "header svelte-rxqier");
      attr(div11, "class", "header val svelte-rxqier");
      attr(div12, "class", "flex2 left");
      attr(div13, "class", "hp flexrow justify-vertical svelte-rxqier");
    },
    m(target, anchor) {
      insert(target, div13, anchor);
      append(div13, div4);
      append(div4, div1);
      append(div1, div0);
      append(div4, div3);
      append(div3, div2);
      append(div13, div9);
      append(div9, div6);
      append(div9, div8);
      append(div8, div7);
      mount_component(docinput0, div7, null);
      append(div13, div12);
      append(div12, div11);
      append(div11, div10);
      mount_component(docinput1, div10, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const docinput1_changes = {};
      if (dirty & /*$actor*/
      1)
        docinput1_changes.max = /*$actor*/
        ctx2[0].system.points.HP.max;
      docinput1.$set(docinput1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(docinput0.$$.fragment, local);
      transition_in(docinput1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(docinput0.$$.fragment, local);
      transition_out(docinput1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div13);
      }
      destroy_component(docinput0);
      destroy_component(docinput1);
    }
  };
}
__name(create_fragment$J, "create_fragment$J");
function instance$C($$self, $$props, $$invalidate) {
  let $actor;
  const actor = getContext("#doc");
  component_subscribe($$self, actor, (value) => $$invalidate(0, $actor = value));
  onMount(() => {
  });
  return [$actor, actor];
}
__name(instance$C, "instance$C");
class HP extends SvelteComponent {
  static {
    __name(this, "HP");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$C, create_fragment$J, safe_not_equal, {});
  }
}
function create_fragment$I(ctx) {
  let div13;
  let div4;
  let div1;
  let div0;
  let div3;
  let div2;
  let div9;
  let div6;
  let div5;
  let div8;
  let div7;
  let docinput0;
  let div12;
  let div11;
  let div10;
  let docinput1;
  let current;
  docinput0 = new DocInput({
    props: {
      class: "wide",
      clickType: "click",
      pulse: true,
      type: "number",
      name: "MP",
      min: "0",
      valuePath: "system.points.MP.max"
    }
  });
  docinput1 = new DocInput({
    props: {
      class: "wide",
      clickType: "click",
      pulse: true,
      type: "number",
      name: "MP",
      min: "0",
      max: (
        /*$actor*/
        ctx[0].system.points.MP.max
      ),
      valuePath: "system.points.MP.val"
    }
  });
  return {
    c() {
      div13 = element("div");
      div4 = element("div");
      div1 = element("div");
      div0 = element("div");
      div0.textContent = `${localize$1("Types.Actor.Points.MP.short")}`;
      div3 = element("div");
      div2 = element("div");
      div2.textContent = `${localize$1("Types.Actor.Points.MP.Label")}`;
      div9 = element("div");
      div6 = element("div");
      div5 = element("div");
      div5.textContent = `${localize$1("Max")}`;
      div8 = element("div");
      div7 = element("div");
      create_component(docinput0.$$.fragment);
      div12 = element("div");
      div11 = element("div");
      div10 = element("div");
      create_component(docinput1.$$.fragment);
      attr(div0, "class", "header svelte-rxqifo");
      attr(div1, "class", "header svelte-rxqifo");
      attr(div2, "class", "header svelte-rxqifo");
      attr(div3, "class", "sub-header svelte-rxqifo");
      attr(div4, "class", "flex3");
      attr(div5, "class", "header svelte-rxqifo");
      attr(div6, "class", "flex sub-header svelte-rxqifo");
      attr(div7, "class", "header svelte-rxqifo");
      attr(div8, "class", "flex max header svelte-rxqifo");
      attr(div9, "class", "flex2");
      attr(div10, "class", "header svelte-rxqifo");
      attr(div11, "class", "header val svelte-rxqifo");
      attr(div12, "class", "flex2 left");
      attr(div13, "class", "mp flexrow justify-vertical svelte-rxqifo");
    },
    m(target, anchor) {
      insert(target, div13, anchor);
      append(div13, div4);
      append(div4, div1);
      append(div1, div0);
      append(div4, div3);
      append(div3, div2);
      append(div13, div9);
      append(div9, div6);
      append(div6, div5);
      append(div9, div8);
      append(div8, div7);
      mount_component(docinput0, div7, null);
      append(div13, div12);
      append(div12, div11);
      append(div11, div10);
      mount_component(docinput1, div10, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const docinput1_changes = {};
      if (dirty & /*$actor*/
      1)
        docinput1_changes.max = /*$actor*/
        ctx2[0].system.points.MP.max;
      docinput1.$set(docinput1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(docinput0.$$.fragment, local);
      transition_in(docinput1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(docinput0.$$.fragment, local);
      transition_out(docinput1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div13);
      }
      destroy_component(docinput0);
      destroy_component(docinput1);
    }
  };
}
__name(create_fragment$I, "create_fragment$I");
function instance$B($$self, $$props, $$invalidate) {
  let $actor;
  const actor = getContext("#doc");
  component_subscribe($$self, actor, (value) => $$invalidate(0, $actor = value));
  onMount(() => {
  });
  return [$actor, actor];
}
__name(instance$B, "instance$B");
class MP extends SvelteComponent {
  static {
    __name(this, "MP");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$B, create_fragment$I, safe_not_equal, {});
  }
}
function create_fragment$H(ctx) {
  let div8;
  let div4;
  let div1;
  let div0;
  let div3;
  let div2;
  let div7;
  let div6;
  let div5;
  let docinput;
  let current;
  docinput = new DocInput({
    props: {
      class: "wide",
      clickType: "click",
      pulse: true,
      type: "number",
      name: "BP",
      min: "0",
      max: (
        /*$actor*/
        ctx[0].system.points.BP.max
      ),
      valuePath: "system.points.BP.val"
    }
  });
  return {
    c() {
      div8 = element("div");
      div4 = element("div");
      div1 = element("div");
      div0 = element("div");
      div0.textContent = `${localize$1("Types.Actor.Points.BP.short")}`;
      div3 = element("div");
      div2 = element("div");
      div2.textContent = `${localize$1("Types.Actor.Points.BP.Label")}`;
      div7 = element("div");
      div6 = element("div");
      div5 = element("div");
      create_component(docinput.$$.fragment);
      attr(div0, "class", "header svelte-rxqik9");
      attr(div1, "class", "header svelte-rxqik9");
      attr(div2, "class", "header svelte-rxqik9");
      attr(div3, "class", "sub-header svelte-rxqik9");
      attr(div4, "class", "flex3");
      attr(div5, "class", "header svelte-rxqik9");
      attr(div6, "class", "header val svelte-rxqik9");
      attr(div7, "class", "flex2 left");
      attr(div8, "class", "bp flexrow justify-vertical svelte-rxqik9");
    },
    m(target, anchor) {
      insert(target, div8, anchor);
      append(div8, div4);
      append(div4, div1);
      append(div1, div0);
      append(div4, div3);
      append(div3, div2);
      append(div8, div7);
      append(div7, div6);
      append(div6, div5);
      mount_component(docinput, div5, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const docinput_changes = {};
      if (dirty & /*$actor*/
      1)
        docinput_changes.max = /*$actor*/
        ctx2[0].system.points.BP.max;
      docinput.$set(docinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(docinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(docinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div8);
      }
      destroy_component(docinput);
    }
  };
}
__name(create_fragment$H, "create_fragment$H");
function instance$A($$self, $$props, $$invalidate) {
  let $actor;
  const actor = getContext("#doc");
  component_subscribe($$self, actor, (value) => $$invalidate(0, $actor = value));
  onMount(() => {
  });
  return [$actor, actor];
}
__name(instance$A, "instance$A");
class BP extends SvelteComponent {
  static {
    __name(this, "BP");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$A, create_fragment$H, safe_not_equal, {});
  }
}
function create_fragment$G(ctx) {
  let section;
  let div3;
  let div0;
  let hp;
  let div1;
  let mp;
  let div2;
  let bp;
  let current;
  hp = new HP({});
  mp = new MP({});
  bp = new BP({});
  return {
    c() {
      section = element("section");
      div3 = element("div");
      div0 = element("div");
      create_component(hp.$$.fragment);
      div1 = element("div");
      create_component(mp.$$.fragment);
      div2 = element("div");
      create_component(bp.$$.fragment);
      attr(div0, "class", "flex hp pa-md svelte-1bm9vzb");
      attr(div1, "class", "flex mp pa-md svelte-1bm9vzb");
      attr(div2, "class", "flex bp pa-md svelte-1bm9vzb");
      attr(div3, "class", "flexrow section svelte-1bm9vzb");
      attr(section, "class", "organism");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, div3);
      append(div3, div0);
      mount_component(hp, div0, null);
      append(div3, div1);
      mount_component(mp, div1, null);
      append(div3, div2);
      mount_component(bp, div2, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(hp.$$.fragment, local);
      transition_in(mp.$$.fragment, local);
      transition_in(bp.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(hp.$$.fragment, local);
      transition_out(mp.$$.fragment, local);
      transition_out(bp.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      destroy_component(hp);
      destroy_component(mp);
      destroy_component(bp);
    }
  };
}
__name(create_fragment$G, "create_fragment$G");
class PointsSection extends SvelteComponent {
  static {
    __name(this, "PointsSection");
  }
  constructor(options) {
    super();
    init$1(this, options, null, create_fragment$G, safe_not_equal, {});
  }
}
function get_each_context$a(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list[i];
  child_ctx[22] = i;
  return child_ctx;
}
__name(get_each_context$a, "get_each_context$a");
function create_if_block_1$a(ctx) {
  let h2;
  let div;
  let table;
  let each_value = ensure_array_like(
    /*ActiveEffects*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
  }
  return {
    c() {
      h2 = element("h2");
      h2.textContent = `${localize$1("Effects")}`;
      div = element("div");
      table = element("table");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(h2, "class", "font-cinzel");
      attr(table, "class", "borderless low-contrast");
      attr(div, "class", "px-xs");
    },
    m(target, anchor) {
      insert(target, h2, anchor);
      insert(target, div, anchor);
      append(div, table);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(table, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*openItem, ActiveEffects*/
      1) {
        each_value = ensure_array_like(
          /*ActiveEffects*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$a(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$a(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(table, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(h2);
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
__name(create_if_block_1$a, "create_if_block_1$a");
function create_each_block$a(ctx) {
  let tr;
  let th;
  let img;
  let img_src_value;
  let img_alt_value;
  let td;
  let a;
  let t_value = localize$1(
    /*item*/
    ctx[20].name
  ) + "";
  let t;
  let mounted;
  let dispose;
  function click_handler2() {
    return (
      /*click_handler*/
      ctx[6](
        /*index*/
        ctx[22],
        /*item*/
        ctx[20]
      )
    );
  }
  __name(click_handler2, "click_handler");
  function keydown_handler(...args) {
    return (
      /*keydown_handler*/
      ctx[7](
        /*index*/
        ctx[22],
        /*item*/
        ctx[20],
        ...args
      )
    );
  }
  __name(keydown_handler, "keydown_handler");
  return {
    c() {
      tr = element("tr");
      th = element("th");
      img = element("img");
      td = element("td");
      a = element("a");
      t = text(t_value);
      attr(img, "class", "icon");
      if (!src_url_equal(img.src, img_src_value = /*item*/
      ctx[20].img))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*item*/
      ctx[20].name);
      attr(th, "class", "img shrink");
      attr(th, "scope", "col");
      attr(a, "class", "ml-sm stealth link no-wrap");
      attr(a, "role", "button");
      attr(a, "tabindex", "0");
      attr(td, "class", "left");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, th);
      append(th, img);
      append(tr, td);
      append(td, a);
      append(a, t);
      if (!mounted) {
        dispose = [listen(a, "click", click_handler2), listen(a, "keydown", keydown_handler)];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*ActiveEffects*/
      1 && !src_url_equal(img.src, img_src_value = /*item*/
      ctx[20].img)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*ActiveEffects*/
      1 && img_alt_value !== (img_alt_value = /*item*/
      ctx[20].name)) {
        attr(img, "alt", img_alt_value);
      }
      if (dirty & /*ActiveEffects*/
      1 && t_value !== (t_value = localize$1(
        /*item*/
        ctx[20].name
      ) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(tr);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_each_block$a, "create_each_block$a");
function create_if_block$e(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = `${localize$1("NoEffects")}`;
      set_style(p, "margin-top", "-2px");
      set_style(p, "margin-bottom", "0px");
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
__name(create_if_block$e, "create_if_block$e");
function create_fragment$F(ctx) {
  let div;
  let if_block0_anchor;
  let if_block0 = (
    /*ActiveEffects*/
    ctx[0].length > 0 && create_if_block_1$a(ctx)
  );
  let if_block1 = !/*ActiveEffects*/
  ctx[0].length && create_if_block$e();
  return {
    c() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      if_block0_anchor = empty();
      if (if_block1)
        if_block1.c();
      attr(div, "class", "effects svelte-1fqib39");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append(div, if_block0_anchor);
      if (if_block1)
        if_block1.m(div, null);
    },
    p(ctx2, [dirty]) {
      if (
        /*ActiveEffects*/
        ctx2[0].length > 0
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1$a(ctx2);
          if_block0.c();
          if_block0.m(div, if_block0_anchor);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!/*ActiveEffects*/
      ctx2[0].length) {
        if (if_block1)
          ;
        else {
          if_block1 = create_if_block$e();
          if_block1.c();
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
__name(create_fragment$F, "create_fragment$F");
function openItem(index, item) {
  item.sheet.render(true);
}
__name(openItem, "openItem");
function instance$z($$self, $$props, $$invalidate) {
  let ActiveEffects;
  let $doc;
  let $wildcard;
  let $Actor;
  const Actor2 = getContext("#doc");
  component_subscribe($$self, Actor2, (value) => $$invalidate(11, $Actor = value));
  const doc = new TJSDocument($Actor);
  component_subscribe($$self, doc, (value) => $$invalidate(4, $doc = value));
  const triggerSearch = createFilterQuery("trigger");
  const nameSearch = createFilterQuery("label");
  const wildcardConfig = doc.embedded.create(Item, {
    name: "wildcard",
    filters: [nameSearch, triggerSearch]
  });
  let wildcard = doc.embedded.create(ActiveEffect, wildcardConfig);
  component_subscribe($$self, wildcard, (value) => $$invalidate(5, $wildcard = value));
  const click_handler2 = /* @__PURE__ */ __name((index, item) => openItem(index, item), "click_handler");
  const keydown_handler = /* @__PURE__ */ __name((index, item, e) => e.key === "Enter" && openItem(index, item), "keydown_handler");
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$wildcard*/
    32) {
      $$invalidate(0, ActiveEffects = [...$wildcard].filter((effect) => !effect.disabled).map((effect) => {
        return effect;
      }));
    }
    if ($$self.$$.dirty & /*$doc*/
    16) {
      $doc.system.effectActionsLocked ? "lock" : "lock-open";
    }
    if ($$self.$$.dirty & /*$doc*/
    16) {
      $doc.system.effectActionsLocked ? "fa-lock negative" : "fa-lock-open positive";
    }
    if ($$self.$$.dirty & /*$doc*/
    16) {
      parseInt($doc.system.xp?.unspent) || 0;
    }
  };
  return [
    ActiveEffects,
    Actor2,
    doc,
    wildcard,
    $doc,
    $wildcard,
    click_handler2,
    keydown_handler
  ];
}
__name(instance$z, "instance$z");
class EffectsSection extends SvelteComponent {
  static {
    __name(this, "EffectsSection");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$z, create_fragment$F, safe_not_equal, {});
  }
}
function get_each_context$9(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list[i];
  child_ctx[22] = i;
  return child_ctx;
}
__name(get_each_context$9, "get_each_context$9");
function create_if_block$d(ctx) {
  let h2;
  let div;
  let table;
  let tr;
  let th0;
  let th1;
  let th2;
  let current;
  let if_block = (
    /*combat*/
    ctx[1] && create_if_block_3$5()
  );
  let each_value = ensure_array_like(
    /*items*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
  }
  const out = /* @__PURE__ */ __name((i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  }), "out");
  return {
    c() {
      h2 = element("h2");
      h2.textContent = `${localize$1("Tabs.Favourites")}`;
      div = element("div");
      table = element("table");
      tr = element("tr");
      th0 = element("th");
      th1 = element("th");
      th1.textContent = `${localize$1("Name")}`;
      if (if_block)
        if_block.c();
      th2 = element("th");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(h2, "class", "font-cinzel svelte-1i7v647");
      attr(th0, "class", "img shrink svelte-1i7v647");
      attr(th0, "scope", "col");
      attr(th1, "class", "left expand svelte-1i7v647");
      attr(th1, "scope", "col");
      attr(th2, "class", "shrink svelte-1i7v647");
      attr(th2, "scope", "col");
      attr(tr, "class", "svelte-1i7v647");
      attr(table, "class", "borderless low-contrast svelte-1i7v647");
      attr(div, "class", "pa-xs svelte-1i7v647");
    },
    m(target, anchor) {
      insert(target, h2, anchor);
      insert(target, div, anchor);
      append(div, table);
      append(table, tr);
      append(tr, th0);
      append(tr, th1);
      if (if_block)
        if_block.m(tr, null);
      append(tr, th2);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(table, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*combat*/
        ctx2[1]
      ) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_3$5();
          if_block.c();
          if_block.m(tr, th2);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*items, badgeType, remaining, combat, showItemSheet, useItem*/
      454) {
        each_value = ensure_array_like(
          /*items*/
          ctx2[2]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$9(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$9(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(table, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h2);
        detach(div);
      }
      if (if_block)
        if_block.d();
      destroy_each(each_blocks, detaching);
    }
  };
}
__name(create_if_block$d, "create_if_block$d");
function create_if_block_3$5(ctx) {
  let th;
  return {
    c() {
      th = element("th");
      attr(th, "class", "svelte-1i7v647");
    },
    m(target, anchor) {
      insert(target, th, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(th);
      }
    }
  };
}
__name(create_if_block_3$5, "create_if_block_3$5");
function create_if_block_1$9(ctx) {
  let td;
  let current;
  let if_block = (
    /*item*/
    ctx[20].system.hasLimitation && create_if_block_2$7(ctx)
  );
  return {
    c() {
      td = element("td");
      if (if_block)
        if_block.c();
      attr(td, "class", "left svelte-1i7v647");
    },
    m(target, anchor) {
      insert(target, td, anchor);
      if (if_block)
        if_block.m(td, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*item*/
        ctx2[20].system.hasLimitation
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*items*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2$7(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(td, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(td);
      }
      if (if_block)
        if_block.d();
    }
  };
}
__name(create_if_block_1$9, "create_if_block_1$9");
function create_if_block_2$7(ctx) {
  let badge;
  let current;
  badge = new Badge({
    props: {
      type: (
        /*badgeType*/
        ctx[7](
          /*item*/
          ctx[20]
        )
      ),
      $$slots: { default: [create_default_slot$d] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(badge.$$.fragment);
    },
    m(target, anchor) {
      mount_component(badge, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const badge_changes = {};
      if (dirty & /*items*/
      4)
        badge_changes.type = /*badgeType*/
        ctx2[7](
          /*item*/
          ctx2[20]
        );
      if (dirty & /*$$scope, items*/
      8388612) {
        badge_changes.$$scope = { dirty, ctx: ctx2 };
      }
      badge.$set(badge_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(badge.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(badge.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(badge, detaching);
    }
  };
}
__name(create_if_block_2$7, "create_if_block_2$7");
function create_default_slot$d(ctx) {
  let t_value = (
    /*remaining*/
    ctx[8](
      /*item*/
      ctx[20]
    ) + ""
  );
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*items*/
      4 && t_value !== (t_value = /*remaining*/
      ctx2[8](
        /*item*/
        ctx2[20]
      ) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
__name(create_default_slot$d, "create_default_slot$d");
function create_each_block$9(ctx) {
  let tr;
  let td0;
  let img;
  let img_src_value;
  let img_alt_value;
  let td1;
  let a;
  let t_value = (
    /*item*/
    ctx[20].name + ""
  );
  let t;
  let a_class_value;
  let td2;
  let button;
  let i;
  let i_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*combat*/
    ctx[1] && create_if_block_1$9(ctx)
  );
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      img = element("img");
      td1 = element("td");
      a = element("a");
      t = text(t_value);
      if (if_block)
        if_block.c();
      td2 = element("td");
      button = element("button");
      i = element("i");
      attr(img, "class", "icon svelte-1i7v647");
      if (!src_url_equal(img.src, img_src_value = /*item*/
      ctx[20].img))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*item*/
      ctx[20].name);
      attr(td0, "class", "img svelte-1i7v647");
      attr(td0, "role", "button");
      attr(a, "class", a_class_value = "ml-sm stealth link " + /*item*/
      (ctx[20].system.isMagic ? "pulse" : "") + " svelte-1i7v647");
      attr(a, "role", "button");
      attr(td1, "class", "left clip svelte-1i7v647");
      attr(i, "class", i_class_value = "fa-bookmark " + /*item*/
      (ctx[20].system.favourite === true ? "fa-solid" : "fa-regular") + " svelte-1i7v647");
      attr(button, "class", "stealth svelte-1i7v647");
      attr(td2, "class", "svelte-1i7v647");
      attr(tr, "class", "svelte-1i7v647");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, img);
      append(tr, td1);
      append(td1, a);
      append(a, t);
      if (if_block)
        if_block.m(tr, null);
      append(tr, td2);
      append(td2, button);
      append(button, i);
      current = true;
      if (!mounted) {
        dispose = [
          listen(td0, "click", function() {
            if (is_function(
              /*useItem*/
              ctx[6](
                /*item*/
                ctx[20]
              )
            ))
              ctx[6](
                /*item*/
                ctx[20]
              ).apply(this, arguments);
          }),
          listen(a, "click", function() {
            if (is_function(showItemSheet$3(
              /*item*/
              ctx[20]
            )))
              showItemSheet$3(
                /*item*/
                ctx[20]
              ).apply(this, arguments);
          }),
          listen(button, "click", function() {
            if (is_function(toggleBookmark(
              /*item*/
              ctx[20]
            )))
              toggleBookmark(
                /*item*/
                ctx[20]
              ).apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty & /*items*/
      4 && !src_url_equal(img.src, img_src_value = /*item*/
      ctx[20].img)) {
        attr(img, "src", img_src_value);
      }
      if (!current || dirty & /*items*/
      4 && img_alt_value !== (img_alt_value = /*item*/
      ctx[20].name)) {
        attr(img, "alt", img_alt_value);
      }
      if ((!current || dirty & /*items*/
      4) && t_value !== (t_value = /*item*/
      ctx[20].name + ""))
        set_data(t, t_value);
      if (!current || dirty & /*items*/
      4 && a_class_value !== (a_class_value = "ml-sm stealth link " + /*item*/
      (ctx[20].system.isMagic ? "pulse" : "") + " svelte-1i7v647")) {
        attr(a, "class", a_class_value);
      }
      if (
        /*combat*/
        ctx[1]
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & /*combat*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$9(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(tr, td2);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*items*/
      4 && i_class_value !== (i_class_value = "fa-bookmark " + /*item*/
      (ctx[20].system.favourite === true ? "fa-solid" : "fa-regular") + " svelte-1i7v647")) {
        attr(i, "class", i_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(tr);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_each_block$9, "create_each_block$9");
function create_fragment$E(ctx) {
  let div;
  let show_if = (
    /*$doc*/
    ctx[0].system.hasFavouriteItems()
  );
  let current;
  let if_block = show_if && create_if_block$d(ctx);
  let div_levels = [
    { class: "favourites" },
    /*$$restProps*/
    ctx[9]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      set_attributes(div, div_data);
      toggle_class(div, "svelte-1i7v647", true);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$doc*/
      1)
        show_if = /*$doc*/
        ctx2[0].system.hasFavouriteItems();
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$doc*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$d(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        { class: "favourites" },
        dirty & /*$$restProps*/
        512 && /*$$restProps*/
        ctx2[9]
      ]));
      toggle_class(div, "svelte-1i7v647", true);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block)
        if_block.d();
    }
  };
}
__name(create_fragment$E, "create_fragment$E");
function showItemSheet$3(item) {
  item.sheet.render(true);
}
__name(showItemSheet$3, "showItemSheet$3");
function instance$y($$self, $$props, $$invalidate) {
  let items;
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $doc;
  let $wildcard;
  let $Actor;
  const Actor2 = getContext("#doc");
  component_subscribe($$self, Actor2, (value) => $$invalidate(13, $Actor = value));
  const doc = new TJSDocument($Actor);
  component_subscribe($$self, doc, (value) => $$invalidate(0, $doc = value));
  const typeSearch = createFilterQuery("system.favourite");
  typeSearch.set(true);
  const wildcard = doc.embedded.create(Item, {
    name: "wildcard",
    filters: [typeSearch],
    sort: (a, b) => a.name.localeCompare(b.name)
  });
  component_subscribe($$self, wildcard, (value) => $$invalidate(10, $wildcard = value));
  let combat;
  function onCombatUpdate() {
    $$invalidate(1, combat = game.combat);
  }
  __name(onCombatUpdate, "onCombatUpdate");
  onMount(() => {
    $$invalidate(1, combat = game.combat);
    Hooks.on("createCombat", onCombatUpdate);
    Hooks.on("deleteCombat", onCombatUpdate);
    Hooks.on("updateCombat", onCombatUpdate);
    return () => {
      Hooks.off("createCombat", onCombatUpdate);
      Hooks.off("deleteCombat", onCombatUpdate);
      Hooks.off("updateCombat", onCombatUpdate);
    };
  });
  function useItem(item) {
    switch (item.type) {
      case "action":
        new CONFIG.FFXIV.RollCalcActor({ actor: $Actor }).ability(item.type, item);
        break;
      case "trait":
        new CONFIG.FFXIV.RollCalcActor({ actor: $Actor }).ability(item.type, item);
        break;
      case "equipment":
        new CONFIG.FFXIV.RollCalcActor({ actor: $Actor }).equipment(item);
        break;
      case "effect":
        ui.notifications.warn("Effects cannot be used directly");
        break;
      case "job":
        ui.notifications.warn("Jobs cannot be used directly");
        break;
      case "limitbreak":
        new CONFIG.FFXIV.RollCalcActor({ actor: $Actor }).ability(item.type, item);
        break;
      default:
        console.warn(`Unhandled item type: ${item.type}`);
        new CONFIG.FFXIV.RollCalcActor({ actor: $Actor }).send();
    }
  }
  __name(useItem, "useItem");
  const badgeType = /* @__PURE__ */ __name((item) => {
    return item.system.uses >= item.system.limitation ? "danger" : "success";
  }, "badgeType");
  const remaining = /* @__PURE__ */ __name((item) => {
    return item.system.hasLimitation ? parseInt(item.system.limitation || 0) - parseInt(item.system.uses || 0) : 10;
  }, "remaining");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$wildcard*/
    1024) {
      $$invalidate(2, items = [...$wildcard]);
    }
    if ($$self.$$.dirty & /*$doc*/
    1) {
      $doc.system.inventoryLocked ? "lock" : "lock-open";
    }
    if ($$self.$$.dirty & /*$doc*/
    1) {
      $doc.system.inventoryLocked ? "fa-lock negative" : "fa-lock-open positive";
    }
  };
  return [
    $doc,
    combat,
    items,
    Actor2,
    doc,
    wildcard,
    useItem,
    badgeType,
    remaining,
    $$restProps,
    $wildcard
  ];
}
__name(instance$y, "instance$y");
class Favourites extends SvelteComponent {
  static {
    __name(this, "Favourites");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$y, create_fragment$E, safe_not_equal, {});
  }
}
function create_if_block_1$8(ctx) {
  let div5;
  let div4;
  let div0;
  let div3;
  let div2;
  let div1;
  let portraitframe;
  let current;
  portraitframe = new PortraitFrame({
    props: {
      size: "40",
      style: "min-width: 182px;",
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div5 = element("div");
      div4 = element("div");
      div0 = element("div");
      div3 = element("div");
      div2 = element("div");
      div1 = element("div");
      create_component(portraitframe.$$.fragment);
      attr(div0, "class", "texture svelte-43aj1a");
      attr(div1, "class", "portrait-frame pr-xs wide svelte-43aj1a");
      attr(div2, "class", "flex2 wide");
      attr(div3, "class", "flexrow panel borderless wide");
      attr(div4, "class", "background svelte-43aj1a");
      attr(div5, "class", "flexcol navy svelte-43aj1a");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div4);
      append(div4, div0);
      append(div4, div3);
      append(div3, div2);
      append(div2, div1);
      mount_component(portraitframe, div1, null);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(portraitframe.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(portraitframe.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div5);
      }
      destroy_component(portraitframe);
    }
  };
}
__name(create_if_block_1$8, "create_if_block_1$8");
function create_default_slot_3(ctx) {
  let div3;
  let div0;
  let h2;
  let div2;
  let div1;
  let prosemirror;
  let current;
  prosemirror = new ProseMirror$1({
    props: {
      editable: false,
      attr: "system.description"
    }
  });
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      h2 = element("h2");
      h2.textContent = `${localize$1("Description")}`;
      div2 = element("div");
      div1 = element("div");
      create_component(prosemirror.$$.fragment);
      attr(h2, "class", "font-cinzel");
      attr(div0, "class", "flex1");
      attr(div1, "class", "left panel borderless overflow");
      attr(div2, "class", "flex1");
      attr(div3, "class", "flexcol wide gold");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      append(div0, h2);
      append(div3, div2);
      append(div2, div1);
      mount_component(prosemirror, div1, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(prosemirror.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(prosemirror.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      destroy_component(prosemirror);
    }
  };
}
__name(create_default_slot_3, "create_default_slot_3");
function create_default_slot_2(ctx) {
  let div3;
  let div0;
  let h2;
  let div2;
  let div1;
  let pointssection;
  let current;
  pointssection = new PointsSection({});
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      h2 = element("h2");
      h2.textContent = `${localize$1("Points")}`;
      div2 = element("div");
      div1 = element("div");
      create_component(pointssection.$$.fragment);
      attr(h2, "class", "font-cinzel");
      attr(div0, "class", "flex1");
      attr(div1, "class", "left panel borderless overflow");
      attr(div2, "class", "flex1");
      attr(div3, "class", "flexcol wide");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      append(div0, h2);
      append(div3, div2);
      append(div2, div1);
      mount_component(pointssection, div1, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(pointssection.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pointssection.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      destroy_component(pointssection);
    }
  };
}
__name(create_default_slot_2, "create_default_slot_2");
function create_if_block$c(ctx) {
  let div5;
  let div4;
  let div0;
  let div1;
  let div3;
  let div2;
  let portraitframe;
  let current;
  portraitframe = new PortraitFrame({
    props: {
      size: "40",
      style: "min-width: 182px;",
      $$slots: { default: [create_default_slot_1$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div5 = element("div");
      div4 = element("div");
      div0 = element("div");
      div1 = element("div");
      div3 = element("div");
      div2 = element("div");
      create_component(portraitframe.$$.fragment);
      attr(div0, "class", "texture svelte-43aj1a");
      attr(div1, "class", "flexrow panel borderless wide");
      attr(div2, "class", "portrait-frame pr-xs svelte-43aj1a");
      attr(div3, "class", "flex2 gold");
      attr(div4, "class", "background svelte-43aj1a");
      attr(div5, "class", "flexcol burgundy svelte-43aj1a");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div4);
      append(div4, div0);
      append(div4, div1);
      append(div4, div3);
      append(div3, div2);
      mount_component(portraitframe, div2, null);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(portraitframe.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(portraitframe.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div5);
      }
      destroy_component(portraitframe);
    }
  };
}
__name(create_if_block$c, "create_if_block$c");
function create_default_slot_1$1(ctx) {
  let favourites;
  let current;
  favourites = new Favourites({ props: { class: "high wide" } });
  return {
    c() {
      create_component(favourites.$$.fragment);
    },
    m(target, anchor) {
      mount_component(favourites, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(favourites.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(favourites.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(favourites, detaching);
    }
  };
}
__name(create_default_slot_1$1, "create_default_slot_1$1");
function create_default_slot$c(ctx) {
  let effectssection;
  let current;
  effectssection = new EffectsSection({ props: { class: "high wide" } });
  return {
    c() {
      create_component(effectssection.$$.fragment);
    },
    m(target, anchor) {
      mount_component(effectssection, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(effectssection.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(effectssection.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(effectssection, detaching);
    }
  };
}
__name(create_default_slot$c, "create_default_slot$c");
function create_fragment$D(ctx) {
  let div15;
  let div14;
  let div0;
  let attributesection;
  let div13;
  let div6;
  let div5;
  let div1;
  let div4;
  let div3;
  let div2;
  let portraitframe0;
  let show_if = (
    /*$actor*/
    ctx[0].system.hasFavouriteItems()
  );
  let div12;
  let div11;
  let div7;
  let div10;
  let div9;
  let div8;
  let portraitframe1;
  let current;
  attributesection = new AttributeSection$1({});
  let if_block0 = (
    /*$actor*/
    ctx[0].system.description.length > 0 && create_if_block_1$8(ctx)
  );
  portraitframe0 = new PortraitFrame({
    props: {
      size: "40",
      style: "min-width: 182px;",
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    }
  });
  let if_block1 = show_if && create_if_block$c(ctx);
  portraitframe1 = new PortraitFrame({
    props: {
      size: "40",
      style: "min-width: 182px;",
      $$slots: { default: [create_default_slot$c] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div15 = element("div");
      div14 = element("div");
      div0 = element("div");
      create_component(attributesection.$$.fragment);
      if (if_block0)
        if_block0.c();
      div13 = element("div");
      div6 = element("div");
      div5 = element("div");
      div1 = element("div");
      div4 = element("div");
      div3 = element("div");
      div2 = element("div");
      create_component(portraitframe0.$$.fragment);
      if (if_block1)
        if_block1.c();
      div12 = element("div");
      div11 = element("div");
      div7 = element("div");
      div10 = element("div");
      div9 = element("div");
      div8 = element("div");
      create_component(portraitframe1.$$.fragment);
      attr(div0, "class", "flex3");
      attr(div1, "class", "texture svelte-43aj1a");
      attr(div2, "class", "portrait-frame pr-xs wide svelte-43aj1a");
      attr(div3, "class", "flex2 wide");
      attr(div4, "class", "flexrow panel borderless wide");
      attr(div5, "class", "background svelte-43aj1a");
      attr(div6, "class", "flexcol purple svelte-43aj1a");
      attr(div7, "class", "texture svelte-43aj1a");
      attr(div8, "class", "portrait-frame pr-xs svelte-43aj1a");
      attr(div9, "class", "flex2 gold");
      attr(div10, "class", "flexrow panel borderless wide");
      attr(div11, "class", "background svelte-43aj1a");
      attr(div12, "class", "flexcol teal svelte-43aj1a");
      attr(div13, "class", "flex2");
      attr(div14, "class", "flexrow high");
      attr(div15, "class", "panel overflow");
    },
    m(target, anchor) {
      insert(target, div15, anchor);
      append(div15, div14);
      append(div14, div0);
      mount_component(attributesection, div0, null);
      if (if_block0)
        if_block0.m(div0, null);
      append(div14, div13);
      append(div13, div6);
      append(div6, div5);
      append(div5, div1);
      append(div5, div4);
      append(div4, div3);
      append(div3, div2);
      mount_component(portraitframe0, div2, null);
      if (if_block1)
        if_block1.m(div13, null);
      append(div13, div12);
      append(div12, div11);
      append(div11, div7);
      append(div11, div10);
      append(div10, div9);
      append(div9, div8);
      mount_component(portraitframe1, div8, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*$actor*/
        ctx2[0].system.description.length > 0
      ) {
        if (if_block0) {
          if (dirty & /*$actor*/
          1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1$8(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const portraitframe0_changes = {};
      if (dirty & /*$$scope*/
      4) {
        portraitframe0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portraitframe0.$set(portraitframe0_changes);
      if (dirty & /*$actor*/
      1)
        show_if = /*$actor*/
        ctx2[0].system.hasFavouriteItems();
      if (show_if) {
        if (if_block1) {
          if (dirty & /*$actor*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$c(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div13, div12);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      const portraitframe1_changes = {};
      if (dirty & /*$$scope*/
      4) {
        portraitframe1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portraitframe1.$set(portraitframe1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(attributesection.$$.fragment, local);
      transition_in(if_block0);
      transition_in(portraitframe0.$$.fragment, local);
      transition_in(if_block1);
      transition_in(portraitframe1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(attributesection.$$.fragment, local);
      transition_out(if_block0);
      transition_out(portraitframe0.$$.fragment, local);
      transition_out(if_block1);
      transition_out(portraitframe1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div15);
      }
      destroy_component(attributesection);
      if (if_block0)
        if_block0.d();
      destroy_component(portraitframe0);
      if (if_block1)
        if_block1.d();
      destroy_component(portraitframe1);
    }
  };
}
__name(create_fragment$D, "create_fragment$D");
function instance$x($$self, $$props, $$invalidate) {
  let $actor;
  const actor = getContext("#doc");
  component_subscribe($$self, actor, (value) => $$invalidate(0, $actor = value));
  return [$actor, actor];
}
__name(instance$x, "instance$x");
let Attributes$1 = class Attributes extends SvelteComponent {
  static {
    __name(this, "Attributes");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$x, create_fragment$D, safe_not_equal, {});
  }
};
function create_fragment$C(ctx) {
  let h10;
  let div2;
  let div0;
  let label;
  let div1;
  let docinput;
  let h11;
  let prosemirror0;
  let h12;
  let prosemirror1;
  let current;
  docinput = new DocInput({
    props: {
      class: "wide",
      id: "character-name",
      name: "name",
      valuePath: "name"
    }
  });
  prosemirror0 = new ProseMirror$1({
    props: {
      classes: (
        /*proseMirrorClasses*/
        ctx[0]
      ),
      attr: "system.description"
    }
  });
  prosemirror1 = new ProseMirror$1({
    props: {
      classes: (
        /*proseMirrorClasses2*/
        ctx[1]
      ),
      attr: "system.biography"
    }
  });
  return {
    c() {
      h10 = element("h1");
      h10.textContent = `${localize$1("Details")}`;
      div2 = element("div");
      div0 = element("div");
      label = element("label");
      label.textContent = `${localize$1("Character")} ${localize$1("Name")}:`;
      div1 = element("div");
      create_component(docinput.$$.fragment);
      h11 = element("h1");
      h11.textContent = `${localize$1("Description")}`;
      create_component(prosemirror0.$$.fragment);
      h12 = element("h1");
      h12.textContent = `${localize$1("Notes")}`;
      create_component(prosemirror1.$$.fragment);
      attr(h10, "class", "gold");
      attr(label, "class", "gold");
      attr(label, "for", "character-name");
      attr(div0, "class", "flex2");
      attr(div1, "class", "flex2 wide");
      attr(div2, "class", "flexrow justify-vertical");
      attr(h11, "class", "gold");
      attr(h12, "class", "gold");
    },
    m(target, anchor) {
      insert(target, h10, anchor);
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, label);
      append(div2, div1);
      mount_component(docinput, div1, null);
      insert(target, h11, anchor);
      mount_component(prosemirror0, target, anchor);
      insert(target, h12, anchor);
      mount_component(prosemirror1, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(docinput.$$.fragment, local);
      transition_in(prosemirror0.$$.fragment, local);
      transition_in(prosemirror1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(docinput.$$.fragment, local);
      transition_out(prosemirror0.$$.fragment, local);
      transition_out(prosemirror1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h10);
        detach(div2);
        detach(h11);
        detach(h12);
      }
      destroy_component(docinput);
      destroy_component(prosemirror0, detaching);
      destroy_component(prosemirror1, detaching);
    }
  };
}
__name(create_fragment$C, "create_fragment$C");
function instance$w($$self) {
  const proseMirrorClasses = ["left", "small"];
  const proseMirrorClasses2 = ["left"];
  return [proseMirrorClasses, proseMirrorClasses2];
}
__name(instance$w, "instance$w");
class Profile extends SvelteComponent {
  static {
    __name(this, "Profile");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$w, create_fragment$C, safe_not_equal, {});
  }
}
function get_each_context$8(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i];
  child_ctx[18] = i;
  return child_ctx;
}
__name(get_each_context$8, "get_each_context$8");
function create_if_block$b(ctx) {
  let button0;
  let button1;
  let button2;
  let mounted;
  let dispose;
  return {
    c() {
      button0 = element("button");
      button0.innerHTML = `<i class="left fa fa-edit"></i>`;
      button1 = element("button");
      button1.innerHTML = `<i class="left fa fa-copy"></i>`;
      button2 = element("button");
      button2.innerHTML = `<i class="left fa fa-trash"></i>`;
      attr(button0, "class", "stealth");
      attr(button0, "data-tooltip", localize$1("Types.Actor.ActionButtons.Edit"));
      attr(button1, "class", "stealth");
      attr(button1, "data-tooltip", localize$1("Types.Actor.ActionButtons.Duplicate"));
      attr(button2, "class", "stealth");
      attr(button2, "data-tooltip", localize$1("Types.Actor.ActionButtons.Delete"));
    },
    m(target, anchor) {
      insert(target, button0, anchor);
      insert(target, button1, anchor);
      insert(target, button2, anchor);
      if (!mounted) {
        dispose = [
          listen(button0, "click", function() {
            if (is_function(editItem$2(
              /*item*/
              ctx[16]
            )))
              editItem$2(
                /*item*/
                ctx[16]
              ).apply(this, arguments);
          }),
          listen(button1, "click", function() {
            if (is_function(
              /*duplicateItem*/
              ctx[7](
                /*index*/
                ctx[18],
                /*item*/
                ctx[16]
              )
            ))
              ctx[7](
                /*index*/
                ctx[18],
                /*item*/
                ctx[16]
              ).apply(this, arguments);
          }),
          listen(button2, "click", function() {
            if (is_function(
              /*deleteItem*/
              ctx[9](
                /*index*/
                ctx[18],
                /*item*/
                ctx[16]
              )
            ))
              ctx[9](
                /*index*/
                ctx[18],
                /*item*/
                ctx[16]
              ).apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching) {
        detach(button0);
        detach(button1);
        detach(button2);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_if_block$b, "create_if_block$b");
function create_each_block$8(ctx) {
  let tr;
  let td0;
  let img;
  let img_src_value;
  let img_alt_value;
  let td1;
  let a;
  let t0_value = (
    /*item*/
    ctx[16].name + ""
  );
  let t0;
  let a_class_value;
  let td2;
  let button0;
  let t1_value = (
    /*item*/
    ctx[16].system.quantity + ""
  );
  let t1;
  let td3;
  let button1;
  let i;
  let i_class_value;
  let td4;
  let mounted;
  let dispose;
  let if_block = !/*$doc*/
  ctx[0].system.inventoryLocked && create_if_block$b(ctx);
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      img = element("img");
      td1 = element("td");
      a = element("a");
      t0 = text(t0_value);
      td2 = element("td");
      button0 = element("button");
      t1 = text(t1_value);
      td3 = element("td");
      button1 = element("button");
      i = element("i");
      td4 = element("td");
      if (if_block)
        if_block.c();
      attr(img, "class", "icon");
      if (!src_url_equal(img.src, img_src_value = /*item*/
      ctx[16].img))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*item*/
      ctx[16].name);
      attr(td0, "class", "img");
      attr(td0, "data-tooltip", localize$1("Use"));
      attr(td0, "role", "button");
      attr(a, "class", a_class_value = "stealth link " + /*item*/
      (ctx[16].system.isMagic ? "pulse" : "") + " svelte-1xqs78");
      attr(a, "role", "button");
      attr(td1, "class", "left");
      attr(td1, "data-tooltip", localize$1("View"));
      attr(button0, "class", "stealth clickable wide svelte-1xqs78");
      attr(button0, "data-tooltip", "Left click + / Right Click -");
      attr(i, "class", i_class_value = "fa-bookmark " + /*item*/
      (ctx[16].system.favourite === true ? "fa-solid" : "fa-regular") + " svelte-1xqs78");
      attr(button1, "class", "stealth");
      attr(td3, "data-tooltip", localize$1("Bookmark"));
      attr(td4, "class", "min buttons right");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, img);
      append(tr, td1);
      append(td1, a);
      append(a, t0);
      append(tr, td2);
      append(td2, button0);
      append(button0, t1);
      append(tr, td3);
      append(td3, button1);
      append(button1, i);
      append(tr, td4);
      if (if_block)
        if_block.m(td4, null);
      if (!mounted) {
        dispose = [
          listen(td0, "click", function() {
            if (is_function(
              /*useItem*/
              ctx[10](
                /*item*/
                ctx[16]
              )
            ))
              ctx[10](
                /*item*/
                ctx[16]
              ).apply(this, arguments);
          }),
          listen(a, "click", function() {
            if (is_function(showItemSheet$2(
              /*item*/
              ctx[16]
            )))
              showItemSheet$2(
                /*item*/
                ctx[16]
              ).apply(this, arguments);
          }),
          listen(button0, "click", function() {
            if (is_function(addQuantity(
              /*item*/
              ctx[16]
            )))
              addQuantity(
                /*item*/
                ctx[16]
              ).apply(this, arguments);
          }),
          listen(button0, "contextmenu", function() {
            if (is_function(removeQuantity(
              /*item*/
              ctx[16]
            )))
              removeQuantity(
                /*item*/
                ctx[16]
              ).apply(this, arguments);
          }),
          listen(button1, "click", function() {
            if (is_function(toggleBookmark(
              /*item*/
              ctx[16]
            )))
              toggleBookmark(
                /*item*/
                ctx[16]
              ).apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*items*/
      8 && !src_url_equal(img.src, img_src_value = /*item*/
      ctx[16].img)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*items*/
      8 && img_alt_value !== (img_alt_value = /*item*/
      ctx[16].name)) {
        attr(img, "alt", img_alt_value);
      }
      if (dirty & /*items*/
      8 && t0_value !== (t0_value = /*item*/
      ctx[16].name + ""))
        set_data(t0, t0_value);
      if (dirty & /*items*/
      8 && a_class_value !== (a_class_value = "stealth link " + /*item*/
      (ctx[16].system.isMagic ? "pulse" : "") + " svelte-1xqs78")) {
        attr(a, "class", a_class_value);
      }
      if (dirty & /*items*/
      8 && t1_value !== (t1_value = /*item*/
      ctx[16].system.quantity + ""))
        set_data(t1, t1_value);
      if (dirty & /*items*/
      8 && i_class_value !== (i_class_value = "fa-bookmark " + /*item*/
      (ctx[16].system.favourite === true ? "fa-solid" : "fa-regular") + " svelte-1xqs78")) {
        attr(i, "class", i_class_value);
      }
      if (!/*$doc*/
      ctx[0].system.inventoryLocked) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block$b(ctx);
          if_block.c();
          if_block.m(td4, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(tr);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_each_block$8, "create_each_block$8");
function create_fragment$B(ctx) {
  let div1;
  let div0;
  let h1;
  let table;
  let tr;
  let th0;
  let th1;
  let th2;
  let th3;
  let th4;
  let button0;
  let i1;
  let i1_class_value;
  let button0_class_value;
  let th4_class_value;
  let button1;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*items*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      h1 = element("h1");
      h1.textContent = `${localize$1("Inventory")}`;
      table = element("table");
      tr = element("tr");
      th0 = element("th");
      th1 = element("th");
      th1.textContent = `${localize$1("Name")}`;
      th2 = element("th");
      th2.textContent = `${localize$1("Quantity")}`;
      th3 = element("th");
      th3.innerHTML = `<i class="fa-solid fa-bookmark svelte-1xqs78"></i>`;
      th4 = element("th");
      button0 = element("button");
      i1 = element("i");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      button1 = element("button");
      button1.textContent = `${localize$1("Instructions.RemoveAll")}`;
      attr(h1, "class", "gold");
      attr(th0, "class", "img shrink");
      attr(th0, "scope", "col");
      attr(th1, "class", "left expand");
      attr(th1, "scope", "col");
      attr(th2, "class", "fixed");
      attr(th2, "scope", "col");
      attr(th3, "class", "shrink");
      attr(th3, "scope", "col");
      attr(i1, "class", i1_class_value = "fa " + /*faLockCSS*/
      ctx[1] + " svelte-1xqs78");
      attr(button0, "class", button0_class_value = "stealth " + /*lockCSS*/
      ctx[2] + " svelte-1xqs78");
      attr(th4, "class", th4_class_value = null_to_empty(
        /*lockCSS*/
        ctx[2]
      ) + " svelte-1xqs78");
      attr(th4, "scope", "col");
      attr(tr, "class", "gold");
      attr(table, "class", "borderless");
      attr(div0, "class", "padded svelte-1xqs78");
      attr(button1, "class", "mt-sm glossy-button gold-light hover-shine");
      attr(div1, "class", "panel overflow containerx svelte-1xqs78");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, h1);
      append(div0, table);
      append(table, tr);
      append(tr, th0);
      append(tr, th1);
      append(tr, th2);
      append(tr, th3);
      append(tr, th4);
      append(th4, button0);
      append(button0, i1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(table, null);
        }
      }
      append(div1, button1);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*toggleLock*/
            ctx[11]
          ),
          listen(
            button1,
            "click",
            /*removeAllItems*/
            ctx[8]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*faLockCSS*/
      2 && i1_class_value !== (i1_class_value = "fa " + /*faLockCSS*/
      ctx2[1] + " svelte-1xqs78")) {
        attr(i1, "class", i1_class_value);
      }
      if (dirty & /*lockCSS*/
      4 && button0_class_value !== (button0_class_value = "stealth " + /*lockCSS*/
      ctx2[2] + " svelte-1xqs78")) {
        attr(button0, "class", button0_class_value);
      }
      if (dirty & /*lockCSS*/
      4 && th4_class_value !== (th4_class_value = null_to_empty(
        /*lockCSS*/
        ctx2[2]
      ) + " svelte-1xqs78")) {
        attr(th4, "class", th4_class_value);
      }
      if (dirty & /*deleteItem, items, duplicateItem, editItem, $doc, addQuantity, removeQuantity, showItemSheet, useItem*/
      1673) {
        each_value = ensure_array_like(
          /*items*/
          ctx2[3]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$8(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$8(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(table, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_fragment$B, "create_fragment$B");
function editItem$2(item) {
  item.sheet.render(true);
  game.system.log.d("editItem");
  game.system.log.d(item);
}
__name(editItem$2, "editItem$2");
function addQuantity(item) {
  game.system.log.d("addQuantity");
  game.system.log.d(item);
  const quantity = item.system.quantity + 1;
  item.update({ system: { quantity } });
}
__name(addQuantity, "addQuantity");
function removeQuantity(item) {
  const quantity = item.system.quantity - 1;
  item.update({ system: { quantity } });
}
__name(removeQuantity, "removeQuantity");
function showItemSheet$2(item) {
  item.sheet.render(true);
}
__name(showItemSheet$2, "showItemSheet$2");
function instance$v($$self, $$props, $$invalidate) {
  let items;
  let lockCSS;
  let faLockCSS;
  let $doc;
  let $wildcard;
  let $Actor;
  const Actor2 = getContext("#doc");
  component_subscribe($$self, Actor2, (value) => $$invalidate(13, $Actor = value));
  const doc = new TJSDocument($Actor);
  component_subscribe($$self, doc, (value) => $$invalidate(0, $doc = value));
  const typeSearch = createFilterQuery("type");
  typeSearch.set(["equipment"]);
  const wildcard = doc.embedded.create(Item, {
    name: "wildcard",
    filters: [typeSearch],
    sort: (a, b) => a.name.localeCompare(b.name)
  });
  component_subscribe($$self, wildcard, (value) => $$invalidate(12, $wildcard = value));
  function duplicateItem(item) {
    game.system.log.d("duplicateItem");
    game.system.log.d(item);
    const itemData = item.toObject();
    delete itemData._id;
    game.system.log.d("itemData", itemData);
    $Actor.sheet._onDropItemCreate(itemData);
  }
  __name(duplicateItem, "duplicateItem");
  async function removeAllItems() {
    const okToDelete = confirm(localize$1("Types.Actor.Inventory.confirmDeleteAll"));
    if (okToDelete) {
      await $Actor.deleteAllItems("equipment");
    }
  }
  __name(removeAllItems, "removeAllItems");
  function deleteItem(index, item) {
    let okToDelete = true;
    if (game.settings.get(SYSTEM_ID, "confirmBeforeDeletingActorItem")) {
      okToDelete = confirm(localize$1("Types.Actor.Inventory.confirmDeleteItem"));
    }
    if (okToDelete) {
      item.delete();
    }
  }
  __name(deleteItem, "deleteItem");
  function useItem(item) {
    new CONFIG.FFXIV.RollCalcActor({ actor: $Actor }).equipment(item);
  }
  __name(useItem, "useItem");
  function toggleLock(event) {
    game.system.log.d("a");
    event.stopPropagation();
    event.preventDefault();
    $doc.update(
      {
        ["system.inventoryLocked"]: !$doc.system.inventoryLocked
      },
      {
        diff: true,
        diffData: true,
        diffSystem: true
      }
    );
  }
  __name(toggleLock, "toggleLock");
  onMount(async () => {
  });
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$wildcard*/
    4096) {
      $$invalidate(3, items = [...$wildcard]);
    }
    if ($$self.$$.dirty & /*$doc*/
    1) {
      $$invalidate(2, lockCSS = $doc.system.inventoryLocked ? "lock" : "lock-open");
    }
    if ($$self.$$.dirty & /*$doc*/
    1) {
      $$invalidate(1, faLockCSS = $doc.system.inventoryLocked ? "fa-lock negative" : "fa-lock-open positive");
    }
  };
  return [
    $doc,
    faLockCSS,
    lockCSS,
    items,
    Actor2,
    doc,
    wildcard,
    duplicateItem,
    removeAllItems,
    deleteItem,
    useItem,
    toggleLock,
    $wildcard
  ];
}
__name(instance$v, "instance$v");
class Inventory extends SvelteComponent {
  static {
    __name(this, "Inventory");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$v, create_fragment$B, safe_not_equal, {});
  }
}
function get_each_context$7(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[33] = list[i];
  child_ctx[35] = i;
  return child_ctx;
}
__name(get_each_context$7, "get_each_context$7");
function create_if_block_4$2(ctx) {
  let th;
  return {
    c() {
      th = element("th");
      th.textContent = `${localize$1("Origin")}`;
      attr(th, "class", "left shrink");
      attr(th, "scope", "col");
    },
    m(target, anchor) {
      insert(target, th, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(th);
      }
    }
  };
}
__name(create_if_block_4$2, "create_if_block_4$2");
function create_if_block_2$6(ctx) {
  let td;
  let show_if;
  function select_block_type(ctx2, dirty) {
    if (dirty[0] & /*ActiveEffects*/
    2)
      show_if = null;
    if (show_if == null)
      show_if = !!/*effect*/
      ctx2[33].getFlag(SYSTEM_ID, "transferredBy.actor.img");
    if (show_if)
      return create_if_block_3$4;
    return create_else_block$1;
  }
  __name(select_block_type, "select_block_type");
  let current_block_type = select_block_type(ctx, [-1, -1]);
  let if_block = current_block_type(ctx);
  return {
    c() {
      td = element("td");
      if_block.c();
      attr(td, "class", "img left");
    },
    m(target, anchor) {
      insert(target, td, anchor);
      if_block.m(td, null);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(td, null);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(td);
      }
      if_block.d();
    }
  };
}
__name(create_if_block_2$6, "create_if_block_2$6");
function create_else_block$1(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = `${localize$1("Unknown")}`;
      attr(span, "class", "no-wrap");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
__name(create_else_block$1, "create_else_block$1");
function create_if_block_3$4(ctx) {
  let img;
  let img_src_value;
  let img_data_tooltip_value;
  return {
    c() {
      img = element("img");
      attr(img, "class", "icon nopointer");
      if (!src_url_equal(img.src, img_src_value = /*effect*/
      ctx[33].getFlag(SYSTEM_ID, "transferredBy.actor.img")))
        attr(img, "src", img_src_value);
      attr(img, "alt", "avatar for effect origin");
      attr(img, "data-tooltip", img_data_tooltip_value = /*effect*/
      ctx[33].getFlag(SYSTEM_ID, "transferredBy.actor.name"));
      attr(img, "data-tooltip-class", "FFXIV-tooltip");
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*ActiveEffects*/
      2 && !src_url_equal(img.src, img_src_value = /*effect*/
      ctx2[33].getFlag(SYSTEM_ID, "transferredBy.actor.img"))) {
        attr(img, "src", img_src_value);
      }
      if (dirty[0] & /*ActiveEffects*/
      2 && img_data_tooltip_value !== (img_data_tooltip_value = /*effect*/
      ctx2[33].getFlag(SYSTEM_ID, "transferredBy.actor.name"))) {
        attr(img, "data-tooltip", img_data_tooltip_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
__name(create_if_block_3$4, "create_if_block_3$4");
function create_if_block_1$7(ctx) {
  let button0;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      button0 = element("button");
      button0.innerHTML = `<i class="left fa fa-edit"></i>`;
      button1 = element("button");
      button1.innerHTML = `<i class="left fa fa-trash"></i>`;
      attr(button0, "class", "stealth");
      attr(button1, "class", "stealth");
    },
    m(target, anchor) {
      insert(target, button0, anchor);
      insert(target, button1, anchor);
      if (!mounted) {
        dispose = [
          listen(button0, "click", function() {
            if (is_function(editItem$1(
              /*index*/
              ctx[35],
              /*effect*/
              ctx[33]
            )))
              editItem$1(
                /*index*/
                ctx[35],
                /*effect*/
                ctx[33]
              ).apply(this, arguments);
          }),
          listen(button1, "click", function() {
            if (is_function(
              /*deleteItem*/
              ctx[9](
                /*index*/
                ctx[35],
                /*effect*/
                ctx[33]
              )
            ))
              ctx[9](
                /*index*/
                ctx[35],
                /*effect*/
                ctx[33]
              ).apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching) {
        detach(button0);
        detach(button1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_if_block_1$7, "create_if_block_1$7");
function create_each_block$7(ctx) {
  let tr;
  let td0;
  let img;
  let img_class_value;
  let img_src_value;
  let td1;
  let t_value = (
    /*effect*/
    ctx[33].name + ""
  );
  let t;
  let td2;
  let tr_class_value;
  let if_block0 = (
    /*parentIsActor*/
    ctx[7] && create_if_block_2$6(ctx)
  );
  let if_block1 = !/*$doc*/
  ctx[0].system.effectActionsLocked && /*showDelete*/
  ctx[6] && create_if_block_1$7(ctx);
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      img = element("img");
      td1 = element("td");
      t = text(t_value);
      if (if_block0)
        if_block0.c();
      td2 = element("td");
      if (if_block1)
        if_block1.c();
      attr(img, "class", img_class_value = "icon " + /*effect*/
      (ctx[33].isSuppressed ? "suspended" : "active"));
      if (!src_url_equal(img.src, img_src_value = /*effect*/
      ctx[33].img))
        attr(img, "src", img_src_value);
      attr(img, "alt", "avatar for game version");
      attr(td0, "class", "img");
      attr(td1, "class", "left expand no-wrap");
      attr(td2, "class", "buttons right no-wrap");
      attr(tr, "class", tr_class_value = null_to_empty(
        /*effect*/
        ctx[33].disabled ? "disabled" : ""
      ) + " svelte-1af8azc");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, img);
      append(tr, td1);
      append(td1, t);
      if (if_block0)
        if_block0.m(tr, null);
      append(tr, td2);
      if (if_block1)
        if_block1.m(td2, null);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*ActiveEffects*/
      2 && img_class_value !== (img_class_value = "icon " + /*effect*/
      (ctx2[33].isSuppressed ? "suspended" : "active"))) {
        attr(img, "class", img_class_value);
      }
      if (dirty[0] & /*ActiveEffects*/
      2 && !src_url_equal(img.src, img_src_value = /*effect*/
      ctx2[33].img)) {
        attr(img, "src", img_src_value);
      }
      if (dirty[0] & /*ActiveEffects*/
      2 && t_value !== (t_value = /*effect*/
      ctx2[33].name + ""))
        set_data(t, t_value);
      if (
        /*parentIsActor*/
        ctx2[7]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2$6(ctx2);
          if_block0.c();
          if_block0.m(tr, td2);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!/*$doc*/
      ctx2[0].system.effectActionsLocked && /*showDelete*/
      ctx2[6]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1$7(ctx2);
          if_block1.c();
          if_block1.m(td2, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty[0] & /*ActiveEffects*/
      2 && tr_class_value !== (tr_class_value = null_to_empty(
        /*effect*/
        ctx2[33].disabled ? "disabled" : ""
      ) + " svelte-1af8azc")) {
        attr(tr, "class", tr_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(tr);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
__name(create_each_block$7, "create_each_block$7");
function create_if_block$a(ctx) {
  let div;
  let button0;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button0 = element("button");
      button0.textContent = `${localize$1("Instructions.AddEffect")}`;
      button1 = element("button");
      button1.textContent = `${localize$1("Instructions.RemoveAllEffects")}`;
      attr(button0, "class", "glossy-button gold-light hover-shine no-wrap");
      attr(button1, "class", "glossy-button gold-light hover-shine no-wrap");
      attr(div, "class", "flexrow mt-sm");
      set_style(div, "justify-content", "space-evenly");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      append(div, button1);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*openActiveEffectEditor*/
            ctx[12]
          ),
          listen(
            button1,
            "click",
            /*removeAllEffects*/
            ctx[10]
          )
        ];
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_if_block$a, "create_if_block$a");
function create_fragment$A(ctx) {
  let div1;
  let div0;
  let h1;
  let table;
  let tr;
  let th0;
  let th1;
  let th2;
  let button;
  let i;
  let i_class_value;
  let button_class_value;
  let th2_class_value;
  let mounted;
  let dispose;
  let if_block0 = (
    /*parentIsActor*/
    ctx[7] && create_if_block_4$2()
  );
  let each_value = ensure_array_like(
    /*ActiveEffects*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$7(get_each_context$7(ctx, each_value, i2));
  }
  let if_block1 = (
    /*showAddRemoveButtons*/
    ctx[5] && create_if_block$a(ctx)
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      h1 = element("h1");
      h1.textContent = `${localize$1("Effects")}`;
      table = element("table");
      tr = element("tr");
      th0 = element("th");
      th1 = element("th");
      th1.textContent = `${localize$1("Name")}`;
      if (if_block0)
        if_block0.c();
      th2 = element("th");
      button = element("button");
      i = element("i");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      if (if_block1)
        if_block1.c();
      attr(h1, "class", "gold");
      attr(th0, "class", "img shrink");
      attr(th0, "scope", "col");
      attr(th1, "class", "left expand ml-sm");
      attr(th1, "scope", "col");
      attr(i, "class", i_class_value = "fa " + /*faLockCSS*/
      ctx[3] + " svelte-1af8azc");
      attr(button, "class", button_class_value = "stealth " + /*lockCSS*/
      ctx[4] + " svelte-1af8azc");
      attr(th2, "class", th2_class_value = "buttons " + /*lockCSS*/
      ctx[4] + " svelte-1af8azc");
      attr(th2, "scope", "col");
      attr(tr, "class", "gold");
      attr(table, "class", "borderless even");
      attr(div0, "class", "padded");
      attr(div1, "class", "panel overflow containerx");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, h1);
      append(div0, table);
      append(table, tr);
      append(tr, th0);
      append(tr, th1);
      if (if_block0)
        if_block0.m(tr, null);
      append(tr, th2);
      append(th2, button);
      append(button, i);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(table, null);
        }
      }
      if (if_block1)
        if_block1.m(div0, null);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*toggleLock*/
          ctx[11]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (
        /*parentIsActor*/
        ctx2[7]
      ) {
        if (if_block0)
          ;
        else {
          if_block0 = create_if_block_4$2();
          if_block0.c();
          if_block0.m(tr, th2);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty[0] & /*faLockCSS*/
      8 && i_class_value !== (i_class_value = "fa " + /*faLockCSS*/
      ctx2[3] + " svelte-1af8azc")) {
        attr(i, "class", i_class_value);
      }
      if (dirty[0] & /*lockCSS*/
      16 && button_class_value !== (button_class_value = "stealth " + /*lockCSS*/
      ctx2[4] + " svelte-1af8azc")) {
        attr(button, "class", button_class_value);
      }
      if (dirty[0] & /*lockCSS*/
      16 && th2_class_value !== (th2_class_value = "buttons " + /*lockCSS*/
      ctx2[4] + " svelte-1af8azc")) {
        attr(th2, "class", th2_class_value);
      }
      if (dirty[0] & /*ActiveEffects, deleteItem, $doc, showDelete, parentIsActor*/
      707) {
        each_value = ensure_array_like(
          /*ActiveEffects*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$7(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$7(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(table, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (
        /*showAddRemoveButtons*/
        ctx2[5]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$a(ctx2);
          if_block1.c();
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (if_block0)
        if_block0.d();
      destroy_each(each_blocks, detaching);
      if (if_block1)
        if_block1.d();
      mounted = false;
      dispose();
    }
  };
}
__name(create_fragment$A, "create_fragment$A");
function editItem$1(index, item) {
  game.system.log.d(item);
  item.sheet.render(true);
}
__name(editItem$1, "editItem$1");
function instance$u($$self, $$props, $$invalidate) {
  let parentIsActor;
  let isActorSheet;
  let isGM;
  let showDelete;
  let showAddRemoveButtons;
  let lockCSS;
  let faLockCSS;
  let $doc;
  let $wildcard, $$unsubscribe_wildcard = noop, $$subscribe_wildcard = /* @__PURE__ */ __name(() => ($$unsubscribe_wildcard(), $$unsubscribe_wildcard = subscribe(wildcard, ($$value) => $$invalidate(17, $wildcard = $$value)), wildcard), "$$subscribe_wildcard");
  $$self.$$.on_destroy.push(() => $$unsubscribe_wildcard());
  let { sheet } = $$props;
  function resetEffectList() {
    game.system.log.d("resetEffectList");
    filterDoc = new TJSDocument($doc);
    $$subscribe_wildcard($$invalidate(2, wildcard = filterDoc.embedded.create(ActiveEffect, wildcardConfig)));
  }
  __name(resetEffectList, "resetEffectList");
  let ActiveEffects = [];
  const doc = getContext("#doc");
  component_subscribe($$self, doc, (value) => $$invalidate(0, $doc = value));
  getContext("#external").application;
  const triggerSearch = createFilterQuery("trigger");
  const nameSearch = createFilterQuery("label");
  const wildcardConfig = {
    name: "wildcard",
    filters: [nameSearch, triggerSearch]
  };
  let filterDoc = new TJSDocument($doc);
  let wildcard = filterDoc.embedded.create(ActiveEffect, wildcardConfig);
  $$subscribe_wildcard();
  async function deleteItem(index, effect) {
    if (isPassiveEffectFromItem(effect)) {
      ui.notifications.warn("This effect is granted by an item. To remove the effect, you can remove the item.");
      return;
    }
    await effect.delete();
    resetEffectList();
  }
  __name(deleteItem, "deleteItem");
  async function removeAllEffects() {
    await Dialog.confirm({
      title: "Remove All Effects",
      content: "Are you sure you want to remove all effects?",
      yes: async () => {
        for (let effect of $doc.effects) {
          await effect.delete();
        }
      },
      no: () => {
      }
    });
  }
  __name(removeAllEffects, "removeAllEffects");
  function isPassiveEffectFromItem(item) {
    game.system.log.d("isPassiveEffectFromItem item", item);
    if (item instanceof ActiveEffect) {
      const origin = getEffectOrigin(item, true);
      const parent = item.parent;
      if (parent instanceof Actor && origin instanceof Item && item.isTransferred) {
        return true;
      }
    }
    return false;
  }
  __name(isPassiveEffectFromItem, "isPassiveEffectFromItem");
  function toggleLock(event) {
    $doc.update(
      {
        ["system.effectActionsLocked"]: !$doc.system.effectActionsLocked
      },
      {
        diff: true,
        diffData: true,
        diffSystem: true
      }
    );
  }
  __name(toggleLock, "toggleLock");
  async function openActiveEffectEditor() {
    game.system.log.d("openActiveEffectEditor");
    const effect = await ActiveEffect.create(
      {
        label: $doc.name,
        icon: $doc.img,
        // For pre-v12 compatibility
        img: $doc.img,
        // For v12+
        origin: $doc.uuid,
        renderSheet: true,
        flags: { [SYSTEM_ID]: {} }
      },
      { parent: $doc }
    );
    game.system.log.d("effect", effect);
  }
  __name(openActiveEffectEditor, "openActiveEffectEditor");
  onMount(() => {
    Hooks.on("createActiveEffect", resetEffectList);
    Hooks.on("deleteActiveEffect", resetEffectList);
    Hooks.on("updateActiveEffect", resetEffectList);
    game.system.log.d("EffectsTab mounted");
    game.system.log.d(ActiveEffects);
  });
  onDestroy(() => {
    Hooks.off("createActiveEffect", resetEffectList);
    Hooks.off("deleteActiveEffect", resetEffectList);
    Hooks.off("updateActiveEffect", resetEffectList);
  });
  $$self.$$set = ($$props2) => {
    if ("sheet" in $$props2)
      $$invalidate(13, sheet = $$props2.sheet);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*$doc, sheet*/
    8193) {
      $$invalidate(7, parentIsActor = isParentActor($doc) || sheet && sheet.includes("actor"));
    }
    if ($$self.$$.dirty[0] & /*sheet*/
    8192) {
      $$invalidate(16, isActorSheet = sheet === "actor");
    }
    if ($$self.$$.dirty[0] & /*isActorSheet, isGM*/
    98304) {
      $$invalidate(6, showDelete = !isActorSheet || isGM);
    }
    if ($$self.$$.dirty[0] & /*isActorSheet, isGM*/
    98304) {
      $$invalidate(5, showAddRemoveButtons = !isActorSheet || isGM);
    }
    if ($$self.$$.dirty[0] & /*$wildcard*/
    131072) {
      $$invalidate(1, ActiveEffects = [...$wildcard].map((effect) => {
        return effect;
      }));
    }
    if ($$self.$$.dirty[0] & /*$doc*/
    1) {
      $$invalidate(4, lockCSS = $doc.system.effectActionsLocked ? "lock" : "lock-open");
    }
    if ($$self.$$.dirty[0] & /*$doc*/
    1) {
      $$invalidate(3, faLockCSS = $doc.system.effectActionsLocked ? "fa-lock negative" : "fa-lock-open positive");
    }
    if ($$self.$$.dirty[0] & /*$doc*/
    1) {
      parseInt($doc.system.xp?.unspent) || 0;
    }
  };
  $$invalidate(15, isGM = game.user.isGM);
  return [
    $doc,
    ActiveEffects,
    wildcard,
    faLockCSS,
    lockCSS,
    showAddRemoveButtons,
    showDelete,
    parentIsActor,
    doc,
    deleteItem,
    removeAllEffects,
    toggleLock,
    openActiveEffectEditor,
    sheet,
    resetEffectList,
    isGM,
    isActorSheet,
    $wildcard
  ];
}
__name(instance$u, "instance$u");
class EffectsTab extends SvelteComponent {
  static {
    __name(this, "EffectsTab");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$u, create_fragment$A, safe_not_equal, { sheet: 13, resetEffectList: 14 }, null, [-1, -1]);
  }
  get sheet() {
    return this.$$.ctx[13];
  }
  set sheet(sheet) {
    this.$$set({ sheet });
    flush();
  }
  get resetEffectList() {
    return this.$$.ctx[14];
  }
}
function create_default_slot$b(ctx) {
  let tabs_1;
  let current;
  tabs_1 = new Tabs({
    props: {
      class: "tabs tall",
      tabs: (
        /*tabs*/
        ctx[3]
      ),
      activeTab: activeTab$1,
      sheet: "['actor', 'PC']"
    }
  });
  return {
    c() {
      create_component(tabs_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tabs_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tabs_1_changes = {};
      if (dirty & /*tabs*/
      8)
        tabs_1_changes.tabs = /*tabs*/
        ctx2[3];
      tabs_1.$set(tabs_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tabs_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tabs_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tabs_1, detaching);
    }
  };
}
__name(create_default_slot$b, "create_default_slot$b");
function create_fragment$z(ctx) {
  let applicationshell;
  let updating_elementRoot;
  let updating_stylesApp;
  let current;
  function applicationshell_elementRoot_binding(value) {
    ctx[7](value);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  function applicationshell_stylesApp_binding(value) {
    ctx[8](value);
  }
  __name(applicationshell_stylesApp_binding, "applicationshell_stylesApp_binding");
  let applicationshell_props = {
    $$slots: { default: [create_default_slot$b] },
    $$scope: { ctx }
  };
  if (
    /*elementRoot*/
    ctx[0] !== void 0
  ) {
    applicationshell_props.elementRoot = /*elementRoot*/
    ctx[0];
  }
  if (
    /*stylesApp*/
    ctx[2] !== void 0
  ) {
    applicationshell_props.stylesApp = /*stylesApp*/
    ctx[2];
  }
  applicationshell = new ApplicationShell({ props: applicationshell_props });
  binding_callbacks.push(() => bind(applicationshell, "elementRoot", applicationshell_elementRoot_binding));
  binding_callbacks.push(() => bind(applicationshell, "stylesApp", applicationshell_stylesApp_binding));
  return {
    c() {
      create_component(applicationshell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(applicationshell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const applicationshell_changes = {};
      if (dirty & /*$$scope, tabs*/
      65544) {
        applicationshell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_elementRoot && dirty & /*elementRoot*/
      1) {
        updating_elementRoot = true;
        applicationshell_changes.elementRoot = /*elementRoot*/
        ctx2[0];
        add_flush_callback(() => updating_elementRoot = false);
      }
      if (!updating_stylesApp && dirty & /*stylesApp*/
      4) {
        updating_stylesApp = true;
        applicationshell_changes.stylesApp = /*stylesApp*/
        ctx2[2];
        add_flush_callback(() => updating_stylesApp = false);
      }
      applicationshell.$set(applicationshell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applicationshell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applicationshell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applicationshell, detaching);
    }
  };
}
__name(create_fragment$z, "create_fragment$z");
let activeTab$1 = "attributes";
function instance$t($$self, $$props, $$invalidate) {
  let tabs;
  let $documentStore, $$unsubscribe_documentStore = noop, $$subscribe_documentStore = /* @__PURE__ */ __name(() => ($$unsubscribe_documentStore(), $$unsubscribe_documentStore = subscribe(documentStore, ($$value) => $$invalidate(9, $documentStore = $$value)), documentStore), "$$subscribe_documentStore");
  let $applicationWindowHeaderIconsOnly;
  let $headerButtonNoLabel;
  $$self.$$.on_destroy.push(() => $$unsubscribe_documentStore());
  let { elementRoot } = $$props;
  let { documentStore } = $$props;
  $$subscribe_documentStore();
  setContext("#doc", documentStore);
  const application = getContext("#external").application;
  const applicationWindowHeaderIconsOnly2 = gameSettings.getStore("applicationWindowHeaderIconsOnly");
  component_subscribe($$self, applicationWindowHeaderIconsOnly2, (value) => $$invalidate(6, $applicationWindowHeaderIconsOnly = value));
  let headerButtonNoLabel = application.reactive.storeAppOptions.headerButtonNoLabel;
  component_subscribe($$self, headerButtonNoLabel, (value) => $$invalidate(10, $headerButtonNoLabel = value));
  const defaultTabs = [
    {
      label: localize$1("Tabs.Attributes"),
      id: "attributes",
      component: Attributes$1,
      img: "/systems/foundryvtt-final-fantasy/assets/icons/tabs/tree.webp"
    },
    {
      label: localize$1("Tabs.Abilities"),
      id: "abilities",
      component: Abilities$1,
      img: "/systems/foundryvtt-final-fantasy/assets/icons/tabs/sun.webp"
    },
    {
      label: localize$1("Tabs.Inventory"),
      id: "inventory",
      component: Inventory,
      img: "/systems/foundryvtt-final-fantasy/assets/icons/tabs/backpack.webp"
    },
    {
      label: localize$1("Tabs.Profile"),
      id: "profile",
      component: Profile,
      img: "/systems/foundryvtt-final-fantasy/assets/icons/tabs/mask.webp"
    },
    {
      label: localize$1("Tabs.Effects"),
      id: "effect",
      component: EffectsTab,
      img: "/systems/foundryvtt-final-fantasy/assets/icons/tabs/spiral.webp"
    }
  ];
  let stylesApp;
  onMount(async () => {
    game.system.log.d($documentStore);
  });
  function applicationshell_elementRoot_binding(value) {
    elementRoot = value;
    $$invalidate(0, elementRoot);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  function applicationshell_stylesApp_binding(value) {
    stylesApp = value;
    $$invalidate(2, stylesApp);
  }
  __name(applicationshell_stylesApp_binding, "applicationshell_stylesApp_binding");
  $$self.$$set = ($$props2) => {
    if ("elementRoot" in $$props2)
      $$invalidate(0, elementRoot = $$props2.elementRoot);
    if ("documentStore" in $$props2)
      $$subscribe_documentStore($$invalidate(1, documentStore = $$props2.documentStore));
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$applicationWindowHeaderIconsOnly*/
    64) {
      set_store_value(headerButtonNoLabel, $headerButtonNoLabel = $applicationWindowHeaderIconsOnly, $headerButtonNoLabel);
    }
  };
  $$invalidate(3, tabs = defaultTabs);
  return [
    elementRoot,
    documentStore,
    stylesApp,
    tabs,
    applicationWindowHeaderIconsOnly2,
    headerButtonNoLabel,
    $applicationWindowHeaderIconsOnly,
    applicationshell_elementRoot_binding,
    applicationshell_stylesApp_binding
  ];
}
__name(instance$t, "instance$t");
class PCSheetShell extends SvelteComponent {
  static {
    __name(this, "PCSheetShell");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$t, create_fragment$z, safe_not_equal, { elementRoot: 0, documentStore: 1 });
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(elementRoot) {
    this.$$set({ elementRoot });
    flush();
  }
  get documentStore() {
    return this.$$.ctx[1];
  }
  set documentStore(documentStore) {
    this.$$set({ documentStore });
    flush();
  }
}
function create_fragment$y(ctx) {
  let applicationshell;
  let updating_elementRoot;
  let current;
  function applicationshell_elementRoot_binding(value) {
    ctx[1](value);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  let applicationshell_props = {};
  if (
    /*elementRoot*/
    ctx[0] !== void 0
  ) {
    applicationshell_props.elementRoot = /*elementRoot*/
    ctx[0];
  }
  applicationshell = new ApplicationShell({ props: applicationshell_props });
  binding_callbacks.push(() => bind(applicationshell, "elementRoot", applicationshell_elementRoot_binding));
  return {
    c() {
      create_component(applicationshell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(applicationshell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const applicationshell_changes = {};
      if (!updating_elementRoot && dirty & /*elementRoot*/
      1) {
        updating_elementRoot = true;
        applicationshell_changes.elementRoot = /*elementRoot*/
        ctx2[0];
        add_flush_callback(() => updating_elementRoot = false);
      }
      applicationshell.$set(applicationshell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applicationshell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applicationshell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applicationshell, detaching);
    }
  };
}
__name(create_fragment$y, "create_fragment$y");
function instance$s($$self, $$props, $$invalidate) {
  let { elementRoot } = $$props;
  function applicationshell_elementRoot_binding(value) {
    elementRoot = value;
    $$invalidate(0, elementRoot);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  $$self.$$set = ($$props2) => {
    if ("elementRoot" in $$props2)
      $$invalidate(0, elementRoot = $$props2.elementRoot);
  };
  return [elementRoot, applicationshell_elementRoot_binding];
}
__name(instance$s, "instance$s");
class DocumentShell extends SvelteComponent {
  static {
    __name(this, "DocumentShell");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$s, create_fragment$y, safe_not_equal, { elementRoot: 0 });
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(elementRoot) {
    this.$$set({ elementRoot });
    flush();
  }
}
class SvelteDocumentSheet extends SvelteApplication {
  static {
    __name(this, "SvelteDocumentSheet");
  }
  /**
   * Document store that monitors updates to any assigned document.
   * @type {TJSDocument<foundry.abstract.Document>}
   */
  #documentStore = new TJSDocument(void 0, { delete: this.close.bind(this) });
  /**
   * Holds the document unsubscription function.
   * @type {Function}
   */
  #storeUnsubscribe;
  /**
   * Creates a new instance of the document sheet
   * @param {object} object - The object to initialize with
   */
  constructor(object) {
    super(object);
    Object.defineProperty(this.reactive, "document", {
      get: () => this.#documentStore.get(),
      set: (document2) => {
        this.#documentStore.set(document2);
      }
    });
    this.reactive.document = object;
    game.system.log.d("isEditing", this.reactive.document.system.isEditing);
  }
  /**
   * Default Application options
   * @return {object} options - Application options.
   * @see https://foundryvtt.com/api/Application.html#options
   */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      title: "No Document Assigned",
      width: 800,
      height: 600,
      resizable: true,
      minimizable: true,
      dragDrop: [{ dragSelector: ".directory-list .item", dropSelector: null }],
      svelte: {
        class: DocumentShell,
        target: document.body,
        // You can assign a function that is invoked with MyItemApp instance as `this`.
        props: function() {
          return {
            documentStore: this.#documentStore
            /* document: this.reactive.document */
            /* @deprecated: useful to know about but confusing to use in the template */
          };
        }
      }
    });
  }
  /**
   * Gets the header buttons for the sheet
   * @return {Array<object>} Returns an array of button configurations for the sheet header
   */
  _getHeaderButtons() {
    const buttons = super._getHeaderButtons();
    buttons.unshift({
      class: "configure-sheet",
      icon: "fas fa-cog",
      title: "open sheet configurator",
      onclick: (ev) => this._onConfigureSheet(ev)
    });
    return buttons;
  }
  /**
   * Handles sheet configuration
   * @param {Event} event - The triggering event
   * @return {void} Nothing
   */
  _onConfigureSheet(event) {
    if (event) {
      event.preventDefault();
    }
    new DocumentSheetConfig(this.reactive.document, {
      top: this.position.top + 40,
      left: this.position.left + (this.position.width - SvelteDocumentSheet.defaultOptions.width) / 2
    }).render(true);
  }
  /**
   * Closes the sheet
   * @param {object} options - Options for closing
   * @return {Promise<void>} Returns a promise that resolves when the sheet is closed
   */
  async close(options = {}) {
    await super.close(options);
    if (this.#storeUnsubscribe) {
      this.#storeUnsubscribe();
      this.#storeUnsubscribe = void 0;
    }
  }
  /**
   * Handles document updates
   * @param {foundry.abstract.Document} doc - The document being updated
   * @param {object} options - Update options
   * @return {Promise<void>} Returns a promise that resolves when the document is updated
   */
  async #handleDocUpdate(doc, options) {
    const { action } = options;
    if ((action === void 0 || action === "update" || action === "subscribe") && doc) {
      this.reactive.title = doc?.isToken ? `[Token] ${doc?.name}` : doc?.name ?? "No Document Assigned";
    }
  }
  /**
   * Prepares base data for the sheet
   * @return {Promise<void>} Returns a promise that resolves when the base data is prepared
   */
  async prepareBaseData() {
  }
  /**
   * Renders the sheet
   * @param {boolean} force - Whether to force render
   * @param {object} options - Render options
   * @return {this} Returns the sheet instance for method chaining
   */
  render(force = false, options = {}) {
    if (!this.#storeUnsubscribe) {
      this.#storeUnsubscribe = this.#documentStore.subscribe(this.#handleDocUpdate.bind(this));
    }
    super.render(force, options);
    return this;
  }
}
let FFXIVActorSheet$1 = class FFXIVActorSheet extends SvelteDocumentSheet {
  static {
    __name(this, "FFXIVActorSheet");
  }
  /**
   * Default Application options
   * @return {object} The default options for configuring the application window - Application options.
   * @see https://foundryvtt.com/api/Application.html#options
   */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      id: `${SYSTEM_ID}--actor-sheet-${generateRandomElementId()}`,
      width: 440,
      height: 828,
      minHeight: 180,
      minWidth: 282,
      // id: `${SYSTEM_ID}--actor-sheet`, // @deprecated: I don't know why we need an ID for this? And having a non-unique ID causes https://github.com/geoidesic/foundryvtt-final-fantasy/issues/8
      classes: [SYSTEM_CODE],
      headerButtonNoLabel: game.settings.get(SYSTEM_ID, "applicationWindowHeaderIconsOnly") || false,
      //- @why: without this the initial value on first load of this app after a page refresh will be wrong, despite a reactive setting in the .svelte template; I don't really know why
      dragDrop: [{ dragSelector: ".directory-list .item", dropSelector: null }],
      svelte: {
        class: PCSheetShell,
        target: document.body
      }
    });
  }
  /**
   * Closes the actor sheet and updates editing state
   * @param {object} options - Options which affect how the window is closed
   * @return {Promise<void>} Returns a promise that resolves when the sheet is closed
   */
  async close(options = {}) {
    this.reactive.document?.update({ system: { isEditing: false } });
    await super.close(options);
  }
  /**
   * Gets the header buttons configuration for the sheet
   * @return {Array<object>} Returns an array of button configurations for the sheet header
   */
  _getHeaderButtons() {
    const buttons = super._getHeaderButtons();
    const canConfigure = game.user.isGM || this.reactive.document.isOwner && game.user.can("TOKEN_CONFIGURE");
    if (this.reactive.document.documentName === "Actor") {
      if (canConfigure) {
        buttons.unshift({
          label: this.token ? "Token" : "TOKEN.TitlePrototype",
          class: "configure-token",
          icon: "fas fa-user-circle",
          onclick: (ev) => this._onConfigureToken(ev)
        });
      }
    }
    const canEdit = game.user.isGM || this.reactive.document.isOwner;
    if (canEdit) {
      buttons.unshift({
        label: localize$1("Types.Actor.HeaderButtons.Edit"),
        class: "edit-sheet" + (this.reactive.document.system.isEditing ? " active" : ""),
        icon: "fas " + (this.reactive.document.system.isEditing ? "fa-toggle-on" : "fa-toggle-off"),
        // onclick: (ev) => this._onToggleEdit(ev),
        onPress: (ev) => {
          this._onToggleEdit(ev);
        }
      });
    }
    return buttons;
  }
  /**
   * Handles toggling the edit mode of the sheet
   * @param {Event} event - The triggering event
   * @return {Promise<void>} Returns a promise that resolves when the edit mode is toggled
   */
  async _onToggleEdit(event) {
    game.system.log.p("[TOGGLE EDIT] _onToggleEdit event", event);
    if (event?.event) {
      event.event.preventDefault();
    }
    await this.reactive.document.update({ system: { isEditing: !this.reactive.document.system.isEditing } });
    this.render();
  }
  /**
   * Opens the token configuration application
   * @param {Event} event - The triggering event
   * @return {void}
   */
  _onConfigureToken(event) {
    if (event) {
      event.preventDefault();
    }
    const actor = this.reactive.document;
    const token = actor.isToken ? actor.token : actor.prototypeToken;
    new CONFIG.Token.prototypeSheetClass(token, {
      left: Math.max(this.position.left - 560 - 10, 10),
      top: this.position.top
    }).render(true);
  }
  /**
   * Determines if dragging can start from the given selector
   * @param {string} selector - The selector to check
   * @return {boolean} Whether dragging can start
   */
  _canDragStart(selector) {
    return true;
  }
  /**
   * Determines if drag and drop is allowed
   * @param {string} selector - The selector to check
   * @return {boolean} Whether drag and drop is allowed
   */
  _canDragDrop(selector) {
    return this.reactive.document.isOwner || game.user.isGM;
  }
  /**
   * Handles drag over events
   * @param {DragEvent} event - The drag event
   * @return {void}
   */
  _onDragOver(event) {
  }
  /**
   * Handles the start of a drag operation
   * @param {DragEvent} event - The drag event
   * @return {void}
   */
  _onDragStart(event) {
    {
      const li = event.currentTarget;
      if (event.target.classList.contains("content-link")) {
        return;
      }
      let dragData;
      if (li.dataset.itemId) {
        const item = this.actor.items.get(li.dataset.itemId);
        dragData = item.toDragData();
      }
      if (li.dataset.effectId) {
        const effect = this.actor.effects.get(li.dataset.effectId);
        dragData = effect.toDragData();
      }
      if (!dragData) {
        return;
      }
      event.dataTransfer.setData("text/plain", JSON.stringify(dragData));
    }
  }
  /**
   * Handles dropping content onto the sheet
   * @param {DragEvent} event - The drop event
   * @return {Promise<void|boolean|ActiveEffect|Item>} The result of the drop operation
   */
  async _onDrop(event) {
    const data = TextEditor.getDragEventData(event);
    const actor = this.reactive.document;
    if (actor.documentName !== "Actor") {
      return;
    }
    const allowed = Hooks.call("dropActorSheetData", actor, this, data);
    if (allowed === false) {
      return;
    }
    switch (data.type) {
      case "ActiveEffect": {
        return await this._onDropActiveEffect(event, data);
      }
      case "Actor": {
        return await this._onDropActor(event, data);
      }
      case "Item": {
        return await this._onDropItem(event, data);
      }
      case "Folder": {
        return await this._onDropFolder(event, data);
      }
      default: {
        log.e(`Impossible type "${data.type}" in _onDrop.`);
        return;
      }
    }
  }
  /**
   * Handles dropping an active effect onto the sheet
   * @param {DragEvent} event - The drop event
   * @param {object} data - The dropped data
   * @return {Promise<boolean|ActiveEffect>} The created effect or false if failed
   */
  async _onDropActiveEffect(event, data) {
    const actor = this.reactive.document;
    const effect = await ActiveEffect.implementation.fromDropData(data);
    if (!actor.isOwner || !effect) {
      return false;
    }
    if (actor.uuid === effect.parent.uuid) {
      return false;
    }
    return ActiveEffect.create(effect.toObject(), { parent: actor });
  }
  /**
   * Handles dropping an actor onto the sheet
   * @param {DragEvent} event - The drop event
   * @param {object} data - The dropped data
   * @return {Promise<boolean>} Whether the drop was successful
   */
  async _onDropActor(event, data) {
    const actor = this.reactive.document;
    if (!actor.isOwner) {
      return false;
    }
  }
  /**
   * Handles dropping an item onto the sheet
   * @param {DragEvent} event - The drop event
   * @param {object} data - The dropped data
   * @param {boolean} ignoreValidation - Whether to ignore validation
   * @return {Promise<boolean|Item>} The created item or false if the operation failed
   */
  async _onDropItem(event, data, ignoreValidation = false) {
    const actor = this.reactive.document;
    if (!actor.isOwner) {
      ui.notifications.error(localize$1(`${SYSTEM_CODE}.Errors.NotOwner`));
      return false;
    }
    const droppedItem = await fromUuid(data.uuid);
    if (droppedItem.type === "job") {
      return this._onDropJob(event, data);
    }
    if (droppedItem.type === "effect") {
      ui.notifications.error(localize$1(`${SYSTEM_CODE}.Errors.EffectItemsNotAllowed`));
      return false;
    }
    const duplicate = actor.items.find((x) => x.name == droppedItem.name && x.type == droppedItem.type);
    if (duplicate) {
      await duplicate.update({ system: { quantity: duplicate.system.quantity + 1 } });
      ui.notifications.info(`Found matching item "${duplicate.name}" and incremented quantity.`);
      return;
    }
    const item = await Item.implementation.fromDropData(data);
    const itemData = item.toObject();
    if (actor.uuid === item.parent?.uuid) {
      return this._onSortItem(event, itemData);
    }
    return this._onDropItemCreate(itemData);
  }
  /**
   * Handles dropping a folder onto the sheet
   * @param {DragEvent} event - The drop event
   * @param {object} data - The dropped data
   * @return {Promise<Array>} Array of created items
   */
  async _onDropFolder(event, data) {
    game.system.log.o("[DROP FOLDER] Starting folder drop:", {
      event,
      data
    });
    const actor = this.reactive.document;
    if (!actor.isOwner) {
      game.system.log.w("[DROP FOLDER] Not owner, exiting");
      return [];
    }
    const folder = await Folder.implementation.fromDropData(data);
    game.system.log.o("[DROP FOLDER] Retrieved folder:", {
      folder,
      name: folder?.name,
      contents: folder?.contents,
      children: folder?.children
    });
    if (!folder) {
      game.system.log.w("[DROP FOLDER] No folder found");
      return [];
    }
    const items = [];
    let foundJob = false;
    const processItems = /* @__PURE__ */ __name(async (contents) => {
      game.system.log.o("[DROP FOLDER] Processing contents:", {
        count: contents?.length,
        items: contents?.map((i) => ({ name: i.name, type: i.type }))
      });
      if (!contents?.length)
        return;
      if (!foundJob) {
        for (const item of contents) {
          if (item.type === "job") {
            game.system.log.o("[DROP FOLDER] Found job:", item.name);
            await this._onDropJob(event, { uuid: item.uuid });
            foundJob = true;
            break;
          }
        }
      }
      for (const item of contents) {
        if (item.type !== "job") {
          game.system.log.o("[DROP FOLDER] Processing non-job item:", {
            name: item.name,
            type: item.type
          });
          items.push(item);
        }
      }
    }, "processItems");
    if (folder.contents?.length) {
      game.system.log.o("[DROP FOLDER] Processing main folder contents");
      await processItems(folder.contents);
    }
    if (folder.children?.length) {
      game.system.log.o("[DROP FOLDER] Found subfolders:", folder.children.length);
      for (const child of folder.children) {
        game.system.log.o("[DROP FOLDER] Processing subfolder:", {
          name: child.name,
          entries: child.entries?.length
        });
        if (child.entries?.length) {
          await processItems(child.entries);
        }
      }
    }
    if (items.length) {
      game.system.log.o("[DROP FOLDER] Creating items:", {
        count: items.length,
        items: items.map((i) => ({ name: i.name, type: i.type }))
      });
      for (const item of items) {
        await this._onDropItem(event, item, true);
      }
    }
    return items;
  }
  /**
   * Handles dropping a job onto the sheet
   * @param {DragEvent} event - The drop event
   * @param {object} data - The dropped data
   * @return {Promise<boolean|void>} Whether the drop was successful
   */
  async _onDropJob(event, data) {
    const actor = this.reactive.document;
    if (!actor.isOwner) {
      return false;
    }
    const job = await fromUuid(data.uuid);
    const grants = job.system.grants;
    const grantItems = [];
    const failedUuids = [];
    const existingUuids = new Set(actor.items.map((item) => item.uuid));
    game.system.log.d("_onDropJob: Job grants:", grants);
    for (const grantObject of grants.list) {
      game.system.log.d("_onDropJob: Processing grant:", grantObject);
      let grantItem;
      if (grantObject.uuid.startsWith("Item.")) {
        grantItem = game.items.get(grantObject.uuid.replace("Item.", ""));
        game.system.log.d("_onDropJob: Attempting to find world item:", grantItem);
      } else {
        grantItem = await fromUuid(grantObject.uuid);
        game.system.log.d("_onDropJob: Attempting to find compendium item:", grantItem);
      }
      if (!grantItem) {
        game.system.log.w(`_onDropJob: Failed to find item with UUID: ${grantObject.uuid}`);
        failedUuids.push(grantObject.uuid);
        continue;
      }
      if (!existingUuids.has(grantItem.uuid)) {
        grantItems.push(grantItem);
        existingUuids.add(grantItem.uuid);
      }
    }
    if (failedUuids.length > 0) {
      game.system.log.g("ItemBucket:_onDropJob: Failed Uuids:", failedUuids);
      const confirmed = await Dialog.confirm({
        title: "Missing Items Found",
        content: `
          <p>The following items could not be found:</p>
          <p>${failedUuids.join("<br>")}</p>
          <p>Would you like to remove these invalid references from the job?</p>
        `,
        yes: () => true,
        no: () => false
      });
      if (confirmed) {
        const jobToUpdate = await fromUuid(data.uuid);
        const updatedGrants = {
          ...jobToUpdate.system.grants,
          list: jobToUpdate.system.grants.list.filter((g) => !failedUuids.includes(g.uuid))
        };
        await jobToUpdate.update({
          "system.grants": updatedGrants
        });
        ui.notifications.info(`Removed ${failedUuids.length} invalid references from job.`);
      } else {
        ui.notifications.error(`Job import cancelled due to missing items.`);
        return false;
      }
    }
    if (grantItems.length > 0) {
      await actor.createEmbeddedDocuments("Item", grantItems);
    }
    await actor.update({
      system: {
        job: {
          uuid: job.uuid,
          name: job.name,
          grants: grants.list,
          level: job.system.level,
          role: job.system.role,
          img: job.img
        }
      }
    });
  }
  /**
   * Creates new items from dropped data
   * @param {object|Array} itemData - The item data to create
   * @return {Promise<void>} Returns a promise that resolves when the items have been created
   */
  async _onDropItemCreate(itemData) {
    itemData = itemData instanceof Array ? itemData : [itemData];
    const actor = this.reactive.document;
    for (const v of itemData) {
      await actor.createEmbeddedDocuments("Item", [v]);
    }
  }
  /**
   * Handles sorting items within the actor's inventory
   * @param {Event} event - The triggering event
   * @param {object} itemData - The item data being sorted
   * @return {Promise<Item[]>} The updated array of sorted items
   */
  _onSortItem(event, itemData) {
    const actor = this.reactive.document;
    const items = actor.items;
    const source = items.get(itemData._id);
    const dropTarget = event.target.closest("[data-item-id]");
    const target = items.get(dropTarget.dataset.itemId);
    if (source.id === target.id) {
      return;
    }
    const siblings = [];
    for (const el of dropTarget.parentElement.children) {
      const siblingId = el.dataset.itemId;
      if (siblingId && siblingId !== source.id) {
        siblings.push(items.get(el.dataset.itemId));
      }
    }
    const sortUpdates = SortingHelpers.performIntegerSort(source, { target, siblings });
    const updateData = sortUpdates.map((u) => {
      const update2 = u.update;
      update2._id = u.target.data._id;
      return update2;
    });
    return actor.updateEmbeddedDocuments("Item", updateData);
  }
};
function get_each_context$6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i];
  child_ctx[25] = i;
  return child_ctx;
}
__name(get_each_context$6, "get_each_context$6");
function create_if_block_3$3(ctx) {
  let h1;
  let table;
  let tr;
  let th0;
  let img;
  let img_src_value;
  let img_alt_value;
  let th1;
  let t1_value = ucfirst(
    /*$Actor*/
    ctx[0].system.job?.name
  ) + "";
  let t1;
  let th2;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      h1 = element("h1");
      h1.textContent = `${localize$1("Job")}`;
      table = element("table");
      tr = element("tr");
      th0 = element("th");
      img = element("img");
      th1 = element("th");
      t1 = text(t1_value);
      th2 = element("th");
      button = element("button");
      button.innerHTML = `<i class="fa-solid fa-trash"></i>`;
      attr(h1, "class", "left gold");
      attr(img, "class", "icon");
      if (!src_url_equal(img.src, img_src_value = /*$Actor*/
      ctx[0].system.job?.img))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*$Actor*/
      ctx[0].system.job?.img);
      attr(th0, "class", "img shrink");
      attr(th0, "scope", "col");
      attr(th1, "class", "left expand");
      attr(th1, "scope", "col");
      attr(th1, "role", "button");
      attr(button, "class", "stealth");
      attr(th2, "class", "buttons");
      attr(th2, "scope", "col");
      attr(table, "class", "borderless");
    },
    m(target, anchor) {
      insert(target, h1, anchor);
      insert(target, table, anchor);
      append(table, tr);
      append(tr, th0);
      append(th0, img);
      append(tr, th1);
      append(th1, t1);
      append(tr, th2);
      append(th2, button);
      if (!mounted) {
        dispose = [
          listen(th1, "click", function() {
            if (is_function(showItemSheet$1(
              /*$Actor*/
              ctx[0].system.job
            )))
              showItemSheet$1(
                /*$Actor*/
                ctx[0].system.job
              ).apply(this, arguments);
          }),
          listen(
            button,
            "click",
            /*deleteJob*/
            ctx[14]
          )
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$Actor*/
      1 && !src_url_equal(img.src, img_src_value = /*$Actor*/
      ctx[0].system.job?.img)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*$Actor*/
      1 && img_alt_value !== (img_alt_value = /*$Actor*/
      ctx[0].system.job?.img)) {
        attr(img, "alt", img_alt_value);
      }
      if (dirty & /*$Actor*/
      1 && t1_value !== (t1_value = ucfirst(
        /*$Actor*/
        ctx[0].system.job?.name
      ) + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(h1);
        detach(table);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_if_block_3$3, "create_if_block_3$3");
function create_if_block_2$5(ctx) {
  let span;
  let badge;
  let current;
  badge = new Badge({
    props: {
      type: (
        /*badgeType*/
        ctx[15](
          /*item*/
          ctx[23]
        )
      ),
      $$slots: { default: [create_default_slot$a] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      span = element("span");
      create_component(badge.$$.fragment);
      attr(span, "class", "ml-sm");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      mount_component(badge, span, null);
      current = true;
    },
    p(ctx2, dirty) {
      const badge_changes = {};
      if (dirty & /*items*/
      64)
        badge_changes.type = /*badgeType*/
        ctx2[15](
          /*item*/
          ctx2[23]
        );
      if (dirty & /*$$scope, items*/
      67108928) {
        badge_changes.$$scope = { dirty, ctx: ctx2 };
      }
      badge.$set(badge_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(badge.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(badge.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      destroy_component(badge);
    }
  };
}
__name(create_if_block_2$5, "create_if_block_2$5");
function create_default_slot$a(ctx) {
  let t_value = (
    /*remaining*/
    ctx[16](
      /*item*/
      ctx[23]
    ) + ""
  );
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*items*/
      64 && t_value !== (t_value = /*remaining*/
      ctx2[16](
        /*item*/
        ctx2[23]
      ) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
__name(create_default_slot$a, "create_default_slot$a");
function create_if_block_1$6(ctx) {
  let button0;
  let button1;
  let button2;
  let mounted;
  let dispose;
  return {
    c() {
      button0 = element("button");
      button0.innerHTML = `<i class="left fa fa-edit"></i>`;
      button1 = element("button");
      button1.innerHTML = `<i class="left fa fa-copy"></i>`;
      button2 = element("button");
      button2.innerHTML = `<i class="left fa fa-trash"></i>`;
      attr(button0, "class", "stealth");
      attr(button0, "data-tooltip", localize$1("Types.Actor.ActionButtons.Edit"));
      attr(button1, "class", "stealth");
      attr(button1, "data-tooltip", localize$1("Types.Actor.ActionButtons.Duplicate"));
      attr(button2, "class", "stealth");
      attr(button2, "data-tooltip", localize$1("Types.Actor.ActionButtons.Delete"));
    },
    m(target, anchor) {
      insert(target, button0, anchor);
      insert(target, button1, anchor);
      insert(target, button2, anchor);
      if (!mounted) {
        dispose = [
          listen(button0, "click", function() {
            if (is_function(editItem(
              /*item*/
              ctx[23]
            )))
              editItem(
                /*item*/
                ctx[23]
              ).apply(this, arguments);
          }),
          listen(button1, "click", function() {
            if (is_function(
              /*duplicateItem*/
              ctx[10](
                /*index*/
                ctx[25],
                /*item*/
                ctx[23]
              )
            ))
              ctx[10](
                /*index*/
                ctx[25],
                /*item*/
                ctx[23]
              ).apply(this, arguments);
          }),
          listen(button2, "click", function() {
            if (is_function(
              /*deleteItem*/
              ctx[11](
                /*index*/
                ctx[25],
                /*item*/
                ctx[23]
              )
            ))
              ctx[11](
                /*index*/
                ctx[25],
                /*item*/
                ctx[23]
              ).apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching) {
        detach(button0);
        detach(button1);
        detach(button2);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_if_block_1$6, "create_if_block_1$6");
function create_each_block$6(ctx) {
  let tr;
  let td0;
  let img;
  let img_src_value;
  let img_alt_value;
  let td1;
  let a;
  let t0_value = (
    /*item*/
    ctx[23].name + ""
  );
  let t0;
  let a_class_value;
  let td2;
  let t1_value = ucfirst(
    /*item*/
    ctx[23].type
  ) + "";
  let t1;
  let td3;
  let button;
  let i;
  let i_class_value;
  let td4;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*item*/
    ctx[23].system.hasLimitation && /*combat*/
    ctx[2] && create_if_block_2$5(ctx)
  );
  let if_block1 = !/*$doc*/
  ctx[1].system.inventoryLocked && create_if_block_1$6(ctx);
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      img = element("img");
      td1 = element("td");
      a = element("a");
      t0 = text(t0_value);
      if (if_block0)
        if_block0.c();
      td2 = element("td");
      t1 = text(t1_value);
      td3 = element("td");
      button = element("button");
      i = element("i");
      td4 = element("td");
      if (if_block1)
        if_block1.c();
      attr(img, "class", "icon");
      if (!src_url_equal(img.src, img_src_value = /*item*/
      ctx[23].img))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*item*/
      ctx[23].name);
      attr(td0, "class", "img");
      attr(a, "class", a_class_value = "stealth link " + /*item*/
      (ctx[23].system.isMagic ? "pulse" : "") + " svelte-1omalaq");
      attr(a, "role", "button");
      attr(td1, "class", "left");
      attr(i, "class", i_class_value = "fa-bookmark " + /*item*/
      (ctx[23].system.favourite === true ? "fa-solid" : "fa-regular") + " svelte-1omalaq");
      attr(button, "class", "stealth");
      attr(td4, "class", "min buttons right");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, img);
      append(tr, td1);
      append(td1, a);
      append(a, t0);
      if (if_block0)
        if_block0.m(td1, null);
      append(tr, td2);
      append(td2, t1);
      append(tr, td3);
      append(td3, button);
      append(button, i);
      append(tr, td4);
      if (if_block1)
        if_block1.m(td4, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(a, "click", function() {
            if (is_function(showItemSheet$1(
              /*item*/
              ctx[23]
            )))
              showItemSheet$1(
                /*item*/
                ctx[23]
              ).apply(this, arguments);
          }),
          listen(button, "click", function() {
            if (is_function(toggleBookmark(
              /*item*/
              ctx[23]
            )))
              toggleBookmark(
                /*item*/
                ctx[23]
              ).apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty & /*items*/
      64 && !src_url_equal(img.src, img_src_value = /*item*/
      ctx[23].img)) {
        attr(img, "src", img_src_value);
      }
      if (!current || dirty & /*items*/
      64 && img_alt_value !== (img_alt_value = /*item*/
      ctx[23].name)) {
        attr(img, "alt", img_alt_value);
      }
      if ((!current || dirty & /*items*/
      64) && t0_value !== (t0_value = /*item*/
      ctx[23].name + ""))
        set_data(t0, t0_value);
      if (!current || dirty & /*items*/
      64 && a_class_value !== (a_class_value = "stealth link " + /*item*/
      (ctx[23].system.isMagic ? "pulse" : "") + " svelte-1omalaq")) {
        attr(a, "class", a_class_value);
      }
      if (
        /*item*/
        ctx[23].system.hasLimitation && /*combat*/
        ctx[2]
      ) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
          if (dirty & /*items, combat*/
          68) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2$5(ctx);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(td1, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if ((!current || dirty & /*items*/
      64) && t1_value !== (t1_value = ucfirst(
        /*item*/
        ctx[23].type
      ) + ""))
        set_data(t1, t1_value);
      if (!current || dirty & /*items*/
      64 && i_class_value !== (i_class_value = "fa-bookmark " + /*item*/
      (ctx[23].system.favourite === true ? "fa-solid" : "fa-regular") + " svelte-1omalaq")) {
        attr(i, "class", i_class_value);
      }
      if (!/*$doc*/
      ctx[1].system.inventoryLocked) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block_1$6(ctx);
          if_block1.c();
          if_block1.m(td4, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(tr);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_each_block$6, "create_each_block$6");
function create_if_block$9(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = `${localize$1("Instructions.RemoveAll")}`;
      attr(button, "class", "mt-sm glossy-button gold-light hover-shine");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*removeAllItems*/
          ctx[12]
        );
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block$9, "create_if_block$9");
function create_fragment$x(ctx) {
  let div1;
  let div0;
  let h1;
  let table;
  let tr;
  let th0;
  let th1;
  let th2;
  let th3;
  let th4;
  let button;
  let i1;
  let i1_class_value;
  let button_class_value;
  let th4_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*$Actor*/
    ctx[0].system.job?.name && create_if_block_3$3(ctx)
  );
  let each_value = ensure_array_like(
    /*items*/
    ctx[6]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
  }
  const out = /* @__PURE__ */ __name((i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  }), "out");
  let if_block1 = (
    /*hasItems*/
    ctx[3] && create_if_block$9(ctx)
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      h1 = element("h1");
      h1.textContent = "Abilities";
      table = element("table");
      tr = element("tr");
      th0 = element("th");
      th1 = element("th");
      th1.textContent = `${localize$1("Name")}`;
      th2 = element("th");
      th2.textContent = `${localize$1("Type")}`;
      th3 = element("th");
      th3.innerHTML = `<i class="fa-solid fa-bookmark svelte-1omalaq"></i>`;
      th4 = element("th");
      button = element("button");
      i1 = element("i");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      if (if_block1)
        if_block1.c();
      attr(h1, "class", "gold");
      attr(th0, "class", "img shrink");
      attr(th0, "scope", "col");
      attr(th1, "class", "left expand ml-sm");
      attr(th1, "scope", "col");
      attr(th2, "class", "fixed");
      attr(th2, "scope", "col");
      attr(th3, "class", "shrink");
      attr(th3, "scope", "col");
      attr(i1, "class", i1_class_value = "fa " + /*faLockCSS*/
      ctx[4] + " svelte-1omalaq");
      attr(button, "class", button_class_value = "stealth " + /*lockCSS*/
      ctx[5] + " svelte-1omalaq");
      attr(th4, "class", th4_class_value = "buttons " + /*lockCSS*/
      ctx[5] + " svelte-1omalaq");
      attr(th4, "scope", "col");
      attr(table, "class", "borderless");
      attr(div0, "class", "padded svelte-1omalaq");
      attr(div1, "class", "panel overflow containerx svelte-1omalaq");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append(div0, h1);
      append(div0, table);
      append(table, tr);
      append(tr, th0);
      append(tr, th1);
      append(tr, th2);
      append(tr, th3);
      append(tr, th4);
      append(th4, button);
      append(button, i1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(table, null);
        }
      }
      if (if_block1)
        if_block1.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*toggleLock*/
          ctx[13]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*$Actor*/
        ctx2[0].system.job?.name
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_3$3(ctx2);
          if_block0.c();
          if_block0.m(div0, h1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!current || dirty & /*faLockCSS*/
      16 && i1_class_value !== (i1_class_value = "fa " + /*faLockCSS*/
      ctx2[4] + " svelte-1omalaq")) {
        attr(i1, "class", i1_class_value);
      }
      if (!current || dirty & /*lockCSS*/
      32 && button_class_value !== (button_class_value = "stealth " + /*lockCSS*/
      ctx2[5] + " svelte-1omalaq")) {
        attr(button, "class", button_class_value);
      }
      if (!current || dirty & /*lockCSS*/
      32 && th4_class_value !== (th4_class_value = "buttons " + /*lockCSS*/
      ctx2[5] + " svelte-1omalaq")) {
        attr(th4, "class", th4_class_value);
      }
      if (dirty & /*deleteItem, items, duplicateItem, editItem, $doc, badgeType, remaining, combat, showItemSheet*/
      101446) {
        each_value = ensure_array_like(
          /*items*/
          ctx2[6]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$6(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$6(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(table, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (
        /*hasItems*/
        ctx2[3]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$9(ctx2);
          if_block1.c();
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (if_block0)
        if_block0.d();
      destroy_each(each_blocks, detaching);
      if (if_block1)
        if_block1.d();
      mounted = false;
      dispose();
    }
  };
}
__name(create_fragment$x, "create_fragment$x");
function editItem(item) {
  item.sheet.render(true);
  game.system.log.d("editItem");
  game.system.log.d(item);
}
__name(editItem, "editItem");
function showItemSheet$1(item) {
  item.sheet.render(true);
}
__name(showItemSheet$1, "showItemSheet$1");
function instance$r($$self, $$props, $$invalidate) {
  let items;
  let lockCSS;
  let faLockCSS;
  let hasItems;
  let $Actor;
  let $doc;
  let $wildcard;
  const Actor2 = getContext("#doc");
  component_subscribe($$self, Actor2, (value) => $$invalidate(0, $Actor = value));
  const doc = new TJSDocument($Actor);
  component_subscribe($$self, doc, (value) => $$invalidate(1, $doc = value));
  new CONFIG.FFXIV.RollCalcActor({ actor: $Actor });
  const typeSearch = createFilterQuery("type");
  typeSearch.set(["trait", "action"]);
  let combat;
  function onCombatUpdate() {
    $$invalidate(2, combat = game.combat);
  }
  __name(onCombatUpdate, "onCombatUpdate");
  onMount(() => {
    $$invalidate(2, combat = game.combat);
    Hooks.on("createCombat", onCombatUpdate);
    Hooks.on("deleteCombat", onCombatUpdate);
    Hooks.on("updateCombat", onCombatUpdate);
    return () => {
      Hooks.off("createCombat", onCombatUpdate);
      Hooks.off("deleteCombat", onCombatUpdate);
      Hooks.off("updateCombat", onCombatUpdate);
    };
  });
  const wildcard = doc.embedded.create(Item, {
    name: "wildcard",
    filters: [typeSearch],
    sort: (a, b) => a.name.localeCompare(b.name)
  });
  component_subscribe($$self, wildcard, (value) => $$invalidate(17, $wildcard = value));
  function duplicateItem(item) {
    game.system.log.d("duplicateItem");
    game.system.log.d(item);
    const itemData = item.toObject();
    delete itemData._id;
    game.system.log.d("itemData", itemData);
    $Actor.sheet._onDropItemCreate(itemData);
  }
  __name(duplicateItem, "duplicateItem");
  function deleteItem(index, item) {
    let okToDelete = true;
    if (game.settings.get(SYSTEM_ID, "confirmBeforeDeletingActorItem")) {
      okToDelete = confirm(localize$1("Types.Actor.Abilities.confirmDeleteItem"));
    }
    if (okToDelete) {
      item.delete();
    }
  }
  __name(deleteItem, "deleteItem");
  async function removeAllItems() {
    await Dialog.confirm({
      title: localize$1("Types.Actor.Abilities.confirmDeleteAllTitle"),
      content: localize$1("Types.Actor.Abilities.confirmDeleteAll"),
      yes: async () => {
        await $Actor.deleteAllItems(["trait", "action"]);
      },
      no: () => {
      }
    });
  }
  __name(removeAllItems, "removeAllItems");
  function toggleLock(event) {
    game.system.log.d("a");
    event.stopPropagation();
    event.preventDefault();
    $doc.update(
      {
        ["system.inventoryLocked"]: !$doc.system.inventoryLocked
      },
      {
        diff: true,
        diffData: true,
        diffSystem: true
      }
    );
  }
  __name(toggleLock, "toggleLock");
  async function deleteJob() {
    if (!$doc.system.job.uuid) {
      return;
    }
    await Dialog.confirm({
      title: localize$1("Types.Actor.Abilities.confirmDeleteJobTitle"),
      content: localize$1("Types.Actor.Abilities.confirmDeleteJob"),
      yes: async () => {
        const job = await fromUuid($doc.system.job.uuid);
        const grants = job.system.grants;
        for (let grant of grants.list) {
          const item = await fromUuid(grant.uuid);
          const actorItem = $doc.items.find((x) => x.name === item.name);
          if (actorItem) {
            actorItem.delete();
          }
        }
        $doc.update({
          system: {
            job: {
              uuid: "",
              name: "",
              grants: [],
              level: null,
              img: null,
              role: ""
            }
          }
        });
      },
      no: () => {
      }
    });
  }
  __name(deleteJob, "deleteJob");
  onMount(async () => {
    game.system.log.d("items", $doc.items);
  });
  const badgeType = /* @__PURE__ */ __name((item) => {
    return item.system.uses >= item.system.limitation ? "danger" : "success";
  }, "badgeType");
  const remaining = /* @__PURE__ */ __name((item) => {
    return item.system.hasLimitation ? parseInt(item.system.limitation || 0) - parseInt(item.system.uses || 0) : 10;
  }, "remaining");
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$wildcard*/
    131072) {
      $$invalidate(6, items = [...$wildcard]);
    }
    if ($$self.$$.dirty & /*$doc*/
    2) {
      $$invalidate(5, lockCSS = $doc.system.inventoryLocked ? "lock" : "lock-open");
    }
    if ($$self.$$.dirty & /*$doc*/
    2) {
      $$invalidate(4, faLockCSS = $doc.system.inventoryLocked ? "fa-lock negative" : "fa-lock-open positive");
    }
    if ($$self.$$.dirty & /*$Actor*/
    1) {
      $$invalidate(3, hasItems = $Actor.items.some((x) => ["action", "trait"].includes(x.type)));
    }
  };
  return [
    $Actor,
    $doc,
    combat,
    hasItems,
    faLockCSS,
    lockCSS,
    items,
    Actor2,
    doc,
    wildcard,
    duplicateItem,
    deleteItem,
    removeAllItems,
    toggleLock,
    deleteJob,
    badgeType,
    remaining,
    $wildcard
  ];
}
__name(instance$r, "instance$r");
class Abilities2 extends SvelteComponent {
  static {
    __name(this, "Abilities");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$r, create_fragment$x, safe_not_equal, {});
  }
}
function get_each_context$5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i].code;
  child_ctx[7] = i;
  return child_ctx;
}
__name(get_each_context$5, "get_each_context$5");
function create_each_block$5(ctx) {
  let attribute;
  let current;
  attribute = new Attribute({
    props: {
      showSign: (
        /*showSign*/
        ctx[3]
      ),
      abbreviateLabel: (
        /*abbreviateLabel*/
        ctx[1]
      ),
      key: (
        /*key*/
        ctx[2]
      ),
      code: (
        /*code*/
        ctx[5]
      ),
      onclick: (
        /*onclick*/
        ctx[4]
      )
    }
  });
  return {
    c() {
      create_component(attribute.$$.fragment);
    },
    m(target, anchor) {
      mount_component(attribute, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const attribute_changes = {};
      if (dirty & /*showSign*/
      8)
        attribute_changes.showSign = /*showSign*/
        ctx2[3];
      if (dirty & /*abbreviateLabel*/
      2)
        attribute_changes.abbreviateLabel = /*abbreviateLabel*/
        ctx2[1];
      if (dirty & /*key*/
      4)
        attribute_changes.key = /*key*/
        ctx2[2];
      if (dirty & /*data*/
      1)
        attribute_changes.code = /*code*/
        ctx2[5];
      if (dirty & /*onclick*/
      16)
        attribute_changes.onclick = /*onclick*/
        ctx2[4];
      attribute.$set(attribute_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(attribute.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(attribute.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(attribute, detaching);
    }
  };
}
__name(create_each_block$5, "create_each_block$5");
function create_fragment$w(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like(
    /*data*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
  }
  const out = /* @__PURE__ */ __name((i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  }), "out");
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "component");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*showSign, abbreviateLabel, key, data, onclick*/
      31) {
        each_value = ensure_array_like(
          /*data*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$5(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$5(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
__name(create_fragment$w, "create_fragment$w");
function instance$q($$self, $$props, $$invalidate) {
  let { data } = $$props;
  let { abbreviateLabel } = $$props;
  let { key } = $$props;
  let { showSign } = $$props;
  let { onclick } = $$props;
  onMount(() => {
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("abbreviateLabel" in $$props2)
      $$invalidate(1, abbreviateLabel = $$props2.abbreviateLabel);
    if ("key" in $$props2)
      $$invalidate(2, key = $$props2.key);
    if ("showSign" in $$props2)
      $$invalidate(3, showSign = $$props2.showSign);
    if ("onclick" in $$props2)
      $$invalidate(4, onclick = $$props2.onclick);
  };
  return [data, abbreviateLabel, key, showSign, onclick];
}
__name(instance$q, "instance$q");
class AttributeCol2 extends SvelteComponent {
  static {
    __name(this, "AttributeCol");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$q, create_fragment$w, safe_not_equal, {
      data: 0,
      abbreviateLabel: 1,
      key: 2,
      showSign: 3,
      onclick: 4
    });
  }
}
function create_fragment$v(ctx) {
  let div1;
  let div0;
  let attributecol;
  let current;
  attributecol = new AttributeCol2({
    props: {
      key: "primary",
      showSign: true,
      abbreviateLabel: true,
      data: (
        /*data*/
        ctx[1]
      ),
      onclick: (
        /*onclick*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(attributecol.$$.fragment);
      attr(div0, "class", "flexrow mb-md");
      attr(div1, "class", "molecule svelte-1x6bbhr");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(attributecol, div0, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const attributecol_changes = {};
      if (dirty & /*onclick*/
      1)
        attributecol_changes.onclick = /*onclick*/
        ctx2[0];
      attributecol.$set(attributecol_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(attributecol.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(attributecol.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(attributecol);
    }
  };
}
__name(create_fragment$v, "create_fragment$v");
function instance$p($$self, $$props, $$invalidate) {
  let { onclick } = $$props;
  let data = [
    { code: "str" },
    { code: "dex" },
    { code: "vit" },
    { code: "int" },
    { code: "mnd" }
  ];
  $$self.$$set = ($$props2) => {
    if ("onclick" in $$props2)
      $$invalidate(0, onclick = $$props2.onclick);
  };
  return [onclick, data];
}
__name(instance$p, "instance$p");
class PrimaryAttributes2 extends SvelteComponent {
  static {
    __name(this, "PrimaryAttributes");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$p, create_fragment$v, safe_not_equal, { onclick: 0 });
  }
}
function create_fragment$u(ctx) {
  let div1;
  let div0;
  let attributecol;
  let current;
  attributecol = new AttributeCol$1({
    props: {
      data: (
        /*data*/
        ctx[1]
      ),
      key: "secondary",
      onclick: (
        /*onclick*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(attributecol.$$.fragment);
      attr(div0, "class", "flexrow mb-md");
      attr(div1, "class", "molecule svelte-3bnbep");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(attributecol, div0, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const attributecol_changes = {};
      if (dirty & /*onclick*/
      1)
        attributecol_changes.onclick = /*onclick*/
        ctx2[0];
      attributecol.$set(attributecol_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(attributecol.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(attributecol.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(attributecol);
    }
  };
}
__name(create_fragment$u, "create_fragment$u");
function instance$o($$self, $$props, $$invalidate) {
  let { onclick } = $$props;
  let data = [{ code: "def" }, { code: "mag" }, { code: "vig" }, { code: "spd" }];
  $$self.$$set = ($$props2) => {
    if ("onclick" in $$props2)
      $$invalidate(0, onclick = $$props2.onclick);
  };
  return [onclick, data];
}
__name(instance$o, "instance$o");
class SecondaryAttributes2 extends SvelteComponent {
  static {
    __name(this, "SecondaryAttributes");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$o, create_fragment$u, safe_not_equal, { onclick: 0 });
  }
}
function create_fragment$t(ctx) {
  let div6;
  let div2;
  let div0;
  let label;
  let div1;
  let docselect;
  let div5;
  let div3;
  let primaryattributes;
  let div4;
  let secondaryattributes;
  let current;
  docselect = new DocSelect({
    props: {
      class: "right white",
      name: "size",
      valuePath: "system.size",
      options: (
        /*sizeOptions*/
        ctx[0]
      ),
      callback: (
        /*onSizeChange*/
        ctx[2]
      )
    }
  });
  primaryattributes = new PrimaryAttributes2({ props: { onclick: (
    /*onclick*/
    ctx[3]
  ) } });
  secondaryattributes = new SecondaryAttributes2({ props: { onclick: (
    /*onclick*/
    ctx[3]
  ) } });
  return {
    c() {
      div6 = element("div");
      div2 = element("div");
      div0 = element("div");
      label = element("label");
      label.textContent = `${localize$1("Size")}`;
      div1 = element("div");
      create_component(docselect.$$.fragment);
      div5 = element("div");
      div3 = element("div");
      create_component(primaryattributes.$$.fragment);
      div4 = element("div");
      create_component(secondaryattributes.$$.fragment);
      attr(label, "for", "size");
      attr(div0, "class", "flex1 ml-md mt-md left white");
      attr(div1, "class", "flex1 mt-md mr-md right");
      attr(div2, "class", "flexrow sheet-row justify-vertical");
      attr(div3, "class", "flex");
      attr(div4, "class", "flex");
      attr(div5, "class", "flexrow");
      attr(div6, "class", "molecule svelte-xanq5m");
    },
    m(target, anchor) {
      insert(target, div6, anchor);
      append(div6, div2);
      append(div2, div0);
      append(div0, label);
      append(div2, div1);
      mount_component(docselect, div1, null);
      append(div6, div5);
      append(div5, div3);
      mount_component(primaryattributes, div3, null);
      append(div5, div4);
      mount_component(secondaryattributes, div4, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(docselect.$$.fragment, local);
      transition_in(primaryattributes.$$.fragment, local);
      transition_in(secondaryattributes.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(docselect.$$.fragment, local);
      transition_out(primaryattributes.$$.fragment, local);
      transition_out(secondaryattributes.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div6);
      }
      destroy_component(docselect);
      destroy_component(primaryattributes);
      destroy_component(secondaryattributes);
    }
  };
}
__name(create_fragment$t, "create_fragment$t");
function instance$n($$self, $$props, $$invalidate) {
  let $actor;
  const sizeOptions = getSizeOptions();
  const actor = getContext("#doc");
  component_subscribe($$self, actor, (value) => $$invalidate(4, $actor = value));
  const sizeToGrid = {
    tiny: 0.5,
    small: 1,
    medium: 1,
    large: 2,
    huge: 3,
    gargantuan: 4
  };
  const onSizeChange = /* @__PURE__ */ __name(async (newSize) => {
    const gridSize = sizeToGrid[newSize.toLowerCase()] || 1;
    await $actor.update({
      "prototypeToken.width": gridSize,
      "prototypeToken.height": gridSize
    });
  }, "onSizeChange");
  const onclick = /* @__PURE__ */ __name(async (key, code) => {
    game.system.log.d("actor", $actor);
    const attributeValue = $actor.system.attributes[key][code].val;
    const rollFormula = `1d20 + ${attributeValue}`;
    const attributeName = code.toUpperCase();
    const roll = await new Roll(rollFormula).evaluate({ async: true });
    const messageData = {
      speaker: ChatMessage.getSpeaker({ actor: $actor }),
      flavor: `${attributeName} Check`,
      type: CONST.CHAT_MESSAGE_TYPES.ROLL,
      roll,
      flags: {
        [SYSTEM_ID]: {
          data: {
            chatTemplate: "AttributeRollChat",
            actor: {
              _id: $actor._id,
              name: $actor.name,
              img: $actor.img
            }
          }
        }
      }
    };
    await roll.toMessage(messageData);
  }, "onclick");
  return [sizeOptions, actor, onSizeChange, onclick];
}
__name(instance$n, "instance$n");
class AttributeBlock2 extends SvelteComponent {
  static {
    __name(this, "AttributeBlock");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$n, create_fragment$t, safe_not_equal, {});
  }
}
function create_fragment$s(ctx) {
  let section;
  let div3;
  let div0;
  let div2;
  let div1;
  let attributeblock;
  let current;
  attributeblock = new AttributeBlock2({});
  return {
    c() {
      section = element("section");
      div3 = element("div");
      div0 = element("div");
      div2 = element("div");
      div1 = element("div");
      create_component(attributeblock.$$.fragment);
      attr(div0, "class", "texture svelte-1j11oxv");
      attr(div1, "class", "flex2");
      attr(div2, "class", "flexrow panel borderless");
      attr(div3, "class", "flexcol background svelte-1j11oxv");
      attr(section, "class", "organism");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, div3);
      append(div3, div0);
      append(div3, div2);
      append(div2, div1);
      mount_component(attributeblock, div1, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(attributeblock.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(attributeblock.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      destroy_component(attributeblock);
    }
  };
}
__name(create_fragment$s, "create_fragment$s");
function instance$m($$self, $$props, $$invalidate) {
  getContext("#external").application;
  const documentStore = getContext("#doc");
  component_subscribe($$self, documentStore, (value) => $$invalidate(2, value));
  return [documentStore];
}
__name(instance$m, "instance$m");
class AttributeSection2 extends SvelteComponent {
  static {
    __name(this, "AttributeSection");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$m, create_fragment$s, safe_not_equal, {});
  }
}
function create_fragment$r(ctx) {
  let section;
  let div1;
  let div0;
  let hp;
  let current;
  hp = new HP({});
  return {
    c() {
      section = element("section");
      div1 = element("div");
      div0 = element("div");
      create_component(hp.$$.fragment);
      attr(div0, "class", "flex hp pa-md svelte-w11pgv");
      attr(div1, "class", "flexrow section svelte-w11pgv");
      attr(section, "class", "organism");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, div1);
      append(div1, div0);
      mount_component(hp, div0, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(hp.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(hp.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      destroy_component(hp);
    }
  };
}
__name(create_fragment$r, "create_fragment$r");
class PointsSectionNPC extends SvelteComponent {
  static {
    __name(this, "PointsSectionNPC");
  }
  constructor(options) {
    super();
    init$1(this, options, null, create_fragment$r, safe_not_equal, {});
  }
}
function create_fragment$q(ctx) {
  let div;
  let pre;
  let portraitframe;
  let current;
  portraitframe = new PortraitFrame({
    props: {
      img: true,
      imgSrc: (
        /*$documentStore*/
        ctx[0]?.img
      ),
      onclick: (
        /*_editToken*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      div = element("div");
      pre = element("pre");
      pre.textContent = "bo";
      create_component(portraitframe.$$.fragment);
      attr(div, "class", "portrait-frame svelte-1cb780d");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, pre);
      mount_component(portraitframe, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const portraitframe_changes = {};
      if (dirty & /*$documentStore*/
      1)
        portraitframe_changes.imgSrc = /*$documentStore*/
        ctx2[0]?.img;
      portraitframe.$set(portraitframe_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(portraitframe.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(portraitframe.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(portraitframe);
    }
  };
}
__name(create_fragment$q, "create_fragment$q");
function instance$l($$self, $$props, $$invalidate) {
  let $documentStore;
  const application = getContext("#external").application;
  const documentStore = getContext("#doc");
  component_subscribe($$self, documentStore, (value) => $$invalidate(0, $documentStore = value));
  let _filePickerInstance = {};
  function _launchStandardProfileEditor(event) {
    const current = $documentStore.img;
    if (_filePickerInstance instanceof FilePicker && !_filePickerInstance?.rendered) {
      _filePickerInstance.render(true);
      return;
    }
    _filePickerInstance = new FilePicker({
      type: "image",
      current,
      callback: (path) => {
        $documentStore.update({ img: path });
      },
      top: application.position.top + 40,
      left: application.position.left + 10
    });
    return _filePickerInstance.browse();
  }
  __name(_launchStandardProfileEditor, "_launchStandardProfileEditor");
  function _editToken(event) {
    if (game.modules.has("vtta-tokenizer") && typeof Tokenizer !== "undefined") {
      _launchTokenizer();
    } else {
      _launchStandardProfileEditor();
    }
  }
  __name(_editToken, "_editToken");
  function _launchTokenizer() {
    if (game.modules.has("vtta-tokenizer") && typeof Tokenizer !== "undefined") {
      Tokenizer.tokenizeActor($documentStore);
    }
  }
  __name(_launchTokenizer, "_launchTokenizer");
  return [$documentStore, documentStore, _editToken];
}
__name(instance$l, "instance$l");
class Portrait extends SvelteComponent {
  static {
    __name(this, "Portrait");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$l, create_fragment$q, safe_not_equal, {});
  }
}
function create_default_slot$9(ctx) {
  let div7;
  let div0;
  let h2;
  let div4;
  let div3;
  let div1;
  let label;
  let div2;
  let docinput;
  let hr;
  let div6;
  let div5;
  let prosemirror;
  let current;
  docinput = new DocInput({
    props: {
      class: "wide",
      id: "name",
      name: "name",
      valuePath: "name"
    }
  });
  prosemirror = new ProseMirror$1({
    props: {
      editable: true,
      attr: "system.description"
    }
  });
  return {
    c() {
      div7 = element("div");
      div0 = element("div");
      h2 = element("h2");
      h2.textContent = `${localize(`${SYSTEM_CODE}.Description`)}`;
      div4 = element("div");
      div3 = element("div");
      div1 = element("div");
      label = element("label");
      label.textContent = `${localize(`${SYSTEM_CODE}.Name`)}`;
      div2 = element("div");
      create_component(docinput.$$.fragment);
      hr = element("hr");
      div6 = element("div");
      div5 = element("div");
      create_component(prosemirror.$$.fragment);
      attr(h2, "class", "font-cinzel");
      attr(div0, "class", "flex1");
      attr(label, "class", "gold");
      attr(label, "for", "name");
      attr(div1, "class", "flex2 left pl-md");
      attr(div2, "class", "flex2 wide");
      attr(div3, "class", "flexrow justify-vertical");
      attr(div4, "class", "flex1");
      attr(div5, "class", "left panel borderless overflow prose");
      attr(div6, "class", "flex3");
      attr(div7, "class", "flexcol wide gold");
    },
    m(target, anchor) {
      insert(target, div7, anchor);
      append(div7, div0);
      append(div0, h2);
      append(div7, div4);
      append(div4, div3);
      append(div3, div1);
      append(div1, label);
      append(div3, div2);
      mount_component(docinput, div2, null);
      append(div7, hr);
      append(div7, div6);
      append(div6, div5);
      mount_component(prosemirror, div5, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(docinput.$$.fragment, local);
      transition_in(prosemirror.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(docinput.$$.fragment, local);
      transition_out(prosemirror.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div7);
      }
      destroy_component(docinput);
      destroy_component(prosemirror);
    }
  };
}
__name(create_default_slot$9, "create_default_slot$9");
function create_fragment$p(ctx) {
  let div5;
  let div4;
  let div0;
  let div3;
  let div2;
  let div1;
  let portraitframe;
  let current;
  portraitframe = new PortraitFrame({
    props: {
      style: "min-width: 182px;",
      $$slots: { default: [create_default_slot$9] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div5 = element("div");
      div4 = element("div");
      div0 = element("div");
      div3 = element("div");
      div2 = element("div");
      div1 = element("div");
      create_component(portraitframe.$$.fragment);
      attr(div0, "class", "texture svelte-1l2lk3v");
      attr(div1, "class", "portrait-frame pr-xs wide svelte-1l2lk3v");
      attr(div2, "class", "flex2 wide");
      attr(div3, "class", "flexrow panel borderless wide");
      attr(div4, "class", "background svelte-1l2lk3v");
      attr(div5, "class", "navy svelte-1l2lk3v");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div4);
      append(div4, div0);
      append(div4, div3);
      append(div3, div2);
      append(div2, div1);
      mount_component(portraitframe, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const portraitframe_changes = {};
      if (dirty & /*$$scope*/
      1) {
        portraitframe_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portraitframe.$set(portraitframe_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(portraitframe.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(portraitframe.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div5);
      }
      destroy_component(portraitframe);
    }
  };
}
__name(create_fragment$p, "create_fragment$p");
class DescriptionBlockNPC extends SvelteComponent {
  static {
    __name(this, "DescriptionBlockNPC");
  }
  constructor(options) {
    super();
    init$1(this, options, null, create_fragment$p, safe_not_equal, {});
  }
}
function create_default_slot_1(ctx) {
  let div3;
  let div0;
  let h2;
  let div2;
  let div1;
  let pointssection;
  let current;
  pointssection = new PointsSectionNPC({});
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      h2 = element("h2");
      h2.textContent = `${localize(`${SYSTEM_CODE}.Points`)}`;
      div2 = element("div");
      div1 = element("div");
      create_component(pointssection.$$.fragment);
      attr(h2, "class", "font-cinzel");
      attr(div0, "class", "flex1");
      attr(div1, "class", "left panel borderless overflow");
      attr(div2, "class", "flex1");
      attr(div3, "class", "flexcol wide");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      append(div0, h2);
      append(div3, div2);
      append(div2, div1);
      mount_component(pointssection, div1, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(pointssection.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pointssection.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      destroy_component(pointssection);
    }
  };
}
__name(create_default_slot_1, "create_default_slot_1");
function create_if_block_1$5(ctx) {
  let div;
  let descriptionblocknpc;
  let current;
  descriptionblocknpc = new DescriptionBlockNPC({});
  return {
    c() {
      div = element("div");
      create_component(descriptionblocknpc.$$.fragment);
      attr(div, "class", "flexcol");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(descriptionblocknpc, div, null);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(descriptionblocknpc.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(descriptionblocknpc.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(descriptionblocknpc);
    }
  };
}
__name(create_if_block_1$5, "create_if_block_1$5");
function create_if_block$8(ctx) {
  let div;
  let descriptionblocknpc;
  let current;
  descriptionblocknpc = new DescriptionBlockNPC({});
  return {
    c() {
      div = element("div");
      create_component(descriptionblocknpc.$$.fragment);
      attr(div, "class", "flexcol");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(descriptionblocknpc, div, null);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(descriptionblocknpc.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(descriptionblocknpc.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(descriptionblocknpc);
    }
  };
}
__name(create_if_block$8, "create_if_block$8");
function create_default_slot$8(ctx) {
  let effectssection;
  let current;
  effectssection = new EffectsSection({ props: { class: "high wide" } });
  return {
    c() {
      create_component(effectssection.$$.fragment);
    },
    m(target, anchor) {
      mount_component(effectssection, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(effectssection.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(effectssection.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(effectssection, detaching);
    }
  };
}
__name(create_default_slot$8, "create_default_slot$8");
function create_fragment$o(ctx) {
  let div17;
  let div10;
  let div8;
  let div7;
  let div6;
  let div5;
  let div0;
  let div4;
  let div1;
  let portrait;
  let div1_style_value;
  let div3;
  let div2;
  let portraitframe0;
  let div8_class_value;
  let div9;
  let attributesection;
  let div9_class_value;
  let div16;
  let div15;
  let div11;
  let div14;
  let div13;
  let div12;
  let portraitframe1;
  let current;
  portrait = new Portrait({});
  portraitframe0 = new PortraitFrame({
    props: {
      style: "min-width: 182px;",
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    }
  });
  let if_block0 = (
    /*largewindow*/
    ctx[0] && create_if_block_1$5()
  );
  attributesection = new AttributeSection2({});
  let if_block1 = (
    /*smallwindow*/
    ctx[1] && create_if_block$8()
  );
  portraitframe1 = new PortraitFrame({
    props: {
      size: "40",
      style: "min-width: 182px;",
      $$slots: { default: [create_default_slot$8] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div17 = element("div");
      div10 = element("div");
      div8 = element("div");
      div7 = element("div");
      div6 = element("div");
      div5 = element("div");
      div0 = element("div");
      div4 = element("div");
      div1 = element("div");
      create_component(portrait.$$.fragment);
      div3 = element("div");
      div2 = element("div");
      create_component(portraitframe0.$$.fragment);
      if (if_block0)
        if_block0.c();
      div9 = element("div");
      create_component(attributesection.$$.fragment);
      if (if_block1)
        if_block1.c();
      div16 = element("div");
      div15 = element("div");
      div11 = element("div");
      div14 = element("div");
      div13 = element("div");
      div12 = element("div");
      create_component(portraitframe1.$$.fragment);
      attr(div0, "class", "texture svelte-73oti1");
      attr(div1, "class", "flex1");
      attr(div1, "style", div1_style_value = /*smallwindow*/
      ctx[1] ? "min-width: 120px;" : "");
      attr(div2, "class", "portrait-frame pr-xs wide svelte-73oti1");
      attr(div3, "class", "flex2 wide");
      attr(div4, "class", "flexrow panel borderless wide");
      attr(div5, "class", "background svelte-73oti1");
      attr(div6, "class", "purple svelte-73oti1");
      attr(div7, "class", "flexcol");
      attr(div8, "class", div8_class_value = /*smallwindow*/
      ctx[1] ? "flex2" : "flex3");
      attr(div9, "class", div9_class_value = /*largewindow*/
      ctx[0] ? "flex2" : "flex3");
      set_style(div9, "min-width", "250px");
      attr(div10, "class", "flexrow");
      attr(div11, "class", "texture svelte-73oti1");
      attr(div12, "class", "portrait-frame pr-xs svelte-73oti1");
      attr(div13, "class", "flex2 gold");
      attr(div14, "class", "flexrow panel borderless wide");
      attr(div15, "class", "background svelte-73oti1");
      attr(div16, "class", "flexcol teal svelte-73oti1");
      attr(div17, "class", "panel overflow");
    },
    m(target, anchor) {
      insert(target, div17, anchor);
      append(div17, div10);
      append(div10, div8);
      append(div8, div7);
      append(div7, div6);
      append(div6, div5);
      append(div5, div0);
      append(div5, div4);
      append(div4, div1);
      mount_component(portrait, div1, null);
      append(div4, div3);
      append(div3, div2);
      mount_component(portraitframe0, div2, null);
      if (if_block0)
        if_block0.m(div8, null);
      append(div10, div9);
      mount_component(attributesection, div9, null);
      if (if_block1)
        if_block1.m(div17, null);
      append(div17, div16);
      append(div16, div15);
      append(div15, div11);
      append(div15, div14);
      append(div14, div13);
      append(div13, div12);
      mount_component(portraitframe1, div12, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*smallwindow*/
      2 && div1_style_value !== (div1_style_value = /*smallwindow*/
      ctx2[1] ? "min-width: 120px;" : "")) {
        attr(div1, "style", div1_style_value);
      }
      const portraitframe0_changes = {};
      if (dirty & /*$$scope*/
      64) {
        portraitframe0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portraitframe0.$set(portraitframe0_changes);
      if (
        /*largewindow*/
        ctx2[0]
      ) {
        if (if_block0) {
          if (dirty & /*largewindow*/
          1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1$5();
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div8, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*smallwindow*/
      2 && div8_class_value !== (div8_class_value = /*smallwindow*/
      ctx2[1] ? "flex2" : "flex3")) {
        attr(div8, "class", div8_class_value);
      }
      if (!current || dirty & /*largewindow*/
      1 && div9_class_value !== (div9_class_value = /*largewindow*/
      ctx2[0] ? "flex2" : "flex3")) {
        attr(div9, "class", div9_class_value);
      }
      if (
        /*smallwindow*/
        ctx2[1]
      ) {
        if (if_block1) {
          if (dirty & /*smallwindow*/
          2) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$8();
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div17, div16);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      const portraitframe1_changes = {};
      if (dirty & /*$$scope*/
      64) {
        portraitframe1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portraitframe1.$set(portraitframe1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(portrait.$$.fragment, local);
      transition_in(portraitframe0.$$.fragment, local);
      transition_in(if_block0);
      transition_in(attributesection.$$.fragment, local);
      transition_in(if_block1);
      transition_in(portraitframe1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(portrait.$$.fragment, local);
      transition_out(portraitframe0.$$.fragment, local);
      transition_out(if_block0);
      transition_out(attributesection.$$.fragment, local);
      transition_out(if_block1);
      transition_out(portraitframe1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div17);
      }
      destroy_component(portrait);
      destroy_component(portraitframe0);
      if (if_block0)
        if_block0.d();
      destroy_component(attributesection);
      if (if_block1)
        if_block1.d();
      destroy_component(portraitframe1);
    }
  };
}
__name(create_fragment$o, "create_fragment$o");
function instance$k($$self, $$props, $$invalidate) {
  let smallwindow;
  let largewindow;
  let $width;
  getContext("#doc");
  const application = getContext("#external").application;
  const { width } = application.position.stores;
  component_subscribe($$self, width, (value) => $$invalidate(3, $width = value));
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$width*/
    8) {
      $$invalidate(1, smallwindow = $width <= 750);
    }
    if ($$self.$$.dirty & /*$width*/
    8) {
      $$invalidate(0, largewindow = $width > 750);
    }
  };
  return [largewindow, smallwindow, width, $width];
}
__name(instance$k, "instance$k");
class Attributes2 extends SvelteComponent {
  static {
    __name(this, "Attributes");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$k, create_fragment$o, safe_not_equal, {});
  }
}
function create_default_slot$7(ctx) {
  let tabs_1;
  let current;
  tabs_1 = new Tabs({
    props: {
      class: "tabs tall",
      tabs: (
        /*tabs*/
        ctx[3]
      ),
      activeTab,
      sheet: "['actor', 'NPC']"
    }
  });
  return {
    c() {
      create_component(tabs_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tabs_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tabs_1_changes = {};
      if (dirty & /*tabs*/
      8)
        tabs_1_changes.tabs = /*tabs*/
        ctx2[3];
      tabs_1.$set(tabs_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tabs_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tabs_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tabs_1, detaching);
    }
  };
}
__name(create_default_slot$7, "create_default_slot$7");
function create_fragment$n(ctx) {
  let applicationshell;
  let updating_elementRoot;
  let updating_stylesApp;
  let current;
  function applicationshell_elementRoot_binding(value) {
    ctx[7](value);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  function applicationshell_stylesApp_binding(value) {
    ctx[8](value);
  }
  __name(applicationshell_stylesApp_binding, "applicationshell_stylesApp_binding");
  let applicationshell_props = {
    $$slots: { default: [create_default_slot$7] },
    $$scope: { ctx }
  };
  if (
    /*elementRoot*/
    ctx[0] !== void 0
  ) {
    applicationshell_props.elementRoot = /*elementRoot*/
    ctx[0];
  }
  if (
    /*stylesApp*/
    ctx[2] !== void 0
  ) {
    applicationshell_props.stylesApp = /*stylesApp*/
    ctx[2];
  }
  applicationshell = new ApplicationShell({ props: applicationshell_props });
  binding_callbacks.push(() => bind(applicationshell, "elementRoot", applicationshell_elementRoot_binding));
  binding_callbacks.push(() => bind(applicationshell, "stylesApp", applicationshell_stylesApp_binding));
  return {
    c() {
      create_component(applicationshell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(applicationshell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const applicationshell_changes = {};
      if (dirty & /*$$scope, tabs*/
      32776) {
        applicationshell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_elementRoot && dirty & /*elementRoot*/
      1) {
        updating_elementRoot = true;
        applicationshell_changes.elementRoot = /*elementRoot*/
        ctx2[0];
        add_flush_callback(() => updating_elementRoot = false);
      }
      if (!updating_stylesApp && dirty & /*stylesApp*/
      4) {
        updating_stylesApp = true;
        applicationshell_changes.stylesApp = /*stylesApp*/
        ctx2[2];
        add_flush_callback(() => updating_stylesApp = false);
      }
      applicationshell.$set(applicationshell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applicationshell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applicationshell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applicationshell, detaching);
    }
  };
}
__name(create_fragment$n, "create_fragment$n");
let activeTab = "attributes";
function instance$j($$self, $$props, $$invalidate) {
  let tabs;
  let $documentStore, $$unsubscribe_documentStore = noop, $$subscribe_documentStore = /* @__PURE__ */ __name(() => ($$unsubscribe_documentStore(), $$unsubscribe_documentStore = subscribe(documentStore, ($$value) => $$invalidate(9, $documentStore = $$value)), documentStore), "$$subscribe_documentStore");
  let $applicationWindowHeaderIconsOnly;
  let $headerButtonNoLabel;
  $$self.$$.on_destroy.push(() => $$unsubscribe_documentStore());
  let { elementRoot } = $$props;
  let { documentStore } = $$props;
  $$subscribe_documentStore();
  setContext("#doc", documentStore);
  const application = getContext("#external").application;
  const applicationWindowHeaderIconsOnly2 = gameSettings.getStore("applicationWindowHeaderIconsOnly");
  component_subscribe($$self, applicationWindowHeaderIconsOnly2, (value) => $$invalidate(6, $applicationWindowHeaderIconsOnly = value));
  let headerButtonNoLabel = application.reactive.storeAppOptions.headerButtonNoLabel;
  component_subscribe($$self, headerButtonNoLabel, (value) => $$invalidate(10, $headerButtonNoLabel = value));
  const defaultTabs = [
    {
      label: localize$1("Tabs.Attributes"),
      id: "attributes",
      component: Attributes2,
      img: "/systems/foundryvtt-final-fantasy/assets/icons/tabs/tree.webp"
    },
    {
      label: localize$1("Tabs.Abilities"),
      id: "abilities",
      component: Abilities2,
      img: "/systems/foundryvtt-final-fantasy/assets/icons/tabs/sun.webp"
    },
    // { label: localize("Tabs.Inventory"), id: "inventory", component: Inventory, img: '/systems/foundryvtt-final-fantasy/assets/icons/tabs/backpack.webp'},
    // { label: localize("Tabs.Profile"), id: "profile", component: Profile, img: '/systems/foundryvtt-final-fantasy/assets/icons/tabs/mask.webp' },
    {
      label: localize$1("Tabs.Effects"),
      id: "effect",
      component: EffectsTab,
      img: "/systems/foundryvtt-final-fantasy/assets/icons/tabs/spiral.webp"
    }
  ];
  let stylesApp;
  onMount(async () => {
    game.system.log.d($documentStore);
  });
  function applicationshell_elementRoot_binding(value) {
    elementRoot = value;
    $$invalidate(0, elementRoot);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  function applicationshell_stylesApp_binding(value) {
    stylesApp = value;
    $$invalidate(2, stylesApp);
  }
  __name(applicationshell_stylesApp_binding, "applicationshell_stylesApp_binding");
  $$self.$$set = ($$props2) => {
    if ("elementRoot" in $$props2)
      $$invalidate(0, elementRoot = $$props2.elementRoot);
    if ("documentStore" in $$props2)
      $$subscribe_documentStore($$invalidate(1, documentStore = $$props2.documentStore));
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$applicationWindowHeaderIconsOnly*/
    64) {
      set_store_value(headerButtonNoLabel, $headerButtonNoLabel = $applicationWindowHeaderIconsOnly, $headerButtonNoLabel);
    }
  };
  $$invalidate(3, tabs = defaultTabs);
  return [
    elementRoot,
    documentStore,
    stylesApp,
    tabs,
    applicationWindowHeaderIconsOnly2,
    headerButtonNoLabel,
    $applicationWindowHeaderIconsOnly,
    applicationshell_elementRoot_binding,
    applicationshell_stylesApp_binding
  ];
}
__name(instance$j, "instance$j");
class NPCSheetShell extends SvelteComponent {
  static {
    __name(this, "NPCSheetShell");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$j, create_fragment$n, safe_not_equal, { elementRoot: 0, documentStore: 1 });
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(elementRoot) {
    this.$$set({ elementRoot });
    flush();
  }
  get documentStore() {
    return this.$$.ctx[1];
  }
  set documentStore(documentStore) {
    this.$$set({ documentStore });
    flush();
  }
}
class FFXIVActorSheet2 extends SvelteDocumentSheet {
  static {
    __name(this, "FFXIVActorSheet");
  }
  /**
   * Default Application options
   * @return {object} The default options for configuring the application window - Application options.
   * @see https://foundryvtt.com/api/Application.html#options
   */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      id: `${SYSTEM_ID}--actor-sheet-${generateRandomElementId()}`,
      width: 342,
      height: 533,
      minHeight: 180,
      minWidth: 282,
      // id: `${SYSTEM_ID}--actor-sheet`, // @deprecated: I don't know why we need an ID for this? And having a non-unique ID causes https://github.com/geoidesic/foundryvtt-final-fantasy/issues/8
      classes: [SYSTEM_CODE],
      headerButtonNoLabel: game.settings.get(SYSTEM_ID, "applicationWindowHeaderIconsOnly") || false,
      //- @why: without this the initial value on first load of this app after a page refresh will be wrong, despite a reactive setting in the .svelte template; I don't really know why
      dragDrop: [{ dragSelector: ".directory-list .item", dropSelector: null }],
      svelte: {
        class: NPCSheetShell,
        target: document.body
      }
    });
  }
  /**
   * Closes the actor sheet and updates editing state
   * @param {object} options - Options which affect how the window is closed
   * @return {Promise<void>} Returns a promise that resolves when the sheet is closed
   */
  async close(options = {}) {
    this.reactive.document?.update({ system: { isEditing: false } });
    await super.close(options);
  }
  /**
   * Gets the header buttons configuration for the sheet
   * @return {Array<object>} Returns an array of button configurations for the sheet header
   */
  _getHeaderButtons() {
    const buttons = super._getHeaderButtons();
    const canConfigure = game.user.isGM || this.reactive.document.isOwner && game.user.can("TOKEN_CONFIGURE");
    if (this.reactive.document.documentName === "Actor") {
      if (canConfigure) {
        buttons.unshift({
          label: this.token ? "Token" : "TOKEN.TitlePrototype",
          class: "configure-token",
          icon: "fas fa-user-circle",
          onclick: (ev) => this._onConfigureToken(ev)
        });
      }
    }
    const canEdit = game.user.isGM || this.reactive.document.isOwner;
    if (canEdit) {
      buttons.unshift({
        label: localize$1("Types.Actor.HeaderButtons.Edit"),
        class: "edit-sheet" + (this.reactive.document.system.isEditing ? " active" : ""),
        icon: "fas " + (this.reactive.document.system.isEditing ? "fa-toggle-on" : "fa-toggle-off"),
        // onclick: (ev) => this._onToggleEdit(ev),
        onPress: (ev) => {
          this._onToggleEdit(ev);
        }
      });
    }
    return buttons;
  }
  /**
   * Handles toggling the edit mode of the sheet
   * @param {Event} event - The triggering event
   * @return {Promise<void>} Returns a promise that resolves when the edit mode is toggled
   */
  async _onToggleEdit(event) {
    game.system.log.p("[TOGGLE EDIT] _onToggleEdit event", event);
    if (event?.event) {
      event.event.preventDefault();
    }
    await this.reactive.document.update({ system: { isEditing: !this.reactive.document.system.isEditing } });
    this.render();
  }
  /**
   * Opens the token configuration application
   * @param {Event} event - The triggering event
   * @return {void}
   */
  _onConfigureToken(event) {
    if (event) {
      event.preventDefault();
    }
    const actor = this.reactive.document;
    const token = actor.isToken ? actor.token : actor.prototypeToken;
    new CONFIG.Token.prototypeSheetClass(token, {
      left: Math.max(this.position.left - 560 - 10, 10),
      top: this.position.top
    }).render(true);
  }
  /**
   * Determines if dragging can start from the given selector
   * @param {string} selector - The selector to check
   * @return {boolean} Whether dragging can start
   */
  _canDragStart(selector) {
    return true;
  }
  /**
   * Determines if drag and drop is allowed
   * @param {string} selector - The selector to check
   * @return {boolean} Whether drag and drop is allowed
   */
  _canDragDrop(selector) {
    return this.reactive.document.isOwner || game.user.isGM;
  }
  /**
   * Handles drag over events
   * @param {DragEvent} event - The drag event
   * @return {void}
   */
  _onDragOver(event) {
  }
  /**
   * Handles the start of a drag operation
   * @param {DragEvent} event - The drag event
   * @return {void}
   */
  _onDragStart(event) {
    {
      const li = event.currentTarget;
      if (event.target.classList.contains("content-link")) {
        return;
      }
      let dragData;
      if (li.dataset.itemId) {
        const item = this.actor.items.get(li.dataset.itemId);
        dragData = item.toDragData();
      }
      if (li.dataset.effectId) {
        const effect = this.actor.effects.get(li.dataset.effectId);
        dragData = effect.toDragData();
      }
      if (!dragData) {
        return;
      }
      event.dataTransfer.setData("text/plain", JSON.stringify(dragData));
    }
  }
  /**
   * Handles dropping content onto the sheet
   * @param {DragEvent} event - The drop event
   * @return {Promise<void|boolean|ActiveEffect|Item>} The result of the drop operation
   */
  async _onDrop(event) {
    const data = TextEditor.getDragEventData(event);
    const actor = this.reactive.document;
    if (actor.documentName !== "Actor") {
      return;
    }
    const allowed = Hooks.call("dropActorSheetData", actor, this, data);
    if (allowed === false) {
      return;
    }
    switch (data.type) {
      case "ActiveEffect": {
        return await this._onDropActiveEffect(event, data);
      }
      case "Actor": {
        return await this._onDropActor(event, data);
      }
      case "Item": {
        return await this._onDropItem(event, data);
      }
      case "Folder": {
        return await this._onDropFolder(event, data);
      }
      default: {
        log.e(`Impossible type "${data.type}" in _onDrop.`);
        return;
      }
    }
  }
  /**
   * Handles dropping an active effect onto the sheet
   * @param {DragEvent} event - The drop event
   * @param {object} data - The dropped data
   * @return {Promise<boolean|ActiveEffect>} The created effect or false if failed
   */
  async _onDropActiveEffect(event, data) {
    const actor = this.reactive.document;
    const effect = await ActiveEffect.implementation.fromDropData(data);
    if (!actor.isOwner || !effect) {
      return false;
    }
    if (actor.uuid === effect.parent.uuid) {
      return false;
    }
    return ActiveEffect.create(effect.toObject(), { parent: actor });
  }
  /**
   * Handles dropping an actor onto the sheet
   * @param {DragEvent} event - The drop event
   * @param {object} data - The dropped data
   * @return {Promise<boolean>} Whether the drop was successful
   */
  async _onDropActor(event, data) {
    const actor = this.reactive.document;
    if (!actor.isOwner) {
      return false;
    }
  }
  /**
   * Handles dropping an item onto the sheet
   * @param {DragEvent} event - The drop event
   * @param {object} data - The dropped data
   * @param {boolean} ignoreValidation - Whether to ignore validation
   * @return {Promise<boolean|Item>} The created item or false if the operation failed
   */
  async _onDropItem(event, data, ignoreValidation = false) {
    const actor = this.reactive.document;
    if (!actor.isOwner) {
      ui.notifications.error(localize$1("Errors.NotOwner"));
      return false;
    }
    const droppedItem = await fromUuid(data.uuid);
    if (droppedItem.type === "job") {
      return this._onDropJob(event, data);
    }
    if (droppedItem.type === "effect") {
      ui.notifications.error(localize$1("Errors.EffectItemsNotAllowed"));
      return false;
    }
    const duplicate = actor.items.find((x) => x.name == droppedItem.name);
    if (duplicate) {
      await duplicate.update({ system: { quantity: duplicate.system.quantity + 1 } });
      ui.notifications.info(`Found matching item "${duplicate.name}" and incremented quantity.`);
      return;
    }
    const item = await Item.implementation.fromDropData(data);
    const itemData = item.toObject();
    if (actor.uuid === item.parent?.uuid) {
      return this._onSortItem(event, itemData);
    }
    return this._onDropItemCreate(itemData);
  }
  /**
   * Handles dropping a folder onto the sheet
   * @param {DragEvent} event - The drop event
   * @param {object} data - The dropped data
   * @return {Promise<Array>} Array of created items
   */
  async _onDropFolder(event, data) {
    const actor = this.reactive.document;
    const folder = await Folder.implementation.fromDropData(data);
    if (!folder && data.documentName !== "Item" && !actor.isOwner) {
      return [];
    }
    if (folder.contents.length) {
      for (const item of folder.contents) {
        await this._onDropItem(event, item, true);
      }
    }
  }
  /**
   * Handles dropping a job onto the sheet
   * @param {DragEvent} event - The drop event
   * @param {object} data - The dropped data
   * @return {Promise<boolean|void>} Whether the drop was successful
   */
  async _onDropJob(event, data) {
    const actor = this.reactive.document;
    if (!actor.isOwner) {
      return false;
    }
    const job = await fromUuid(data.uuid);
    const grants = job.system.grants;
    const grantItems = [];
    for (const grantObject of grants.list) {
      const grantItem = await fromUuid(grantObject.uuid);
      if (!actor.items.some((x) => x.name === grantItem.name)) {
        grantItems.push(grantItem);
      }
    }
    await actor.createEmbeddedDocuments("Item", grantItems);
    await actor.update({
      system: {
        job: {
          uuid: job.uuid,
          name: job.name,
          grants: grants.list,
          level: job.system.level,
          role: job.system.role,
          img: job.img
        }
      }
    });
  }
  /**
   * Creates new items from dropped data
   * @param {object|Array} itemData - The item data to create
   * @return {Promise<void>} Returns a promise that resolves when the items have been created
   */
  async _onDropItemCreate(itemData) {
    itemData = itemData instanceof Array ? itemData : [itemData];
    const actor = this.reactive.document;
    for (const v of itemData) {
      await actor.createEmbeddedDocuments("Item", [v]);
    }
  }
  /**
   * Handles sorting items within the actor's inventory
   * @param {Event} event - The triggering event
   * @param {object} itemData - The item data being sorted
   * @return {Promise<Item[]>} The updated items
   */
  _onSortItem(event, itemData) {
    const actor = this.reactive.document;
    const items = actor.items;
    const source = items.get(itemData._id);
    const dropTarget = event.target.closest("[data-item-id]");
    const target = items.get(dropTarget.dataset.itemId);
    if (source.id === target.id) {
      return;
    }
    const siblings = [];
    for (const el of dropTarget.parentElement.children) {
      const siblingId = el.dataset.itemId;
      if (siblingId && siblingId !== source.id) {
        siblings.push(items.get(el.dataset.itemId));
      }
    }
    const sortUpdates = SortingHelpers.performIntegerSort(source, { target, siblings });
    const updateData = sortUpdates.map((u) => {
      const update2 = u.update;
      update2._id = u.target.data._id;
      return update2;
    });
    return actor.updateEmbeddedDocuments("Item", updateData);
  }
}
function create_fragment$m(ctx) {
  let div1;
  let div0;
  let prosemirror;
  let current;
  prosemirror = new ProseMirror$1({ props: { attr: "system.description" } });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(prosemirror.$$.fragment);
      attr(div0, "class", "flexcol flex3 left high");
      attr(div1, "class", "item-sheet details overflow high svelte-1hen0dc");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(prosemirror, div0, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(prosemirror.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(prosemirror.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(prosemirror);
    }
  };
}
__name(create_fragment$m, "create_fragment$m");
function instance$i($$self, $$props, $$invalidate) {
  let { sheet } = $$props;
  $$self.$$set = ($$props2) => {
    if ("sheet" in $$props2)
      $$invalidate(0, sheet = $$props2.sheet);
  };
  return [sheet];
}
__name(instance$i, "instance$i");
class DescriptionTab extends SvelteComponent {
  static {
    __name(this, "DescriptionTab");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$i, create_fragment$m, safe_not_equal, { sheet: 0 });
  }
}
function get_each_context$4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i];
  return child_ctx;
}
__name(get_each_context$4, "get_each_context$4");
function create_if_block$7(ctx) {
  let each_1_anchor;
  let each_value = ensure_array_like(
    /*options*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*options*/
      1) {
        each_value = ensure_array_like(
          /*options*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$4(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
__name(create_if_block$7, "create_if_block$7");
function create_each_block$4(ctx) {
  let option_1;
  let t0_value = (
    /*option*/
    ctx[8].label + ""
  );
  let t0;
  let t1;
  let option_1_value_value;
  return {
    c() {
      option_1 = element("option");
      t0 = text(t0_value);
      t1 = space();
      option_1.__value = option_1_value_value = /*option*/
      ctx[8].value;
      set_input_value(option_1, option_1.__value);
    },
    m(target, anchor) {
      insert(target, option_1, anchor);
      append(option_1, t0);
      append(option_1, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*options*/
      1 && t0_value !== (t0_value = /*option*/
      ctx2[8].label + ""))
        set_data(t0, t0_value);
      if (dirty & /*options*/
      1 && option_1_value_value !== (option_1_value_value = /*option*/
      ctx2[8].value)) {
        option_1.__value = option_1_value_value;
        set_input_value(option_1, option_1.__value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(option_1);
      }
    }
  };
}
__name(create_each_block$4, "create_each_block$4");
function create_fragment$l(ctx) {
  let select;
  let option_1;
  let t;
  let option_1_selected_value;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*options*/
    ctx[0] && /*options*/
    ctx[0].length && create_if_block$7(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let select_levels = [
    /*$$restProps*/
    ctx[4],
    { disabled: (
      /*disabled*/
      ctx[2]
    ) }
  ];
  let select_data = {};
  for (let i = 0; i < select_levels.length; i += 1) {
    select_data = assign(select_data, select_levels[i]);
  }
  return {
    c() {
      select = element("select");
      option_1 = element("option");
      t = text("Please select an option");
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      if (default_slot)
        default_slot.c();
      option_1.__value = "";
      set_input_value(option_1, option_1.__value);
      option_1.disabled = true;
      option_1.selected = option_1_selected_value = !/*value*/
      ctx[1];
      set_attributes(select, select_data);
      toggle_class(select, "svelte-76qduf", true);
    },
    m(target, anchor) {
      insert(target, select, anchor);
      append(select, option_1);
      append(option_1, t);
      if (if_block)
        if_block.m(select, null);
      append(select, if_block_anchor);
      if (default_slot) {
        default_slot.m(select, null);
      }
      "value" in select_data && (select_data.multiple ? select_options : select_option)(select, select_data.value);
      if (select.autofocus)
        select.focus();
      current = true;
      if (!mounted) {
        dispose = listen(
          select,
          "change",
          /*handleChange*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*value*/
      2 && option_1_selected_value !== (option_1_selected_value = !/*value*/
      ctx2[1])) {
        option_1.selected = option_1_selected_value;
      }
      if (
        /*options*/
        ctx2[0] && /*options*/
        ctx2[0].length
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$7(ctx2);
          if_block.c();
          if_block.m(select, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(select, select_data = get_spread_update(select_levels, [
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        (!current || dirty & /*disabled*/
        4) && { disabled: (
          /*disabled*/
          ctx2[2]
        ) }
      ]));
      if (dirty & /*$$restProps, disabled*/
      20 && "value" in select_data)
        (select_data.multiple ? select_options : select_option)(select, select_data.value);
      toggle_class(select, "svelte-76qduf", true);
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(select);
      }
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
__name(create_fragment$l, "create_fragment$l");
function instance$h($$self, $$props, $$invalidate) {
  const omit_props_names = ["options", "value", "disabled"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  const dispatch2 = createEventDispatcher();
  let { options = void 0 } = $$props;
  let { value = null } = $$props;
  let { disabled = false } = $$props;
  function handleChange(event) {
    dispatch2("change", { value: event.target.value });
  }
  __name(handleChange, "handleChange");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("options" in $$new_props)
      $$invalidate(0, options = $$new_props.options);
    if ("value" in $$new_props)
      $$invalidate(1, value = $$new_props.value);
    if ("disabled" in $$new_props)
      $$invalidate(2, disabled = $$new_props.disabled);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  return [options, value, disabled, handleChange, $$restProps, $$scope, slots];
}
__name(instance$h, "instance$h");
class ArraySelect extends SvelteComponent {
  static {
    __name(this, "ArraySelect");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$h, create_fragment$l, safe_not_equal, { options: 0, value: 1, disabled: 2 });
  }
}
function get_each_context$3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[15] = list[i];
  child_ctx[17] = i;
  return child_ctx;
}
__name(get_each_context$3, "get_each_context$3");
function create_if_block$6(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*durations*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
  }
  const out = /* @__PURE__ */ __name((i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  }), "out");
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*durationUnitsOptions, durations, updateDuration, durationQualifierOptions, durationOptions, durationTypeOptions, removeDuration*/
      445) {
        each_value = ensure_array_like(
          /*durations*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
__name(create_if_block$6, "create_if_block$6");
function create_if_block_1$4(ctx) {
  let div2;
  let div0;
  let if_block0_anchor;
  let div1;
  let div3;
  let if_block2_anchor;
  let if_block3_anchor;
  let current;
  let if_block0 = (
    /*duration*/
    ctx[15].type === "hasAmount" && create_if_block_6$1(ctx)
  );
  let if_block1 = (
    /*duration*/
    ctx[15].type === "hasQualifier" && create_if_block_5$1(ctx)
  );
  let if_block2 = (
    /*duration*/
    ctx[15].type === "hasAmount" && create_if_block_4$1(ctx)
  );
  let if_block3 = (
    /*duration*/
    ctx[15].type === "hasQualifier" && create_if_block_3$2(ctx)
  );
  let if_block4 = (
    /*duration*/
    (ctx[15].type === "hasAmount" || /*duration*/
    ctx[15].qualifier && /*duration*/
    (ctx[15].type === "hasQualifier" && /*duration*/
    ctx[15].qualifier !== "untilDamage" && /*duration*/
    ctx[15].qualifier !== "nextAbility")) && create_if_block_2$4(ctx)
  );
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      if_block0_anchor = empty();
      if (if_block1)
        if_block1.c();
      div1 = element("div");
      div1.textContent = "Units";
      div3 = element("div");
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
      if (if_block3)
        if_block3.c();
      if_block3_anchor = empty();
      if (if_block4)
        if_block4.c();
      attr(div0, "class", "flex3 left");
      attr(div1, "class", "flex1 right");
      attr(div2, "class", "flexrow sheet-row justify-vertical wide px-sm bg-black pa-sm");
      attr(div3, "class", "flexrow sheet-row justify-vertical wide px-sm border");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append(div0, if_block0_anchor);
      if (if_block1)
        if_block1.m(div0, null);
      append(div2, div1);
      insert(target, div3, anchor);
      if (if_block2)
        if_block2.m(div3, null);
      append(div3, if_block2_anchor);
      if (if_block3)
        if_block3.m(div3, null);
      append(div3, if_block3_anchor);
      if (if_block4)
        if_block4.m(div3, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*duration*/
        ctx2[15].type === "hasAmount"
      ) {
        if (if_block0)
          ;
        else {
          if_block0 = create_if_block_6$1(ctx2);
          if_block0.c();
          if_block0.m(div0, if_block0_anchor);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*duration*/
        ctx2[15].type === "hasQualifier"
      ) {
        if (if_block1)
          ;
        else {
          if_block1 = create_if_block_5$1(ctx2);
          if_block1.c();
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*duration*/
        ctx2[15].type === "hasAmount"
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*durations*/
          1) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_4$1(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div3, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*duration*/
        ctx2[15].type === "hasQualifier"
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & /*durations*/
          1) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_3$2(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div3, if_block3_anchor);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (
        /*duration*/
        ctx2[15].type === "hasAmount" || /*duration*/
        ctx2[15].qualifier && /*duration*/
        (ctx2[15].type === "hasQualifier" && /*duration*/
        ctx2[15].qualifier !== "untilDamage" && /*duration*/
        ctx2[15].qualifier !== "nextAbility")
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty & /*durations*/
          1) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_2$4(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div3, null);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      current = true;
    },
    o(local) {
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
        detach(div3);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
    }
  };
}
__name(create_if_block_1$4, "create_if_block_1$4");
function create_if_block_6$1(ctx) {
  let label;
  return {
    c() {
      label = element("label");
      label.textContent = `${localize$1("Types.Item.Types.Options.DurationAmount.label")}`;
      attr(label, "for", `durationAmount${/*i*/
      ctx[17]}`);
      attr(label, "class", "svelte-sihn49");
    },
    m(target, anchor) {
      insert(target, label, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(label);
      }
    }
  };
}
__name(create_if_block_6$1, "create_if_block_6$1");
function create_if_block_5$1(ctx) {
  let label;
  return {
    c() {
      label = element("label");
      label.textContent = `${localize$1("Types.Item.Types.Options.DurationQualifier.label")}`;
      attr(label, "for", `durationQualifier${/*i*/
      ctx[17]}`);
      attr(label, "class", "svelte-sihn49");
    },
    m(target, anchor) {
      insert(target, label, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(label);
      }
    }
  };
}
__name(create_if_block_5$1, "create_if_block_5$1");
function create_if_block_4$1(ctx) {
  let div;
  let arrayselect;
  let current;
  function change_handler_1(...args) {
    return (
      /*change_handler_1*/
      ctx[12](
        /*i*/
        ctx[17],
        ...args
      )
    );
  }
  __name(change_handler_1, "change_handler_1");
  arrayselect = new ArraySelect({
    props: {
      class: "left wide",
      id: `durationAmount${/*i*/
      ctx[17]}`,
      options: (
        /*durationOptions*/
        ctx[4]
      ),
      value: (
        /*duration*/
        ctx[15].amount
      )
    }
  });
  arrayselect.$on("change", change_handler_1);
  return {
    c() {
      div = element("div");
      create_component(arrayselect.$$.fragment);
      attr(div, "class", "flex3 left nowrap");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(arrayselect, div, null);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const arrayselect_changes = {};
      if (dirty & /*durations*/
      1)
        arrayselect_changes.value = /*duration*/
        ctx[15].amount;
      arrayselect.$set(arrayselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(arrayselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(arrayselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(arrayselect);
    }
  };
}
__name(create_if_block_4$1, "create_if_block_4$1");
function create_if_block_3$2(ctx) {
  let div;
  let arrayselect;
  let current;
  function change_handler_2(...args) {
    return (
      /*change_handler_2*/
      ctx[13](
        /*i*/
        ctx[17],
        ...args
      )
    );
  }
  __name(change_handler_2, "change_handler_2");
  arrayselect = new ArraySelect({
    props: {
      class: "left wide",
      id: `durationQualifier${/*i*/
      ctx[17]}`,
      options: (
        /*durationQualifierOptions*/
        ctx[3]
      ),
      value: (
        /*duration*/
        ctx[15].qualifier
      )
    }
  });
  arrayselect.$on("change", change_handler_2);
  return {
    c() {
      div = element("div");
      create_component(arrayselect.$$.fragment);
      attr(div, "class", "flex2 left nowrap");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(arrayselect, div, null);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const arrayselect_changes = {};
      if (dirty & /*durations*/
      1)
        arrayselect_changes.value = /*duration*/
        ctx[15].qualifier;
      arrayselect.$set(arrayselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(arrayselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(arrayselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(arrayselect);
    }
  };
}
__name(create_if_block_3$2, "create_if_block_3$2");
function create_if_block_2$4(ctx) {
  let div;
  let arrayselect;
  let current;
  function change_handler_3(...args) {
    return (
      /*change_handler_3*/
      ctx[14](
        /*i*/
        ctx[17],
        ...args
      )
    );
  }
  __name(change_handler_3, "change_handler_3");
  arrayselect = new ArraySelect({
    props: {
      class: "right wide",
      id: `durationUnits${/*i*/
      ctx[17]}`,
      options: (
        /*durationUnitsOptions*/
        ctx[5]
      ),
      value: (
        /*duration*/
        ctx[15].units
      )
    }
  });
  arrayselect.$on("change", change_handler_3);
  return {
    c() {
      div = element("div");
      create_component(arrayselect.$$.fragment);
      attr(div, "class", "flex2 right");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(arrayselect, div, null);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const arrayselect_changes = {};
      if (dirty & /*durations*/
      1)
        arrayselect_changes.value = /*duration*/
        ctx[15].units;
      arrayselect.$set(arrayselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(arrayselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(arrayselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(arrayselect);
    }
  };
}
__name(create_if_block_2$4, "create_if_block_2$4");
function create_each_block$3(ctx) {
  let div6;
  let div2;
  let div0;
  let h3;
  let div1;
  let button;
  let div5;
  let div3;
  let label;
  let div4;
  let arrayselect;
  let current;
  let mounted;
  let dispose;
  function click_handler2() {
    return (
      /*click_handler*/
      ctx[10](
        /*i*/
        ctx[17]
      )
    );
  }
  __name(click_handler2, "click_handler");
  function change_handler(...args) {
    return (
      /*change_handler*/
      ctx[11](
        /*i*/
        ctx[17],
        ...args
      )
    );
  }
  __name(change_handler, "change_handler");
  arrayselect = new ArraySelect({
    props: {
      class: "left",
      id: `durationType${/*i*/
      ctx[17]}`,
      options: (
        /*durationTypeOptions*/
        ctx[2]
      ),
      value: (
        /*duration*/
        ctx[15].type
      )
    }
  });
  arrayselect.$on("change", change_handler);
  let if_block = (
    /*duration*/
    (ctx[15].type === "hasAmount" || /*duration*/
    ctx[15].type === "hasQualifier") && create_if_block_1$4(ctx)
  );
  return {
    c() {
      div6 = element("div");
      div2 = element("div");
      div0 = element("div");
      h3 = element("h3");
      h3.textContent = `${localize$1("EFFECT.Duration.Title")} ${/*i*/
      ctx[17] + 1}`;
      div1 = element("div");
      button = element("button");
      button.innerHTML = `<i class="fas fa-times svelte-sihn49"></i>`;
      div5 = element("div");
      div3 = element("div");
      label = element("label");
      label.textContent = `${localize$1("Types.Item.Types.Options.DurationType.label")}`;
      div4 = element("div");
      create_component(arrayselect.$$.fragment);
      if (if_block)
        if_block.c();
      attr(h3, "class", "left");
      attr(div0, "class", "flex4");
      attr(button, "class", "small gold svelte-sihn49");
      attr(div1, "class", "flex0 right");
      attr(div2, "class", "flexrow justify-vertical wide");
      attr(label, "for", `durationType${/*i*/
      ctx[17]}`);
      attr(label, "class", "svelte-sihn49");
      attr(div3, "class", "flex1");
      attr(div4, "class", "flex1");
      attr(div5, "class", "flexrow sheet-row justify-vertical wide px-sm");
      attr(div6, "class", "subsection svelte-sihn49");
    },
    m(target, anchor) {
      insert(target, div6, anchor);
      append(div6, div2);
      append(div2, div0);
      append(div0, h3);
      append(div2, div1);
      append(div1, button);
      append(div6, div5);
      append(div5, div3);
      append(div3, label);
      append(div5, div4);
      mount_component(arrayselect, div4, null);
      if (if_block)
        if_block.m(div6, null);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", click_handler2);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const arrayselect_changes = {};
      if (dirty & /*durations*/
      1)
        arrayselect_changes.value = /*duration*/
        ctx[15].type;
      arrayselect.$set(arrayselect_changes);
      if (
        /*duration*/
        ctx[15].type === "hasAmount" || /*duration*/
        ctx[15].type === "hasQualifier"
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & /*durations*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$4(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div6, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(arrayselect.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(arrayselect.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div6);
      }
      destroy_component(arrayselect);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
__name(create_each_block$3, "create_each_block$3");
function create_fragment$k(ctx) {
  let div3;
  let div2;
  let div0;
  let div1;
  let button;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*durations*/
    ctx[0] && /*durations*/
    ctx[0].length > 0 && create_if_block$6(ctx)
  );
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      div0.innerHTML = `<h2 class="left">Duration</h2>`;
      div1 = element("div");
      button = element("button");
      button.innerHTML = `<i class="fas fa-plus svelte-sihn49"></i>`;
      if (if_block)
        if_block.c();
      attr(div0, "class", "flex4");
      attr(button, "class", "small gold svelte-sihn49");
      attr(div1, "class", "flex0 right");
      attr(div2, "class", "flexrow justify-vertical");
      attr(div3, "class", "duration");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div0);
      append(div2, div1);
      append(div1, button);
      if (if_block)
        if_block.m(div3, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*addDuration*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*durations*/
        ctx2[0] && /*durations*/
        ctx2[0].length > 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*durations*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$6(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div3, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
__name(create_fragment$k, "create_fragment$k");
function instance$g($$self, $$props, $$invalidate) {
  let durations;
  let $item;
  const item = getContext("#doc");
  component_subscribe($$self, item, (value) => $$invalidate(9, $item = value));
  const durationTypeOptions = getDurationTypeOptions();
  const durationQualifierOptions = getDurationQualifierOptions();
  const durationOptions = getDurationOptions();
  const durationUnitsOptions = getDurationUnits();
  async function addDuration() {
    const existingDurations = [...$item.system.durations || []];
    existingDurations.push({
      type: null,
      amount: null,
      units: "rounds",
      qualifier: ""
    });
    await $item.update({ system: { durations: existingDurations } });
    game.system.log.pink(`Added duration: ${existingDurations}`, $item);
  }
  __name(addDuration, "addDuration");
  function removeDuration(index) {
    const existingDurations = [...$item.system.durations];
    existingDurations.splice(index, 1);
    $item.update({ system: { durations: existingDurations } });
  }
  __name(removeDuration, "removeDuration");
  async function updateDuration(index, field, value) {
    const updatedDurations = [...durations];
    updatedDurations[index] = {
      ...updatedDurations[index],
      [field]: value
    };
    await $item.update({ "system.durations": updatedDurations });
  }
  __name(updateDuration, "updateDuration");
  const click_handler2 = /* @__PURE__ */ __name((i) => removeDuration(i), "click_handler");
  const change_handler = /* @__PURE__ */ __name((i, e) => updateDuration(i, "type", e.detail.value), "change_handler");
  const change_handler_1 = /* @__PURE__ */ __name((i, e) => updateDuration(i, "amount", e.detail.value), "change_handler_1");
  const change_handler_2 = /* @__PURE__ */ __name((i, e) => updateDuration(i, "qualifier", e.detail.value), "change_handler_2");
  const change_handler_3 = /* @__PURE__ */ __name((i, e) => updateDuration(i, "units", e.detail.value), "change_handler_3");
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$item*/
    512) {
      $$invalidate(0, durations = $item.system.durations);
    }
  };
  return [
    durations,
    item,
    durationTypeOptions,
    durationQualifierOptions,
    durationOptions,
    durationUnitsOptions,
    addDuration,
    removeDuration,
    updateDuration,
    $item,
    click_handler2,
    change_handler,
    change_handler_1,
    change_handler_2,
    change_handler_3
  ];
}
__name(instance$g, "instance$g");
class Duration2 extends SvelteComponent {
  static {
    __name(this, "Duration");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$g, create_fragment$k, safe_not_equal, {});
  }
}
function create_else_block(ctx) {
  let h3;
  return {
    c() {
      h3 = element("h3");
      h3.textContent = `${localize$1("Types.Item.Types.action.BaseEffect")}`;
      attr(h3, "class", "left");
    },
    m(target, anchor) {
      insert(target, h3, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(h3);
      }
    }
  };
}
__name(create_else_block, "create_else_block");
function create_if_block_17(ctx) {
  let h2;
  return {
    c() {
      h2 = element("h2");
      h2.textContent = `${localize$1("Types.Item.Types.action.BaseEffect")}`;
      attr(h2, "class", "left");
    },
    m(target, anchor) {
      insert(target, h2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(h2);
      }
    }
  };
}
__name(create_if_block_17, "create_if_block_17");
function create_if_block_12(ctx) {
  let div12;
  let div2;
  let div0;
  let h30;
  let div1;
  let doccheckbox0;
  let div5;
  let div3;
  let h31;
  let div4;
  let doccheckbox1;
  let div8;
  let div6;
  let h32;
  let div7;
  let doccheckbox2;
  let div11;
  let div9;
  let h33;
  let div10;
  let doccheckbox3;
  let current;
  doccheckbox0 = new DocCheckbox({
    props: {
      name: "hasBaseEffectBarrier",
      valuePath: "system.hasBaseEffectBarrier"
    }
  });
  let if_block0 = (
    /*$item*/
    ctx[0].system.hasBaseEffectBarrier && create_if_block_16()
  );
  doccheckbox1 = new DocCheckbox({
    props: {
      name: "hasBaseEffectDamage",
      valuePath: "system.hasBaseEffectDamage"
    }
  });
  let if_block1 = (
    /*$item*/
    ctx[0].system.hasBaseEffectDamage && create_if_block_15()
  );
  doccheckbox2 = new DocCheckbox({
    props: {
      name: "hasBaseEffectHealing",
      valuePath: "system.hasBaseEffectHealing"
    }
  });
  let if_block2 = (
    /*$item*/
    ctx[0].system.hasBaseEffectHealing && create_if_block_14(ctx)
  );
  doccheckbox3 = new DocCheckbox({
    props: {
      name: "hasBaseEffectRestoreMP",
      valuePath: "system.hasBaseEffectRestoreMP"
    }
  });
  let if_block3 = (
    /*$item*/
    ctx[0].system.hasBaseEffectRestoreMP && create_if_block_13()
  );
  return {
    c() {
      div12 = element("div");
      div2 = element("div");
      div0 = element("div");
      h30 = element("h3");
      h30.textContent = `${localize$1("Types.Item.Types.action.BaseEffectBarrier")}`;
      div1 = element("div");
      create_component(doccheckbox0.$$.fragment);
      if (if_block0)
        if_block0.c();
      div5 = element("div");
      div3 = element("div");
      h31 = element("h3");
      h31.textContent = `${localize$1("Types.Item.Types.action.BaseEffectDamage")}`;
      div4 = element("div");
      create_component(doccheckbox1.$$.fragment);
      if (if_block1)
        if_block1.c();
      div8 = element("div");
      div6 = element("div");
      h32 = element("h3");
      h32.textContent = `${localize$1("Types.Item.Types.action.BaseEffectHealing")}`;
      div7 = element("div");
      create_component(doccheckbox2.$$.fragment);
      if (if_block2)
        if_block2.c();
      div11 = element("div");
      div9 = element("div");
      h33 = element("h3");
      h33.textContent = `${localize$1("Types.Item.Types.action.BaseEffectRestoreMP")}`;
      div10 = element("div");
      create_component(doccheckbox3.$$.fragment);
      if (if_block3)
        if_block3.c();
      attr(h30, "class", "left");
      attr(div0, "class", "flex4");
      attr(div1, "class", "flex0 right");
      attr(div2, "class", "flexrow justify-vertical");
      attr(h31, "class", "left");
      attr(div3, "class", "flex4");
      attr(div4, "class", "flex0 right");
      attr(div5, "class", "flexrow justify-vertical");
      attr(h32, "class", "left");
      attr(div6, "class", "flex4");
      attr(div7, "class", "flex0 right");
      attr(div8, "class", "flexrow justify-vertical");
      attr(h33, "class", "left");
      attr(div9, "class", "flex4");
      attr(div10, "class", "flex0 right");
      attr(div11, "class", "flexrow justify-vertical");
      attr(div12, "class", "subsection svelte-mf8ncy");
    },
    m(target, anchor) {
      insert(target, div12, anchor);
      append(div12, div2);
      append(div2, div0);
      append(div0, h30);
      append(div2, div1);
      mount_component(doccheckbox0, div1, null);
      if (if_block0)
        if_block0.m(div12, null);
      append(div12, div5);
      append(div5, div3);
      append(div3, h31);
      append(div5, div4);
      mount_component(doccheckbox1, div4, null);
      if (if_block1)
        if_block1.m(div12, null);
      append(div12, div8);
      append(div8, div6);
      append(div6, h32);
      append(div8, div7);
      mount_component(doccheckbox2, div7, null);
      if (if_block2)
        if_block2.m(div12, null);
      append(div12, div11);
      append(div11, div9);
      append(div9, h33);
      append(div11, div10);
      mount_component(doccheckbox3, div10, null);
      if (if_block3)
        if_block3.m(div12, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*$item*/
        ctx2[0].system.hasBaseEffectBarrier
      ) {
        if (if_block0) {
          if (dirty & /*$item*/
          1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_16();
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div12, div5);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*$item*/
        ctx2[0].system.hasBaseEffectDamage
      ) {
        if (if_block1) {
          if (dirty & /*$item*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_15();
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div12, div8);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*$item*/
        ctx2[0].system.hasBaseEffectHealing
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*$item*/
          1) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_14(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div12, div11);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*$item*/
        ctx2[0].system.hasBaseEffectRestoreMP
      ) {
        if (if_block3) {
          if (dirty & /*$item*/
          1) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_13();
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div12, null);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(doccheckbox0.$$.fragment, local);
      transition_in(if_block0);
      transition_in(doccheckbox1.$$.fragment, local);
      transition_in(if_block1);
      transition_in(doccheckbox2.$$.fragment, local);
      transition_in(if_block2);
      transition_in(doccheckbox3.$$.fragment, local);
      transition_in(if_block3);
      current = true;
    },
    o(local) {
      transition_out(doccheckbox0.$$.fragment, local);
      transition_out(if_block0);
      transition_out(doccheckbox1.$$.fragment, local);
      transition_out(if_block1);
      transition_out(doccheckbox2.$$.fragment, local);
      transition_out(if_block2);
      transition_out(doccheckbox3.$$.fragment, local);
      transition_out(if_block3);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div12);
      }
      destroy_component(doccheckbox0);
      if (if_block0)
        if_block0.d();
      destroy_component(doccheckbox1);
      if (if_block1)
        if_block1.d();
      destroy_component(doccheckbox2);
      if (if_block2)
        if_block2.d();
      destroy_component(doccheckbox3);
      if (if_block3)
        if_block3.d();
    }
  };
}
__name(create_if_block_12, "create_if_block_12");
function create_if_block_16(ctx) {
  let div2;
  let div0;
  let label;
  let div1;
  let docinput;
  let current;
  docinput = new DocInput({
    props: {
      id: "baseEffectBP",
      name: "baseEffectBP",
      valuePath: "system.baseEffectBP"
    }
  });
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      label = element("label");
      label.textContent = `${localize$1("Types.Actor.Points.BP.Label")}`;
      div1 = element("div");
      create_component(docinput.$$.fragment);
      attr(label, "for", "baseEffectBP");
      attr(label, "class", "svelte-mf8ncy");
      attr(div0, "class", "flex3");
      attr(div1, "class", "flex2 right");
      attr(div2, "class", "flexrow sheet-row justify-vertical px-sm");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, label);
      append(div2, div1);
      mount_component(docinput, div1, null);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(docinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(docinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(docinput);
    }
  };
}
__name(create_if_block_16, "create_if_block_16");
function create_if_block_15(ctx) {
  let div2;
  let div0;
  let label;
  let div1;
  let docinput;
  let current;
  docinput = new DocInput({
    props: {
      id: "baseEffectDamage",
      name: "baseEffectDamage",
      valuePath: "system.baseEffectDamage"
    }
  });
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      label = element("label");
      label.textContent = `${localize$1("Damage")}`;
      div1 = element("div");
      create_component(docinput.$$.fragment);
      attr(label, "for", "baseEffectDamage");
      attr(label, "class", "svelte-mf8ncy");
      attr(div0, "class", "flex3");
      attr(div1, "class", "flex2 right");
      attr(div2, "class", "flexrow sheet-row justify-vertical px-sm");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, label);
      append(div2, div1);
      mount_component(docinput, div1, null);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(docinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(docinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(docinput);
    }
  };
}
__name(create_if_block_15, "create_if_block_15");
function create_if_block_14(ctx) {
  let div2;
  let div0;
  let label0;
  let div1;
  let docselect;
  let div5;
  let div3;
  let label1;
  let div4;
  let docinput;
  let current;
  docselect = new DocSelect({
    props: {
      class: "wide right",
      id: "baseEffectHealingType",
      name: "baseEffectHealingType",
      options: (
        /*baseEffectHealingTypeOptions*/
        ctx[12]
      ),
      valuePath: "system.baseEffectHealingType"
    }
  });
  docinput = new DocInput({
    props: {
      id: "baseEffectHealing",
      name: "baseEffectHealing",
      valuePath: "system.baseEffectHealing"
    }
  });
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      label0 = element("label");
      label0.textContent = `${localize$1("Type")}`;
      div1 = element("div");
      create_component(docselect.$$.fragment);
      div5 = element("div");
      div3 = element("div");
      label1 = element("label");
      label1.textContent = `${localize$1("Amount")}`;
      div4 = element("div");
      create_component(docinput.$$.fragment);
      attr(label0, "for", "baseEffectHealing");
      attr(label0, "class", "svelte-mf8ncy");
      attr(div0, "class", "flex3");
      attr(div1, "class", "flex4 right");
      attr(div2, "class", "flexrow sheet-row justify-vertical px-sm");
      attr(label1, "for", "baseEffectHealing");
      attr(label1, "class", "svelte-mf8ncy");
      attr(div3, "class", "flex3");
      attr(div4, "class", "flex4 right");
      attr(div5, "class", "flexrow sheet-row justify-vertical px-sm");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, label0);
      append(div2, div1);
      mount_component(docselect, div1, null);
      insert(target, div5, anchor);
      append(div5, div3);
      append(div3, label1);
      append(div5, div4);
      mount_component(docinput, div4, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(docselect.$$.fragment, local);
      transition_in(docinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(docselect.$$.fragment, local);
      transition_out(docinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
        detach(div5);
      }
      destroy_component(docselect);
      destroy_component(docinput);
    }
  };
}
__name(create_if_block_14, "create_if_block_14");
function create_if_block_13(ctx) {
  let div2;
  let div0;
  let label;
  let div1;
  let docinput;
  let current;
  docinput = new DocInput({
    props: {
      id: "baseEffectRestoreMP",
      name: "baseEffectRestoreMP",
      valuePath: "system.baseEffectRestoreMP"
    }
  });
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      label = element("label");
      label.textContent = `${localize$1("Types.Item.Types.action.BaseEffectRestoreMP")}`;
      div1 = element("div");
      create_component(docinput.$$.fragment);
      attr(label, "for", "baseEffectRestoreMP");
      attr(label, "class", "svelte-mf8ncy");
      attr(div0, "class", "flex3");
      attr(div1, "class", "flex2 right");
      attr(div2, "class", "flexrow sheet-row justify-vertical px-sm");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, label);
      append(div2, div1);
      mount_component(docinput, div1, null);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(docinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(docinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(docinput);
    }
  };
}
__name(create_if_block_13, "create_if_block_13");
function create_if_block_11(ctx) {
  let div2;
  let div0;
  let label;
  let div1;
  let docselect;
  let current;
  docselect = new DocSelect({
    props: {
      class: "wide right",
      id: "target",
      name: "target",
      options: (
        /*targetOptions*/
        ctx[8]
      ),
      valuePath: "system.target"
    }
  });
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      label = element("label");
      label.textContent = `${localize$1("Type")}`;
      div1 = element("div");
      create_component(docselect.$$.fragment);
      attr(label, "for", "target");
      attr(label, "class", "svelte-mf8ncy");
      attr(div0, "class", "flex1");
      attr(div1, "class", "flex4 right wide");
      attr(div2, "class", "flexrow sheet-row justify-vertical wide");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, label);
      append(div2, div1);
      mount_component(docselect, div1, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(docselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(docselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(docselect);
    }
  };
}
__name(create_if_block_11, "create_if_block_11");
function create_if_block_10(ctx) {
  let div2;
  let div0;
  let label;
  let div1;
  let docselect;
  let current;
  docselect = new DocSelect({
    props: {
      class: "wide right wide",
      id: "rangeType",
      name: "rangeType",
      options: (
        /*rangeOptions*/
        ctx[6]
      ),
      valuePath: "system.rangeType"
    }
  });
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      label = element("label");
      label.textContent = `${localize$1("Type")}`;
      div1 = element("div");
      create_component(docselect.$$.fragment);
      attr(label, "for", "rangeType");
      attr(label, "class", "svelte-mf8ncy");
      attr(div0, "class", "flex1");
      attr(div1, "class", "flex4 right wide");
      attr(div2, "class", "flexrow sheet-row justify-vertical wide");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, label);
      append(div2, div1);
      mount_component(docselect, div1, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(docselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(docselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(docselect);
    }
  };
}
__name(create_if_block_10, "create_if_block_10");
function create_if_block_9(ctx) {
  let div2;
  let div0;
  let label;
  let div1;
  let docselect;
  let current;
  docselect = new DocSelect({
    props: {
      class: "wide right",
      id: "checkAttribute",
      name: "checkAttribute",
      options: (
        /*checkOptions*/
        ctx[1]
      ),
      valuePath: "system.checkAttribute"
    }
  });
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      label = element("label");
      label.textContent = `${localize$1("Check")} ${localize$1("Attribute")}`;
      div1 = element("div");
      create_component(docselect.$$.fragment);
      attr(label, "for", "checkAttribute");
      attr(label, "class", "svelte-mf8ncy");
      attr(div0, "class", "flex2");
      attr(div1, "class", "flex4 right wide");
      attr(div2, "class", "flexrow sheet-row justify-vertical wide");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, label);
      append(div2, div1);
      mount_component(docselect, div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      const docselect_changes = {};
      if (dirty & /*checkOptions*/
      2)
        docselect_changes.options = /*checkOptions*/
        ctx2[1];
      docselect.$set(docselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(docselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(docselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(docselect);
    }
  };
}
__name(create_if_block_9, "create_if_block_9");
function create_if_block_8(ctx) {
  let div2;
  let div0;
  let label;
  let div1;
  let docselect;
  let current;
  docselect = new DocSelect({
    props: {
      class: "wide right",
      id: "CR",
      name: "CR",
      options: (
        /*CROptions*/
        ctx[3]
      ),
      valuePath: "system.CR"
    }
  });
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      label = element("label");
      label.textContent = `${localize$1("Type")}`;
      div1 = element("div");
      create_component(docselect.$$.fragment);
      attr(label, "for", "CR");
      attr(label, "class", "svelte-mf8ncy");
      attr(div0, "class", "flex1");
      attr(div1, "class", "flex4 right wide");
      attr(div2, "class", "flexrow sheet-row justify-vertical wide");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, label);
      append(div2, div1);
      mount_component(docselect, div1, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(docselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(docselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(docselect);
    }
  };
}
__name(create_if_block_8, "create_if_block_8");
function create_if_block_7(ctx) {
  let div2;
  let div0;
  let docselect0;
  let div1;
  let docselect1;
  let current;
  docselect0 = new DocSelect({
    props: {
      class: "left",
      id: "limitation",
      name: "limitation",
      type: "number",
      options: (
        /*limitationOptions*/
        ctx[4]
      ),
      valuePath: "system.limitation"
    }
  });
  docselect1 = new DocSelect({
    props: {
      class: "right",
      id: "limitationUnits",
      name: "limitationUnits",
      options: (
        /*limitationUnitsOptions*/
        ctx[5]
      ),
      valuePath: "system.limitationUnits"
    }
  });
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      create_component(docselect0.$$.fragment);
      div1 = element("div");
      create_component(docselect1.$$.fragment);
      attr(div0, "class", "flex2 left");
      attr(div1, "class", "flex2 right");
      attr(div2, "class", "flexrow sheet-row justify-vertical wide");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      mount_component(docselect0, div0, null);
      append(div2, div1);
      mount_component(docselect1, div1, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(docselect0.$$.fragment, local);
      transition_in(docselect1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(docselect0.$$.fragment, local);
      transition_out(docselect1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(docselect0);
      destroy_component(docselect1);
    }
  };
}
__name(create_if_block_7, "create_if_block_7");
function create_if_block_6(ctx) {
  let div2;
  let div0;
  let label;
  let div1;
  let docselect;
  let current;
  docselect = new DocSelect({
    props: {
      class: "wide right",
      id: "aspected",
      name: "aspected",
      type: "number",
      options: (
        /*aspectedOptions*/
        ctx[9]
      ),
      valuePath: "system.aspected"
    }
  });
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      label = element("label");
      label.textContent = `${localize$1("Aspected")}`;
      div1 = element("div");
      create_component(docselect.$$.fragment);
      attr(label, "for", "aspected");
      attr(label, "class", "svelte-mf8ncy");
      attr(div0, "class", "flex1");
      attr(div1, "class", "flex4 right wide");
      attr(div2, "class", "flexrow sheet-row justify-vertical wide");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, label);
      append(div2, div1);
      mount_component(docselect, div1, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(docselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(docselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(docselect);
    }
  };
}
__name(create_if_block_6, "create_if_block_6");
function create_if_block_5(ctx) {
  let div2;
  let div0;
  let label;
  let div1;
  let docselect;
  let current;
  docselect = new DocSelect({
    props: {
      class: "wide right",
      id: "trigger",
      name: "trigger",
      type: "number",
      options: (
        /*triggerOptions*/
        ctx[7]
      ),
      valuePath: "system.trigger"
    }
  });
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      label = element("label");
      label.textContent = `${localize$1("Type")}`;
      div1 = element("div");
      create_component(docselect.$$.fragment);
      attr(label, "for", "trigger");
      attr(label, "class", "svelte-mf8ncy");
      attr(div0, "class", "flex1");
      attr(div1, "class", "flex4 right wide");
      attr(div2, "class", "flexrow sheet-row justify-vertical wide");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, label);
      append(div2, div1);
      mount_component(docselect, div1, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(docselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(docselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(docselect);
    }
  };
}
__name(create_if_block_5, "create_if_block_5");
function create_if_block_4(ctx) {
  let div2;
  let div0;
  let label;
  let div1;
  let docselect;
  let current;
  docselect = new DocSelect({
    props: {
      class: "wide right",
      id: "cost",
      name: "cost",
      type: "number",
      options: (
        /*costOptions*/
        ctx[14]
      ),
      valuePath: "system.costMP"
    }
  });
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      label = element("label");
      label.textContent = `${localize$1("Types.Actor.Points.MP.short")}`;
      div1 = element("div");
      create_component(docselect.$$.fragment);
      attr(label, "for", "cost");
      attr(label, "class", "svelte-mf8ncy");
      attr(div0, "class", "flex1");
      attr(div1, "class", "flex4 right wide");
      attr(div2, "class", "flexrow sheet-row justify-vertical wide");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, label);
      append(div2, div1);
      mount_component(docselect, div1, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(docselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(docselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(docselect);
    }
  };
}
__name(create_if_block_4, "create_if_block_4");
function create_if_block_3$1(ctx) {
  let div2;
  let div0;
  let label;
  let div1;
  let docselect;
  let current;
  docselect = new DocSelect({
    props: {
      class: "wide right",
      id: "directHitType",
      name: "directHitType",
      options: (
        /*directHitOptions*/
        ctx[13]
      ),
      valuePath: "system.directHitType"
    }
  });
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      label = element("label");
      label.textContent = `${localize$1("Type")}`;
      div1 = element("div");
      create_component(docselect.$$.fragment);
      attr(label, "for", "directHitType");
      attr(label, "class", "svelte-mf8ncy");
      attr(div0, "class", "flex1");
      attr(div1, "class", "flex4 right wide");
      attr(div2, "class", "flexrow sheet-row justify-vertical wide");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, label);
      append(div2, div1);
      mount_component(docselect, div1, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(docselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(docselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(docselect);
    }
  };
}
__name(create_if_block_3$1, "create_if_block_3$1");
function create_if_block_2$3(ctx) {
  let div2;
  let div0;
  let label;
  let div1;
  let docinput;
  let current;
  docinput = new DocInput({
    props: {
      id: "directHitDamage",
      name: "directHitDamage",
      valuePath: "system.directHitDamage"
    }
  });
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      label = element("label");
      label.textContent = `${localize$1("Damage")}`;
      div1 = element("div");
      create_component(docinput.$$.fragment);
      attr(label, "for", "directHitDamage");
      attr(label, "class", "svelte-mf8ncy");
      attr(div0, "class", "flex2");
      attr(div1, "class", "flex2 right");
      attr(div2, "class", "flexrow sheet-row justify-vertical");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, label);
      append(div2, div1);
      mount_component(docinput, div1, null);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(docinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(docinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(docinput);
    }
  };
}
__name(create_if_block_2$3, "create_if_block_2$3");
function create_if_block_1$3(ctx) {
  let div2;
  let div0;
  let label;
  let div1;
  let docselect;
  let current;
  docselect = new DocSelect({
    props: {
      class: "wide right",
      id: "directHitCondition",
      name: "directHitCondition",
      options: (
        /*directHitConditionOptions*/
        ctx[11]
      ),
      valuePath: "system.directHitCondition"
    }
  });
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      label = element("label");
      label.textContent = `${localize$1("Condition")}`;
      div1 = element("div");
      create_component(docselect.$$.fragment);
      attr(label, "for", "directHitCondition");
      attr(label, "class", "svelte-mf8ncy");
      attr(div0, "class", "flex2");
      attr(div1, "class", "flex2 right wide");
      attr(div2, "class", "flexrow sheet-row justify-vertical wide");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, label);
      append(div2, div1);
      mount_component(docselect, div1, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(docselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(docselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(docselect);
    }
  };
}
__name(create_if_block_1$3, "create_if_block_1$3");
function create_if_block$5(ctx) {
  let div2;
  let div0;
  let h3;
  let div1;
  let prosemirror;
  let current;
  prosemirror = new ProseMirror$1({
    props: {
      id: "directHitText",
      name: "directHitText",
      attr: "system.directHitText"
    }
  });
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      h3 = element("h3");
      h3.textContent = `${localize$1("Types.Item.Types.action.DirectHit")} ${localize$1("Text")} `;
      div1 = element("div");
      create_component(prosemirror.$$.fragment);
      attr(h3, "class", "left");
      attr(div0, "class", "flex2");
      attr(div1, "class", "flex2 left prose high");
      attr(div2, "class", "flexcol sheet-row justify-vertical high");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, h3);
      append(div2, div1);
      mount_component(prosemirror, div1, null);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(prosemirror.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(prosemirror.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(prosemirror);
    }
  };
}
__name(create_if_block$5, "create_if_block$5");
function create_fragment$j(ctx) {
  let div40;
  let div39;
  let h30;
  let div2;
  let div0;
  let label;
  let div1;
  let docselect;
  let div5;
  let div3;
  let div4;
  let doccheckbox0;
  let div8;
  let div6;
  let h31;
  let div7;
  let doccheckbox1;
  let div11;
  let div9;
  let h32;
  let div10;
  let doccheckbox2;
  let div14;
  let div12;
  let div13;
  let doccheckbox3;
  let div17;
  let div15;
  let h34;
  let div16;
  let doccheckbox4;
  let div20;
  let div18;
  let h35;
  let div19;
  let doccheckbox5;
  let if_block6_anchor;
  let durationcomponent;
  let div23;
  let div21;
  let h36;
  let div22;
  let doccheckbox6;
  let div26;
  let div24;
  let h37;
  let div25;
  let doccheckbox7;
  let div29;
  let div27;
  let h38;
  let div28;
  let doccheckbox8;
  let div32;
  let div30;
  let h39;
  let div31;
  let doccheckbox9;
  let div35;
  let div33;
  let h310;
  let div34;
  let doccheckbox10;
  let div38;
  let div36;
  let h311;
  let div37;
  let doccheckbox11;
  let if_block10_anchor;
  let if_block11_anchor;
  let if_block12_anchor;
  let current;
  docselect = new DocSelect({
    props: {
      class: "wide right",
      id: "type",
      name: "type",
      type: "number",
      options: (
        /*typeOptions*/
        ctx[10]
      ),
      valuePath: "system.type"
    }
  });
  function select_block_type(ctx2, dirty) {
    if (
      /*$item*/
      ctx2[0].system.hasBaseEffect
    )
      return create_if_block_17;
    return create_else_block;
  }
  __name(select_block_type, "select_block_type");
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(ctx);
  doccheckbox0 = new DocCheckbox({
    props: {
      name: "hasBaseEffect",
      valuePath: "system.hasBaseEffect"
    }
  });
  let if_block1 = (
    /*$item*/
    ctx[0].system.hasBaseEffect && create_if_block_12(ctx)
  );
  doccheckbox1 = new DocCheckbox({
    props: {
      id: "hasTarget",
      name: "hasTarget",
      valuePath: "system.hasTarget"
    }
  });
  let if_block2 = (
    /*$item*/
    ctx[0].system.hasTarget && create_if_block_11(ctx)
  );
  doccheckbox2 = new DocCheckbox({
    props: {
      name: "hasRanged",
      valuePath: "system.hasRanged"
    }
  });
  let if_block3 = (
    /*$item*/
    ctx[0].system.hasRanged && create_if_block_10(ctx)
  );
  doccheckbox3 = new DocCheckbox({
    props: {
      name: "hasCheck",
      valuePath: "system.hasCheck"
    }
  });
  let if_block4 = (
    /*$item*/
    ctx[0].system.hasCheck && create_if_block_9(ctx)
  );
  doccheckbox4 = new DocCheckbox({
    props: { name: "hasCR", valuePath: "system.hasCR" }
  });
  let if_block5 = (
    /*$item*/
    ctx[0].system.hasCR && create_if_block_8(ctx)
  );
  doccheckbox5 = new DocCheckbox({
    props: {
      name: "hasLimitation",
      valuePath: "system.hasLimitation"
    }
  });
  let if_block6 = (
    /*$item*/
    ctx[0].system.hasLimitation && create_if_block_7(ctx)
  );
  durationcomponent = new Duration2({});
  doccheckbox6 = new DocCheckbox({
    props: {
      name: "hasAspected",
      valuePath: "system.hasAspected"
    }
  });
  let if_block7 = (
    /*$item*/
    ctx[0].system.hasAspected && create_if_block_6(ctx)
  );
  doccheckbox7 = new DocCheckbox({
    props: {
      name: "hasTrigger",
      valuePath: "system.hasTrigger"
    }
  });
  let if_block8 = (
    /*$item*/
    ctx[0].system.hasTrigger && create_if_block_5(ctx)
  );
  doccheckbox8 = new DocCheckbox({
    props: {
      name: "hasCostMP",
      valuePath: "system.hasCostMP"
    }
  });
  let if_block9 = (
    /*$item*/
    ctx[0].system.hasCostMP && create_if_block_4(ctx)
  );
  doccheckbox9 = new DocCheckbox({
    props: {
      name: "hasHeavierShot",
      valuePath: "system.hasHeavierShot"
    }
  });
  doccheckbox10 = new DocCheckbox({
    props: {
      name: "hasSplitDamage",
      valuePath: "system.hasSplitDamage"
    }
  });
  doccheckbox11 = new DocCheckbox({
    props: {
      name: "hasDirectHit",
      valuePath: "system.hasDirectHit"
    }
  });
  let if_block10 = (
    /*$item*/
    ctx[0].system.hasDirectHit && create_if_block_3$1(ctx)
  );
  let if_block11 = (
    /*$item*/
    ctx[0].system.directHitType === "damage" && create_if_block_2$3()
  );
  let if_block12 = (
    /*$item*/
    ctx[0].system.directHitType === "condition" && create_if_block_1$3(ctx)
  );
  let if_block13 = (
    /*$item*/
    ctx[0].system.hasDirectHit && create_if_block$5()
  );
  return {
    c() {
      div40 = element("div");
      div39 = element("div");
      h30 = element("h3");
      h30.textContent = `${localize$1("General")}`;
      div2 = element("div");
      div0 = element("div");
      label = element("label");
      label.textContent = `${localize$1("Type")}`;
      div1 = element("div");
      create_component(docselect.$$.fragment);
      div5 = element("div");
      div3 = element("div");
      if_block0.c();
      div4 = element("div");
      create_component(doccheckbox0.$$.fragment);
      if (if_block1)
        if_block1.c();
      div8 = element("div");
      div6 = element("div");
      h31 = element("h3");
      h31.textContent = `${localize$1("Types.Item.Target")}`;
      div7 = element("div");
      create_component(doccheckbox1.$$.fragment);
      if (if_block2)
        if_block2.c();
      div11 = element("div");
      div9 = element("div");
      h32 = element("h3");
      h32.textContent = `${localize$1("Types.Item.Range")}`;
      div10 = element("div");
      create_component(doccheckbox2.$$.fragment);
      if (if_block3)
        if_block3.c();
      div14 = element("div");
      div12 = element("div");
      div12.innerHTML = `<h3 class="left">Checks</h3>`;
      div13 = element("div");
      create_component(doccheckbox3.$$.fragment);
      if (if_block4)
        if_block4.c();
      div17 = element("div");
      div15 = element("div");
      h34 = element("h3");
      h34.textContent = `${localize$1("CR")}`;
      div16 = element("div");
      create_component(doccheckbox4.$$.fragment);
      if (if_block5)
        if_block5.c();
      div20 = element("div");
      div18 = element("div");
      h35 = element("h3");
      h35.textContent = `${localize$1("Limitation")}`;
      div19 = element("div");
      create_component(doccheckbox5.$$.fragment);
      if (if_block6)
        if_block6.c();
      if_block6_anchor = empty();
      create_component(durationcomponent.$$.fragment);
      div23 = element("div");
      div21 = element("div");
      h36 = element("h3");
      h36.textContent = `${localize$1("Aspected")}`;
      div22 = element("div");
      create_component(doccheckbox6.$$.fragment);
      if (if_block7)
        if_block7.c();
      div26 = element("div");
      div24 = element("div");
      h37 = element("h3");
      h37.textContent = `${localize$1("Types.Item.Trigger")}`;
      div25 = element("div");
      create_component(doccheckbox7.$$.fragment);
      if (if_block8)
        if_block8.c();
      div29 = element("div");
      div27 = element("div");
      h38 = element("h3");
      h38.textContent = `${localize$1("Cost")}`;
      div28 = element("div");
      create_component(doccheckbox8.$$.fragment);
      if (if_block9)
        if_block9.c();
      div32 = element("div");
      div30 = element("div");
      h39 = element("h3");
      h39.textContent = `${localize$1("HeavierShot")}`;
      div31 = element("div");
      create_component(doccheckbox9.$$.fragment);
      div35 = element("div");
      div33 = element("div");
      h310 = element("h3");
      h310.textContent = `${localize$1("Types.Item.Types.action.SplitDamage")}`;
      div34 = element("div");
      create_component(doccheckbox10.$$.fragment);
      div38 = element("div");
      div36 = element("div");
      h311 = element("h3");
      h311.textContent = `${localize$1("Types.Item.Types.action.DirectHit")}`;
      div37 = element("div");
      create_component(doccheckbox11.$$.fragment);
      if (if_block10)
        if_block10.c();
      if_block10_anchor = empty();
      if (if_block11)
        if_block11.c();
      if_block11_anchor = empty();
      if (if_block12)
        if_block12.c();
      if_block12_anchor = empty();
      if (if_block13)
        if_block13.c();
      attr(h30, "class", "left");
      attr(label, "for", "type");
      attr(label, "class", "svelte-mf8ncy");
      attr(div0, "class", "flex1");
      attr(div1, "class", "flex4 right wide");
      attr(div2, "class", "flexrow sheet-row justify-vertical wide");
      attr(div3, "class", "flex4");
      attr(div4, "class", "flex0 right");
      attr(div5, "class", "flexrow justify-vertical");
      attr(h31, "class", "left");
      attr(div6, "class", "flex4");
      attr(div7, "class", "flex0 right");
      attr(div8, "class", "flexrow justify-vertical");
      attr(h32, "class", "left");
      attr(div9, "class", "flex4");
      attr(div10, "class", "flex0 right");
      attr(div11, "class", "flexrow justify-vertical");
      attr(div12, "class", "flex4");
      attr(div13, "class", "flex0 right");
      attr(div14, "class", "flexrow justify-vertical");
      attr(h34, "class", "left");
      attr(div15, "class", "flex4");
      attr(div16, "class", "flex0 right");
      attr(div17, "class", "flexrow justify-vertical");
      attr(h35, "class", "left");
      attr(div18, "class", "flex4");
      attr(div19, "class", "flex0 right");
      attr(div20, "class", "flexrow justify-vertical");
      attr(h36, "class", "left");
      attr(div21, "class", "flex4");
      attr(div22, "class", "flex0 right");
      attr(div23, "class", "flexrow justify-vertical");
      attr(h37, "class", "left");
      attr(div24, "class", "flex4");
      attr(div25, "class", "flex0 right");
      attr(div26, "class", "flexrow justify-vertical");
      attr(h38, "class", "left");
      attr(div27, "class", "flex4");
      attr(div28, "class", "flex0 right");
      attr(div29, "class", "flexrow justify-vertical");
      attr(h39, "class", "left");
      attr(div30, "class", "flex4");
      attr(div31, "class", "flex0 right");
      attr(div32, "class", "flexrow justify-vertical");
      attr(h310, "class", "left");
      attr(div33, "class", "flex4");
      attr(div34, "class", "flex0 right");
      attr(div35, "class", "flexrow justify-vertical");
      attr(h311, "class", "left");
      attr(div36, "class", "flex4");
      attr(div37, "class", "flex0 right");
      attr(div38, "class", "flexrow justify-vertical");
      attr(div39, "class", "flexcol flex3 left high wide");
      attr(div40, "class", "item-sheet details overflow wide svelte-mf8ncy");
    },
    m(target, anchor) {
      insert(target, div40, anchor);
      append(div40, div39);
      append(div39, h30);
      append(div39, div2);
      append(div2, div0);
      append(div0, label);
      append(div2, div1);
      mount_component(docselect, div1, null);
      append(div39, div5);
      append(div5, div3);
      if_block0.m(div3, null);
      append(div5, div4);
      mount_component(doccheckbox0, div4, null);
      if (if_block1)
        if_block1.m(div39, null);
      append(div39, div8);
      append(div8, div6);
      append(div6, h31);
      append(div8, div7);
      mount_component(doccheckbox1, div7, null);
      if (if_block2)
        if_block2.m(div39, null);
      append(div39, div11);
      append(div11, div9);
      append(div9, h32);
      append(div11, div10);
      mount_component(doccheckbox2, div10, null);
      if (if_block3)
        if_block3.m(div39, null);
      append(div39, div14);
      append(div14, div12);
      append(div14, div13);
      mount_component(doccheckbox3, div13, null);
      if (if_block4)
        if_block4.m(div39, null);
      append(div39, div17);
      append(div17, div15);
      append(div15, h34);
      append(div17, div16);
      mount_component(doccheckbox4, div16, null);
      if (if_block5)
        if_block5.m(div39, null);
      append(div39, div20);
      append(div20, div18);
      append(div18, h35);
      append(div20, div19);
      mount_component(doccheckbox5, div19, null);
      if (if_block6)
        if_block6.m(div39, null);
      append(div39, if_block6_anchor);
      mount_component(durationcomponent, div39, null);
      append(div39, div23);
      append(div23, div21);
      append(div21, h36);
      append(div23, div22);
      mount_component(doccheckbox6, div22, null);
      if (if_block7)
        if_block7.m(div39, null);
      append(div39, div26);
      append(div26, div24);
      append(div24, h37);
      append(div26, div25);
      mount_component(doccheckbox7, div25, null);
      if (if_block8)
        if_block8.m(div39, null);
      append(div39, div29);
      append(div29, div27);
      append(div27, h38);
      append(div29, div28);
      mount_component(doccheckbox8, div28, null);
      if (if_block9)
        if_block9.m(div39, null);
      append(div39, div32);
      append(div32, div30);
      append(div30, h39);
      append(div32, div31);
      mount_component(doccheckbox9, div31, null);
      append(div39, div35);
      append(div35, div33);
      append(div33, h310);
      append(div35, div34);
      mount_component(doccheckbox10, div34, null);
      append(div39, div38);
      append(div38, div36);
      append(div36, h311);
      append(div38, div37);
      mount_component(doccheckbox11, div37, null);
      if (if_block10)
        if_block10.m(div39, null);
      append(div39, if_block10_anchor);
      if (if_block11)
        if_block11.m(div39, null);
      append(div39, if_block11_anchor);
      if (if_block12)
        if_block12.m(div39, null);
      append(div39, if_block12_anchor);
      if (if_block13)
        if_block13.m(div39, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (current_block_type !== (current_block_type = select_block_type(ctx2))) {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div3, null);
        }
      }
      if (
        /*$item*/
        ctx2[0].system.hasBaseEffect
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$item*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_12(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div39, div8);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*$item*/
        ctx2[0].system.hasTarget
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*$item*/
          1) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_11(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div39, div11);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*$item*/
        ctx2[0].system.hasRanged
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & /*$item*/
          1) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_10(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div39, div14);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (
        /*$item*/
        ctx2[0].system.hasCheck
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty & /*$item*/
          1) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_9(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div39, div17);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (
        /*$item*/
        ctx2[0].system.hasCR
      ) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty & /*$item*/
          1) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block_8(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(div39, div20);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      if (
        /*$item*/
        ctx2[0].system.hasLimitation
      ) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
          if (dirty & /*$item*/
          1) {
            transition_in(if_block6, 1);
          }
        } else {
          if_block6 = create_if_block_7(ctx2);
          if_block6.c();
          transition_in(if_block6, 1);
          if_block6.m(div39, if_block6_anchor);
        }
      } else if (if_block6) {
        group_outros();
        transition_out(if_block6, 1, 1, () => {
          if_block6 = null;
        });
        check_outros();
      }
      if (
        /*$item*/
        ctx2[0].system.hasAspected
      ) {
        if (if_block7) {
          if_block7.p(ctx2, dirty);
          if (dirty & /*$item*/
          1) {
            transition_in(if_block7, 1);
          }
        } else {
          if_block7 = create_if_block_6(ctx2);
          if_block7.c();
          transition_in(if_block7, 1);
          if_block7.m(div39, div26);
        }
      } else if (if_block7) {
        group_outros();
        transition_out(if_block7, 1, 1, () => {
          if_block7 = null;
        });
        check_outros();
      }
      if (
        /*$item*/
        ctx2[0].system.hasTrigger
      ) {
        if (if_block8) {
          if_block8.p(ctx2, dirty);
          if (dirty & /*$item*/
          1) {
            transition_in(if_block8, 1);
          }
        } else {
          if_block8 = create_if_block_5(ctx2);
          if_block8.c();
          transition_in(if_block8, 1);
          if_block8.m(div39, div29);
        }
      } else if (if_block8) {
        group_outros();
        transition_out(if_block8, 1, 1, () => {
          if_block8 = null;
        });
        check_outros();
      }
      if (
        /*$item*/
        ctx2[0].system.hasCostMP
      ) {
        if (if_block9) {
          if_block9.p(ctx2, dirty);
          if (dirty & /*$item*/
          1) {
            transition_in(if_block9, 1);
          }
        } else {
          if_block9 = create_if_block_4(ctx2);
          if_block9.c();
          transition_in(if_block9, 1);
          if_block9.m(div39, div32);
        }
      } else if (if_block9) {
        group_outros();
        transition_out(if_block9, 1, 1, () => {
          if_block9 = null;
        });
        check_outros();
      }
      if (
        /*$item*/
        ctx2[0].system.hasDirectHit
      ) {
        if (if_block10) {
          if_block10.p(ctx2, dirty);
          if (dirty & /*$item*/
          1) {
            transition_in(if_block10, 1);
          }
        } else {
          if_block10 = create_if_block_3$1(ctx2);
          if_block10.c();
          transition_in(if_block10, 1);
          if_block10.m(div39, if_block10_anchor);
        }
      } else if (if_block10) {
        group_outros();
        transition_out(if_block10, 1, 1, () => {
          if_block10 = null;
        });
        check_outros();
      }
      if (
        /*$item*/
        ctx2[0].system.directHitType === "damage"
      ) {
        if (if_block11) {
          if (dirty & /*$item*/
          1) {
            transition_in(if_block11, 1);
          }
        } else {
          if_block11 = create_if_block_2$3();
          if_block11.c();
          transition_in(if_block11, 1);
          if_block11.m(div39, if_block11_anchor);
        }
      } else if (if_block11) {
        group_outros();
        transition_out(if_block11, 1, 1, () => {
          if_block11 = null;
        });
        check_outros();
      }
      if (
        /*$item*/
        ctx2[0].system.directHitType === "condition"
      ) {
        if (if_block12) {
          if_block12.p(ctx2, dirty);
          if (dirty & /*$item*/
          1) {
            transition_in(if_block12, 1);
          }
        } else {
          if_block12 = create_if_block_1$3(ctx2);
          if_block12.c();
          transition_in(if_block12, 1);
          if_block12.m(div39, if_block12_anchor);
        }
      } else if (if_block12) {
        group_outros();
        transition_out(if_block12, 1, 1, () => {
          if_block12 = null;
        });
        check_outros();
      }
      if (
        /*$item*/
        ctx2[0].system.hasDirectHit
      ) {
        if (if_block13) {
          if (dirty & /*$item*/
          1) {
            transition_in(if_block13, 1);
          }
        } else {
          if_block13 = create_if_block$5();
          if_block13.c();
          transition_in(if_block13, 1);
          if_block13.m(div39, null);
        }
      } else if (if_block13) {
        group_outros();
        transition_out(if_block13, 1, 1, () => {
          if_block13 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(docselect.$$.fragment, local);
      transition_in(doccheckbox0.$$.fragment, local);
      transition_in(if_block1);
      transition_in(doccheckbox1.$$.fragment, local);
      transition_in(if_block2);
      transition_in(doccheckbox2.$$.fragment, local);
      transition_in(if_block3);
      transition_in(doccheckbox3.$$.fragment, local);
      transition_in(if_block4);
      transition_in(doccheckbox4.$$.fragment, local);
      transition_in(if_block5);
      transition_in(doccheckbox5.$$.fragment, local);
      transition_in(if_block6);
      transition_in(durationcomponent.$$.fragment, local);
      transition_in(doccheckbox6.$$.fragment, local);
      transition_in(if_block7);
      transition_in(doccheckbox7.$$.fragment, local);
      transition_in(if_block8);
      transition_in(doccheckbox8.$$.fragment, local);
      transition_in(if_block9);
      transition_in(doccheckbox9.$$.fragment, local);
      transition_in(doccheckbox10.$$.fragment, local);
      transition_in(doccheckbox11.$$.fragment, local);
      transition_in(if_block10);
      transition_in(if_block11);
      transition_in(if_block12);
      transition_in(if_block13);
      current = true;
    },
    o(local) {
      transition_out(docselect.$$.fragment, local);
      transition_out(doccheckbox0.$$.fragment, local);
      transition_out(if_block1);
      transition_out(doccheckbox1.$$.fragment, local);
      transition_out(if_block2);
      transition_out(doccheckbox2.$$.fragment, local);
      transition_out(if_block3);
      transition_out(doccheckbox3.$$.fragment, local);
      transition_out(if_block4);
      transition_out(doccheckbox4.$$.fragment, local);
      transition_out(if_block5);
      transition_out(doccheckbox5.$$.fragment, local);
      transition_out(if_block6);
      transition_out(durationcomponent.$$.fragment, local);
      transition_out(doccheckbox6.$$.fragment, local);
      transition_out(if_block7);
      transition_out(doccheckbox7.$$.fragment, local);
      transition_out(if_block8);
      transition_out(doccheckbox8.$$.fragment, local);
      transition_out(if_block9);
      transition_out(doccheckbox9.$$.fragment, local);
      transition_out(doccheckbox10.$$.fragment, local);
      transition_out(doccheckbox11.$$.fragment, local);
      transition_out(if_block10);
      transition_out(if_block11);
      transition_out(if_block12);
      transition_out(if_block13);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div40);
      }
      destroy_component(docselect);
      if_block0.d();
      destroy_component(doccheckbox0);
      if (if_block1)
        if_block1.d();
      destroy_component(doccheckbox1);
      if (if_block2)
        if_block2.d();
      destroy_component(doccheckbox2);
      if (if_block3)
        if_block3.d();
      destroy_component(doccheckbox3);
      if (if_block4)
        if_block4.d();
      destroy_component(doccheckbox4);
      if (if_block5)
        if_block5.d();
      destroy_component(doccheckbox5);
      if (if_block6)
        if_block6.d();
      destroy_component(durationcomponent);
      destroy_component(doccheckbox6);
      if (if_block7)
        if_block7.d();
      destroy_component(doccheckbox7);
      if (if_block8)
        if_block8.d();
      destroy_component(doccheckbox8);
      if (if_block9)
        if_block9.d();
      destroy_component(doccheckbox9);
      destroy_component(doccheckbox10);
      destroy_component(doccheckbox11);
      if (if_block10)
        if_block10.d();
      if (if_block11)
        if_block11.d();
      if (if_block12)
        if_block12.d();
      if (if_block13)
        if_block13.d();
    }
  };
}
__name(create_fragment$j, "create_fragment$j");
function instance$f($$self, $$props, $$invalidate) {
  let checkOptions;
  let $item;
  const item = getContext("#doc");
  component_subscribe($$self, item, (value) => $$invalidate(0, $item = value));
  game.system.log.d("Details", item.system);
  game.system.log.d("PCModel", PCModel.schema.fields.attributes.fields.primary.fields);
  const { HTMLField: HTMLField2, SchemaField: SchemaField2, NumberField: NumberField2, StringField: StringField2, FilePathField, ArrayField: ArrayField2, BooleanField: BooleanField2 } = foundry.data.fields;
  const schemaFields = PCModel.schema.fields.attributes.fields.primary.fields;
  const schemaFieldEntries = Object.entries(schemaFields);
  const schemaFieldKeys = Object.keys(schemaFields).filter((key) => schemaFields[key] instanceof SchemaField2);
  const schemaFieldObjects = schemaFieldEntries.filter(([key, value]) => value instanceof SchemaField2).map(([key, value]) => ({ key, value }));
  const CROptions = getCROptions();
  const limitationOptions = getLimitationOptions();
  const limitationUnitsOptions = getLimitationUnits();
  getDurationOptions();
  getDurationUnits();
  const rangeOptions = getRangeOptions();
  getHeavyshotOptions();
  const triggerOptions = getTriggerOptions();
  const targetOptions = getTargetOptions();
  const aspectedOptions = getAspectedOptions();
  const typeOptions = getTypeOptions();
  const directHitConditionOptions = getDefaultStatusEffects().map((effect) => ({ value: effect.id, label: effect.name }));
  const baseEffectHealingTypeOptions = getBaseEffectHealingTypeOptions();
  getDurationQualifierOptions();
  getDurationTypeOptions();
  const directHitOptions = getDirectHitOptions();
  const costOptions = [
    {
      value: 1,
      label: localize$1("Types.Item.Types.Options.Cost.1")
    },
    {
      value: 2,
      label: localize$1("Types.Item.Types.Options.Cost.2")
    },
    {
      value: 3,
      label: localize$1("Types.Item.Types.Options.Cost.3")
    },
    {
      value: 4,
      label: localize$1("Types.Item.Types.Options.Cost.4")
    }
  ];
  console.log(schemaFieldObjects);
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$item*/
    1) {
      if (!$item.system.hasTrigger) {
        $item.update({ system: { trigger: null } });
      }
    }
  };
  $$invalidate(1, checkOptions = [
    ...schemaFieldKeys.map((key) => ({ value: key, label: key.toUpperCase() })),
    {
      value: "critical",
      label: localize$1("Types.Item.Types.Options.Check.critical")
    }
  ]);
  return [
    $item,
    checkOptions,
    item,
    CROptions,
    limitationOptions,
    limitationUnitsOptions,
    rangeOptions,
    triggerOptions,
    targetOptions,
    aspectedOptions,
    typeOptions,
    directHitConditionOptions,
    baseEffectHealingTypeOptions,
    directHitOptions,
    costOptions
  ];
}
__name(instance$f, "instance$f");
let Details$4 = class Details extends SvelteComponent {
  static {
    __name(this, "Details");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$f, create_fragment$j, safe_not_equal, {});
  }
};
class FolderProcessor {
  static {
    __name(this, "FolderProcessor");
  }
  /**
   * Process a single item
   * @param {Item} item - The item to process
   * @param {Array} list - The list to add the item to
   * @param {boolean} isJob - Whether this is being processed for a job
   * @param {Object} options - Additional options
   * @param {boolean} options.preventDuplicates - Whether to prevent duplicate items
   * @param {boolean} options.warnOnCompendiumDrops - Whether to warn on non-compendium drops
   * @param {Object} sourceContext - Context about where the item came from
   * @return {Promise<boolean>} Whether the item was processed successfully
   */
  static async processItem(item, list, isJob, options = {}, sourceContext = {}) {
    if (!item)
      return false;
    const { preventDuplicates = true, warnOnCompendiumDrops = true } = options;
    game.system.log.o("[FOLDER PROCESSOR] Processing item:", {
      item,
      uuid: item.uuid,
      type: item.type,
      list: list.map((x) => x.uuid),
      sourceContext
    });
    const existingInList = list.some((existing) => existing.uuid === item.uuid);
    if (preventDuplicates && existingInList) {
      game.system.log.w(`${item.name} is already in the list.`);
      return false;
    }
    if (warnOnCompendiumDrops && !item.uuid.startsWith("Compendium.")) {
      const confirmed = await Dialog.confirm({
        title: "Non-Compendium Item",
        content: `<p>Warning: You are adding an item from the game world rather than from a compendium. If this item is deleted from the game, it could cause inconsistencies.</p><p>Are you sure you want to add this item?</p>`,
        yes: () => true,
        no: () => false,
        defaultYes: false
      });
      if (!confirmed)
        return false;
    }
    game.system.log.o("[FOLDER PROCESSOR] Checking for shared limitation:", { item, type: item.type, sharedLimitation: item.system.sharedLimitation });
    if (item.type === "action" && item.system.sharedLimitation?.value) {
      if (!item.system.hasLimitation) {
        ui.notifications.notify(`The dropped action item, ${item.name}, does not have a limitation.`, "error");
        return false;
      }
      if (item.system.limitation !== sourceContext.system.limitation || item.system.limitationUnits !== sourceContext.system.limitationUnits) {
        ui.notifications.notify(`Dropped item, ${item.name}, has a limitation of "${item.system.limitation} per ${item.system.limitationUnits}", but ${sourceContext.name} has a limitation of "${sourceContext.system.limitation} per ${sourceContext.system.limitationUnits}". These do not match and thus cannot be shared.`, "error");
        game.system.log.w("[FOLDER PROCESSOR] Shared limitation mismatch:", item.uuid);
        return false;
      }
    }
    game.system.log.o("[FOLDER PROCESSOR] Adding item to list:", { uuid: item.uuid });
    list.push({ uuid: item.uuid });
    if (isJob && item.type === "action" && item.system.enables?.value) {
      const enabledTraits = item.system.enables.list || [];
      game.system.log.o("[FOLDER PROCESSOR] Processing enabled traits:", enabledTraits);
      for (const trait of enabledTraits) {
        const traitExists = list.some((existing) => existing.uuid === trait.uuid);
        game.system.log.o("[FOLDER PROCESSOR] Checking trait:", { trait, exists: traitExists });
        if (!traitExists) {
          const traitItem = await fromUuid(trait.uuid);
          if (traitItem) {
            game.system.log.o("[FOLDER PROCESSOR] Adding verified trait to list:", trait.uuid);
            list.push({ uuid: trait.uuid });
          } else {
            game.system.log.w("[FOLDER PROCESSOR] Failed to find trait with UUID:", {
              uuid: trait.uuid,
              sourceAction: {
                name: item.name,
                id: item._id,
                uuid: item.uuid
              },
              sourceFolder: sourceContext,
              invalidTrait: trait
            });
          }
        }
      }
    }
    return true;
  }
  /**
   * Process a folder and all its contents
   * @param {Folder} folder - The folder to process
   * @param {Array} list - The list to add items to
   * @param {boolean} isJob - Whether this is being processed for a job
   * @param {Object} options - Additional options
   * @return {Promise<void>}
   */
  static async processFolder(folder, list, isJob, options = {}) {
    const folderContext = {
      name: folder.name,
      id: folder._id,
      uuid: folder.uuid
    };
    game.system.log.o("[FOLDER PROCESSOR] Processing folder:", {
      folder: folderContext,
      contents: folder?.contents,
      children: folder?.children,
      entries: folder?.children?.[0]?.entries
    });
    if (!folder)
      return;
    if (folder.children?.length) {
      game.system.log.o("[FOLDER PROCESSOR] Processing child folders:", folder.children);
      for (const child of folder.children) {
        game.system.log.o("[FOLDER PROCESSOR] Processing child:", child);
        if (child.entries?.length) {
          game.system.log.o("[FOLDER PROCESSOR] Processing entries:", child.entries);
          for (const entry of child.entries) {
            game.system.log.o("[FOLDER PROCESSOR] Processing entry:", entry);
            const item = await fromUuid(entry.uuid);
            await this.processItem(item, list, isJob, options, folderContext);
          }
        }
        if (child.children?.length) {
          const subFolder = await fromUuid(child.folder.uuid);
          await this.processFolder(subFolder, list, isJob, options);
        }
      }
    }
    if (folder.contents?.length) {
      game.system.log.o("[FOLDER PROCESSOR] Processing folder contents:", folder.contents);
      for (const content of folder.contents) {
        if (content.type === "Folder") {
          game.system.log.o("[FOLDER PROCESSOR] Found nested folder:", content);
          const subFolder = await fromUuid(content.uuid);
          await this.processFolder(subFolder, list, isJob, options);
        } else {
          game.system.log.o("[FOLDER PROCESSOR] Processing item from folder:", content);
          const item = await fromUuid(content.uuid);
          await this.processItem(item, list, isJob, options, folderContext);
        }
      }
    }
  }
  /**
   * Groups items in a folder by type
   * @param {Folder} folder - The folder to process
   * @return {Promise<Object>} Object containing grouped items
   */
  static async groupFolderContentsByType(folder) {
    const groups = {
      job: [],
      other: []
    };
    if (!folder?.contents)
      return groups;
    for (const item of folder.contents) {
      const resolvedItem = await fromUuid(item.uuid);
      if (!resolvedItem)
        continue;
      if (resolvedItem.type === "job") {
        groups.job.push(resolvedItem);
      } else {
        groups.other.push(resolvedItem);
      }
    }
    game.system.log.o("[FOLDER PROCESSOR] Grouped items:", {
      jobs: groups.job.length,
      other: groups.other.length
    });
    return groups;
  }
}
function get_each_context$2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i];
  child_ctx[22] = i;
  return child_ctx;
}
__name(get_each_context$2, "get_each_context$2");
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i];
  return child_ctx;
}
__name(get_each_context_1, "get_each_context_1");
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i];
  return child_ctx;
}
__name(get_each_context_2, "get_each_context_2");
function create_if_block_2$2(ctx) {
  let table;
  let tr;
  let th0;
  let th1;
  let th2;
  let th3;
  let each_value_2 = ensure_array_like(
    /*additionalColumns*/
    ctx[2]
  );
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks_1[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  let each_value = ensure_array_like(
    /*localList*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
  }
  return {
    c() {
      table = element("table");
      tr = element("tr");
      th0 = element("th");
      th1 = element("th");
      th1.textContent = `${localize$1("Name")}`;
      th2 = element("th");
      th2.textContent = `${localize$1("Type")}`;
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      th3 = element("th");
      th3.innerHTML = `<button class="stealth svelte-1wb0kvt"></button>`;
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(th0, "class", "img expand svelte-1wb0kvt");
      attr(th0, "scope", "col");
      attr(th1, "class", "left expand no-wrap svelte-1wb0kvt");
      attr(th1, "scope", "col");
      attr(th2, "class", "left shrink svelte-1wb0kvt");
      attr(th2, "scope", "col");
      attr(th3, "class", "buttons svelte-1wb0kvt");
      attr(tr, "class", "svelte-1wb0kvt");
      attr(table, "class", "standard-list small-text borderless svelte-1wb0kvt");
    },
    m(target, anchor) {
      insert(target, table, anchor);
      append(table, tr);
      append(tr, th0);
      append(tr, th1);
      append(tr, th2);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(tr, null);
        }
      }
      append(tr, th3);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(table, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*additionalColumns*/
      4) {
        each_value_2 = ensure_array_like(
          /*additionalColumns*/
          ctx2[2]
        );
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_2(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(tr, th3);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_2.length;
      }
      if (dirty & /*localList, deleteLink, additionalColumns, showItemSheet*/
      268) {
        each_value = ensure_array_like(
          /*localList*/
          ctx2[3]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(table, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(table);
      }
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
    }
  };
}
__name(create_if_block_2$2, "create_if_block_2$2");
function create_each_block_2(ctx) {
  let th;
  let t_value = (
    /*col*/
    ctx[23].header + ""
  );
  let t;
  return {
    c() {
      th = element("th");
      t = text(t_value);
      attr(th, "class", "left fixed svelte-1wb0kvt");
      attr(th, "scope", "col");
    },
    m(target, anchor) {
      insert(target, th, anchor);
      append(th, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*additionalColumns*/
      4 && t_value !== (t_value = /*col*/
      ctx2[23].header + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(th);
      }
    }
  };
}
__name(create_each_block_2, "create_each_block_2");
function create_each_block_1(ctx) {
  let td;
  let t_value = (
    /*item*/
    (ctx[11].type === /*col*/
    ctx[23].itemType ? ucfirst(
      /*item*/
      ctx[11].system?.[
        /*col*/
        ctx[23].path
      ] || ""
    ) : "") + ""
  );
  let t;
  return {
    c() {
      td = element("td");
      t = text(t_value);
      attr(td, "class", "left svelte-1wb0kvt");
    },
    m(target, anchor) {
      insert(target, td, anchor);
      append(td, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*localList, additionalColumns*/
      12 && t_value !== (t_value = /*item*/
      (ctx2[11].type === /*col*/
      ctx2[23].itemType ? ucfirst(
        /*item*/
        ctx2[11].system?.[
          /*col*/
          ctx2[23].path
        ] || ""
      ) : "") + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(td);
      }
    }
  };
}
__name(create_each_block_1, "create_each_block_1");
function create_each_block$2(ctx) {
  let tr;
  let td0;
  let img;
  let img_src_value;
  let img_alt_value;
  let td1;
  let span;
  let t0_value = (
    /*item*/
    (ctx[11].isMissing ? `${/*item*/
    ctx[11].name} (${/*item*/
    ctx[11].uuid})` : (
      /*item*/
      ctx[11]?.name
    )) + ""
  );
  let t0;
  let td1_class_value;
  let td2;
  let t1_value = ucfirst(
    /*item*/
    ctx[11]?.type
  ) + "";
  let t1;
  let td3;
  let button;
  let tr_class_value;
  let mounted;
  let dispose;
  function click_handler2() {
    return (
      /*click_handler*/
      ctx[18](
        /*item*/
        ctx[11]
      )
    );
  }
  __name(click_handler2, "click_handler");
  let each_value_1 = ensure_array_like(
    /*additionalColumns*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[19](
        /*index*/
        ctx[22]
      )
    );
  }
  __name(click_handler_1, "click_handler_1");
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      img = element("img");
      td1 = element("td");
      span = element("span");
      t0 = text(t0_value);
      td2 = element("td");
      t1 = text(t1_value);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      td3 = element("td");
      button = element("button");
      button.innerHTML = `<i class="left fa fa-trash pointer"></i>`;
      attr(img, "class", "icon nopointer svelte-1wb0kvt");
      if (!src_url_equal(img.src, img_src_value = /*item*/
      ctx[11].img))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*item*/
      ctx[11].name);
      attr(td0, "class", "img svelte-1wb0kvt");
      attr(td1, "class", td1_class_value = "left pointer no-wrap " + /*item*/
      (ctx[11].isMissing ? "missing-text" : "") + " svelte-1wb0kvt");
      attr(td2, "class", "left svelte-1wb0kvt");
      attr(button, "class", "stealth svelte-1wb0kvt");
      attr(td3, "class", "buttons right svelte-1wb0kvt");
      attr(tr, "class", tr_class_value = null_to_empty(
        /*item*/
        ctx[11].isMissing ? "missing-item" : ""
      ) + " svelte-1wb0kvt");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, img);
      append(tr, td1);
      append(td1, span);
      append(span, t0);
      append(tr, td2);
      append(td2, t1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(tr, null);
        }
      }
      append(tr, td3);
      append(td3, button);
      if (!mounted) {
        dispose = [
          listen(td1, "click", click_handler2),
          listen(button, "click", click_handler_1)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*localList*/
      8 && !src_url_equal(img.src, img_src_value = /*item*/
      ctx[11].img)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*localList*/
      8 && img_alt_value !== (img_alt_value = /*item*/
      ctx[11].name)) {
        attr(img, "alt", img_alt_value);
      }
      if (dirty & /*localList*/
      8 && t0_value !== (t0_value = /*item*/
      (ctx[11].isMissing ? `${/*item*/
      ctx[11].name} (${/*item*/
      ctx[11].uuid})` : (
        /*item*/
        ctx[11]?.name
      )) + ""))
        set_data(t0, t0_value);
      if (dirty & /*localList*/
      8 && td1_class_value !== (td1_class_value = "left pointer no-wrap " + /*item*/
      (ctx[11].isMissing ? "missing-text" : "") + " svelte-1wb0kvt")) {
        attr(td1, "class", td1_class_value);
      }
      if (dirty & /*localList*/
      8 && t1_value !== (t1_value = ucfirst(
        /*item*/
        ctx[11]?.type
      ) + ""))
        set_data(t1, t1_value);
      if (dirty & /*localList, additionalColumns*/
      12) {
        each_value_1 = ensure_array_like(
          /*additionalColumns*/
          ctx[2]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(tr, td3);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (dirty & /*localList*/
      8 && tr_class_value !== (tr_class_value = null_to_empty(
        /*item*/
        ctx[11].isMissing ? "missing-item" : ""
      ) + " svelte-1wb0kvt")) {
        attr(tr, "class", tr_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(tr);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_each_block$2, "create_each_block$2");
function create_if_block_1$2(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = `${localize$1("Instructions.RemoveAll")}`;
      attr(button, "class", "mt-sm glossy-button gold-light hover-shine svelte-1wb0kvt");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*removeAllItems*/
          ctx[9]
        );
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block_1$2, "create_if_block_1$2");
function create_if_block$4(ctx) {
  let div;
  let p;
  return {
    c() {
      div = element("div");
      p = element("p");
      p.textContent = `${localize$1("Instructions.DropItemList")}`;
      attr(p, "class", "empty-list-text");
      attr(div, "class", "empty-list svelte-1wb0kvt");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, p);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
__name(create_if_block$4, "create_if_block$4");
function create_fragment$i(ctx) {
  let div3;
  let div2;
  let div0;
  let h2;
  let t;
  let div1;
  let doccheckbox;
  let if_block0_anchor;
  let if_block1_anchor;
  let div3_class_value;
  let current;
  let mounted;
  let dispose;
  const doccheckbox_spread_levels = [
    { class: "right wide" },
    /*$$restProps*/
    ctx[10],
    { valuePath: (
      /*valuePath*/
      ctx[1]
    ) }
  ];
  let doccheckbox_props = {};
  for (let i = 0; i < doccheckbox_spread_levels.length; i += 1) {
    doccheckbox_props = assign(doccheckbox_props, doccheckbox_spread_levels[i]);
  }
  doccheckbox = new DocCheckbox({ props: doccheckbox_props });
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    null
  );
  let if_block0 = (
    /*checkboxValue*/
    ctx[4] && create_if_block_2$2(ctx)
  );
  let if_block1 = (
    /*checkboxValue*/
    ctx[4] && /*hasItems*/
    ctx[5] && create_if_block_1$2(ctx)
  );
  let if_block2 = (
    /*checkboxValue*/
    ctx[4] && /*localList*/
    ctx[3].length === 0 && create_if_block$4()
  );
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      h2 = element("h2");
      t = text(
        /*title*/
        ctx[0]
      );
      div1 = element("div");
      create_component(doccheckbox.$$.fragment);
      if (default_slot)
        default_slot.c();
      if (if_block0)
        if_block0.c();
      if_block0_anchor = empty();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      if (if_block2)
        if_block2.c();
      attr(h2, "class", "wide");
      attr(div0, "class", "flex3");
      attr(div1, "class", "flex0 right");
      attr(div2, "class", "flexrow sheet-row justify-vertical");
      attr(div3, "class", div3_class_value = "item-bucket " + /*activeClass*/
      ctx[6] + " svelte-1wb0kvt");
      attr(div3, "role", "application");
      attr(div3, "aria-dropeffect", "link");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div0);
      append(div0, h2);
      append(h2, t);
      append(div2, div1);
      mount_component(doccheckbox, div1, null);
      if (default_slot) {
        default_slot.m(div3, null);
      }
      if (if_block0)
        if_block0.m(div3, null);
      append(div3, if_block0_anchor);
      if (if_block1)
        if_block1.m(div3, null);
      append(div3, if_block1_anchor);
      if (if_block2)
        if_block2.m(div3, null);
      current = true;
      if (!mounted) {
        dispose = listen(div3, "drop", stop_propagation(prevent_default(
          /*onDrop*/
          ctx[7]
        )));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*title*/
      1)
        set_data(
          t,
          /*title*/
          ctx2[0]
        );
      const doccheckbox_changes = dirty & /*$$restProps, valuePath*/
      1026 ? get_spread_update(doccheckbox_spread_levels, [
        doccheckbox_spread_levels[0],
        dirty & /*$$restProps*/
        1024 && get_spread_object(
          /*$$restProps*/
          ctx2[10]
        ),
        dirty & /*valuePath*/
        2 && { valuePath: (
          /*valuePath*/
          ctx2[1]
        ) }
      ]) : {};
      doccheckbox.$set(doccheckbox_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*checkboxValue*/
        ctx2[4]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2$2(ctx2);
          if_block0.c();
          if_block0.m(div3, if_block0_anchor);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*checkboxValue*/
        ctx2[4] && /*hasItems*/
        ctx2[5]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1$2(ctx2);
          if_block1.c();
          if_block1.m(div3, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*checkboxValue*/
        ctx2[4] && /*localList*/
        ctx2[3].length === 0
      ) {
        if (if_block2)
          ;
        else {
          if_block2 = create_if_block$4();
          if_block2.c();
          if_block2.m(div3, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (!current || dirty & /*activeClass*/
      64 && div3_class_value !== (div3_class_value = "item-bucket " + /*activeClass*/
      ctx2[6] + " svelte-1wb0kvt")) {
        attr(div3, "class", div3_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(doccheckbox.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(doccheckbox.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      destroy_component(doccheckbox);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      mounted = false;
      dispose();
    }
  };
}
__name(create_fragment$i, "create_fragment$i");
function showItemSheet(item) {
  item.sheet.render(true);
}
__name(showItemSheet, "showItemSheet");
function instance$e($$self, $$props, $$invalidate) {
  let checkboxValue;
  let activeClass;
  let hasItems;
  const omit_props_names = [
    "title",
    "key",
    "valuePath",
    "additionalColumns",
    "warnOnCompendiumDrops",
    "preventDuplicates"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $item;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { title } = $$props;
  let { key } = $$props;
  let { valuePath = `system.${key}.value` } = $$props;
  let { additionalColumns = [] } = $$props;
  let { warnOnCompendiumDrops = true } = $$props;
  let { preventDuplicates = true } = $$props;
  const item = getContext("#doc");
  component_subscribe($$self, item, (value) => $$invalidate(15, $item = value));
  let localList = [];
  async function updateLocalList() {
    $$invalidate(3, localList = []);
    for (let listItem of $item.system[key].list) {
      try {
        const item2 = await fromUuid(listItem.uuid);
        if (item2) {
          $$invalidate(3, localList = [...localList, item2]);
        } else {
          $$invalidate(3, localList = [
            ...localList,
            {
              name: "Missing Item",
              type: "unknown",
              img: "icons/svg/hazard.svg",
              uuid: "",
              isMissing: true
            }
          ]);
        }
      } catch (error) {
        console.error(error);
        $$invalidate(3, localList = [
          ...localList,
          {
            name: "Invalid Item",
            type: "error",
            img: "icons/svg/hazard.svg",
            uuid: listItem.uuid,
            isMissing: true
          }
        ]);
      }
    }
  }
  __name(updateLocalList, "updateLocalList");
  async function onDrop(event) {
    event.preventDefault();
    const data = JSON.parse(event.dataTransfer.getData("text/plain"));
    game.system.log.o("ItemBucket:onDrop", "Drop data:", data);
    const list = [...$item.system[key].list];
    const isJob = $item.type === "job";
    game.system.log.o("ItemBucket:onDrop", "Current state:", { key, list: list.map((x) => x.uuid), isJob });
    if (data.type === "Folder") {
      game.system.log.o("ItemBucket:onDrop", "Handling folder drop");
      const folder = await fromUuid(data.uuid);
      game.system.log.o("ItemBucket:onDrop", "Retrieved folder:", folder);
      await FolderProcessor.processFolder(folder, list, isJob, { preventDuplicates, warnOnCompendiumDrops }, $item);
      game.system.log.o("ItemBucket:onDrop", "Final list after folder processing:", list.map((x) => x.uuid));
      await $item.update({ [`system.${key}.list`]: list });
      return;
    }
    const droppedItem = await Item.implementation.fromDropData(data);
    await FolderProcessor.processItem(droppedItem, list, isJob, { preventDuplicates, warnOnCompendiumDrops }, $item);
    game.system.log.o("ItemBucket:onDrop", "Final list after item processing:", list.map((x) => x.uuid));
    await $item.update({ [`system.${key}.list`]: list });
  }
  __name(onDrop, "onDrop");
  async function deleteLink(index) {
    const list = [...$item.system[key].list];
    list.splice(index, 1);
    await $item.update({ [`system.${key}.list`]: list });
  }
  __name(deleteLink, "deleteLink");
  async function removeAllItems() {
    await Dialog.confirm({
      title: localize$1("Types.Actor.Abilities.confirmDeleteAllTitle"),
      content: localize$1("Types.Actor.Abilities.confirmDeleteAll"),
      yes: async () => {
        await $item.update({ [`system.${key}.list`]: [] });
      },
      no: () => {
      }
    });
  }
  __name(removeAllItems, "removeAllItems");
  const click_handler2 = /* @__PURE__ */ __name((item2) => !item2.isMissing && showItemSheet(item2), "click_handler");
  const click_handler_1 = /* @__PURE__ */ __name((index) => deleteLink(index), "click_handler_1");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("title" in $$new_props)
      $$invalidate(0, title = $$new_props.title);
    if ("key" in $$new_props)
      $$invalidate(12, key = $$new_props.key);
    if ("valuePath" in $$new_props)
      $$invalidate(1, valuePath = $$new_props.valuePath);
    if ("additionalColumns" in $$new_props)
      $$invalidate(2, additionalColumns = $$new_props.additionalColumns);
    if ("warnOnCompendiumDrops" in $$new_props)
      $$invalidate(13, warnOnCompendiumDrops = $$new_props.warnOnCompendiumDrops);
    if ("preventDuplicates" in $$new_props)
      $$invalidate(14, preventDuplicates = $$new_props.preventDuplicates);
    if ("$$scope" in $$new_props)
      $$invalidate(16, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$item, key*/
    36864) {
      $$invalidate(4, checkboxValue = $item.system[key]?.value);
    }
    if ($$self.$$.dirty & /*$item, key*/
    36864) {
      if ($item.system[key]?.list) {
        updateLocalList();
      }
    }
    if ($$self.$$.dirty & /*checkboxValue*/
    16) {
      $$invalidate(6, activeClass = checkboxValue ? "active" : "");
    }
    if ($$self.$$.dirty & /*localList*/
    8) {
      $$invalidate(5, hasItems = localList.length > 0);
    }
  };
  return [
    title,
    valuePath,
    additionalColumns,
    localList,
    checkboxValue,
    hasItems,
    activeClass,
    onDrop,
    deleteLink,
    removeAllItems,
    $$restProps,
    item,
    key,
    warnOnCompendiumDrops,
    preventDuplicates,
    $item,
    $$scope,
    slots,
    click_handler2,
    click_handler_1
  ];
}
__name(instance$e, "instance$e");
class ItemBucket extends SvelteComponent {
  static {
    __name(this, "ItemBucket");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$e, create_fragment$i, safe_not_equal, {
      title: 0,
      key: 12,
      valuePath: 1,
      additionalColumns: 2,
      warnOnCompendiumDrops: 13,
      preventDuplicates: 14
    });
  }
}
function get_each_context$1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  return child_ctx;
}
__name(get_each_context$1, "get_each_context$1");
function create_each_block$1(ctx) {
  let div;
  let tag_1;
  let current;
  tag_1 = new Tag({
    props: {
      class: "badge round",
      tag: (
        /*tag*/
        ctx[6]
      )
    }
  });
  return {
    c() {
      div = element("div");
      create_component(tag_1.$$.fragment);
      attr(div, "class", "flex0");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(tag_1, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const tag_1_changes = {};
      if (dirty & /*$doc*/
      2)
        tag_1_changes.tag = /*tag*/
        ctx2[6];
      tag_1.$set(tag_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tag_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tag_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(tag_1);
    }
  };
}
__name(create_each_block$1, "create_each_block$1");
function create_fragment$h(ctx) {
  let div0;
  let input;
  let div1;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*$doc*/
    ctx[1].system.tags
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
  }
  const out = /* @__PURE__ */ __name((i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  }), "out");
  return {
    c() {
      div0 = element("div");
      input = element("input");
      div1 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(input, "placeholder", "Enter new tag");
      attr(div0, "class", "flexcol");
      attr(div1, "class", "flexrow gap-4 mt-sm justify-vertical");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, input);
      set_input_value(
        input,
        /*newTag*/
        ctx[0]
      );
      insert(target, div1, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div1, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[4]
          ),
          listen(
            input,
            "input",
            /*addTagDebounce*/
            ctx[3]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*newTag*/
      1 && input.value !== /*newTag*/
      ctx2[0]) {
        set_input_value(
          input,
          /*newTag*/
          ctx2[0]
        );
      }
      if (dirty & /*$doc*/
      2) {
        each_value = ensure_array_like(
          /*$doc*/
          ctx2[1].system.tags
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$1(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div1, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(div1);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_fragment$h, "create_fragment$h");
function instance$d($$self, $$props, $$invalidate) {
  let $doc;
  const doc = getContext("#doc");
  component_subscribe($$self, doc, (value) => $$invalidate(1, $doc = value));
  let newTag = "";
  const addTagDebounce = Timing.debounce(addTag, 600);
  async function addTag() {
    const tags = [...$doc.system.tags];
    if (tags.includes(newTag)) {
      ui.notifications.error(localize(`${SYSTEM_CODE}.Errors.DuplicateTag`));
      $$invalidate(0, newTag = "");
      return;
    }
    if (!newTag.length) {
      return;
    }
    tags.push(newTag);
    await $doc.update({ system: { tags } });
    $$invalidate(0, newTag = "");
  }
  __name(addTag, "addTag");
  onMount(() => {
  });
  onDestroy(() => {
  });
  function input_input_handler() {
    newTag = this.value;
    $$invalidate(0, newTag);
  }
  __name(input_input_handler, "input_input_handler");
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*newTag*/
    1) {
      $$invalidate(0, newTag = newTag.toLowerCase().trim());
    }
  };
  return [newTag, $doc, doc, addTagDebounce, input_input_handler];
}
__name(instance$d, "instance$d");
class TagInput extends SvelteComponent {
  static {
    __name(this, "TagInput");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$d, create_fragment$h, safe_not_equal, {});
  }
}
function create_if_block_2$1(ctx) {
  let itembucket;
  let current;
  itembucket = new ItemBucket({
    props: {
      title: localize$1("Types.Item.SharedLimitation"),
      key: "sharedLimitation"
    }
  });
  return {
    c() {
      create_component(itembucket.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itembucket, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(itembucket.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itembucket.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itembucket, detaching);
    }
  };
}
__name(create_if_block_2$1, "create_if_block_2$1");
function create_if_block_1$1(ctx) {
  let div2;
  let div0;
  let label;
  let div1;
  let docinput;
  let current;
  docinput = new DocInput({
    props: {
      class: "wide right",
      id: "procTrigger",
      name: "procTrigger",
      type: "number",
      valuePath: "system.procTrigger"
    }
  });
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      label = element("label");
      label.textContent = `${localize$1("Threshold")}`;
      div1 = element("div");
      create_component(docinput.$$.fragment);
      attr(label, "for", "procTrigger");
      attr(div0, "class", "flex1");
      attr(div1, "class", "flex4 right wide");
      attr(div2, "class", "flexrow sheet-row justify-vertical wide gold px-sm");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, label);
      append(div2, div1);
      mount_component(docinput, div1, null);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(docinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(docinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(docinput);
    }
  };
}
__name(create_if_block_1$1, "create_if_block_1$1");
function create_default_slot$6(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$item*/
    ctx[0].system.procs.value && create_if_block_1$1()
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*$item*/
        ctx2[0].system.procs.value
      ) {
        if (if_block) {
          if (dirty & /*$item*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$1();
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
__name(create_default_slot$6, "create_default_slot$6");
function create_if_block$3(ctx) {
  let div;
  let taginput;
  let current;
  taginput = new TagInput({});
  return {
    c() {
      div = element("div");
      create_component(taginput.$$.fragment);
      attr(div, "class", "px-sm");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(taginput, div, null);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(taginput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(taginput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(taginput);
    }
  };
}
__name(create_if_block$3, "create_if_block$3");
function create_fragment$g(ctx) {
  let div6;
  let div1;
  let div0;
  let itembucket0;
  let itembucket1;
  let itembucket2;
  let itembucket3;
  let if_block0_anchor;
  let itembucket4;
  let itembucket5;
  let div4;
  let div2;
  let h2;
  let div3;
  let doccheckbox;
  let div5;
  let current;
  itembucket0 = new ItemBucket({
    props: {
      title: localize$1("Requires"),
      key: "requires"
    }
  });
  itembucket1 = new ItemBucket({
    props: {
      title: localize$1("Removes"),
      key: "removes"
    }
  });
  itembucket2 = new ItemBucket({
    props: {
      title: localize$1("Target") + " " + localize$1("Effects"),
      key: "grants"
    }
  });
  itembucket3 = new ItemBucket({
    props: {
      title: localize$1("Source") + " " + localize$1("Effects"),
      key: "sourceGrants"
    }
  });
  let if_block0 = (
    /*$item*/
    ctx[0].system.hasLimitation && /*$item*/
    ctx[0].system.limitation && /*$item*/
    ctx[0].system.limitationUnits && create_if_block_2$1()
  );
  itembucket4 = new ItemBucket({
    props: {
      title: localize$1("Enabled") + " " + localize$1("Traits"),
      key: "enables"
    }
  });
  itembucket5 = new ItemBucket({
    props: {
      title: localize$1("ProcTriggers"),
      key: "procs",
      $$slots: { default: [create_default_slot$6] },
      $$scope: { ctx }
    }
  });
  doccheckbox = new DocCheckbox({
    props: {
      name: "hasTags",
      valuePath: "system.hasTags"
    }
  });
  let if_block1 = (
    /*$item*/
    ctx[0].system.hasTags && create_if_block$3()
  );
  return {
    c() {
      div6 = element("div");
      div1 = element("div");
      div0 = element("div");
      create_component(itembucket0.$$.fragment);
      create_component(itembucket1.$$.fragment);
      create_component(itembucket2.$$.fragment);
      create_component(itembucket3.$$.fragment);
      if (if_block0)
        if_block0.c();
      if_block0_anchor = empty();
      create_component(itembucket4.$$.fragment);
      create_component(itembucket5.$$.fragment);
      div4 = element("div");
      div2 = element("div");
      h2 = element("h2");
      h2.textContent = `${localize$1("Tags")}`;
      div3 = element("div");
      create_component(doccheckbox.$$.fragment);
      if (if_block1)
        if_block1.c();
      div5 = element("div");
      div5.innerHTML = ``;
      attr(div0, "class", "flex3 left high");
      attr(div1, "class", "flexcol");
      attr(h2, "class", "left");
      attr(div2, "class", "flex4");
      attr(div3, "class", "flex0 right");
      attr(div4, "class", "flexrow sheet-row justify-vertical px-sm");
      attr(div5, "class", "pb-lg");
      attr(div6, "class", "item-sheet details overflow high svelte-z5zfiu");
    },
    m(target, anchor) {
      insert(target, div6, anchor);
      append(div6, div1);
      append(div1, div0);
      mount_component(itembucket0, div0, null);
      mount_component(itembucket1, div0, null);
      mount_component(itembucket2, div0, null);
      mount_component(itembucket3, div0, null);
      if (if_block0)
        if_block0.m(div0, null);
      append(div0, if_block0_anchor);
      mount_component(itembucket4, div0, null);
      mount_component(itembucket5, div0, null);
      append(div6, div4);
      append(div4, div2);
      append(div2, h2);
      append(div4, div3);
      mount_component(doccheckbox, div3, null);
      if (if_block1)
        if_block1.m(div6, null);
      append(div6, div5);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*$item*/
        ctx2[0].system.hasLimitation && /*$item*/
        ctx2[0].system.limitation && /*$item*/
        ctx2[0].system.limitationUnits
      ) {
        if (if_block0) {
          if (dirty & /*$item*/
          1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2$1();
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, if_block0_anchor);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const itembucket5_changes = {};
      if (dirty & /*$$scope, $item*/
      5) {
        itembucket5_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itembucket5.$set(itembucket5_changes);
      if (
        /*$item*/
        ctx2[0].system.hasTags
      ) {
        if (if_block1) {
          if (dirty & /*$item*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$3();
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div6, div5);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(itembucket0.$$.fragment, local);
      transition_in(itembucket1.$$.fragment, local);
      transition_in(itembucket2.$$.fragment, local);
      transition_in(itembucket3.$$.fragment, local);
      transition_in(if_block0);
      transition_in(itembucket4.$$.fragment, local);
      transition_in(itembucket5.$$.fragment, local);
      transition_in(doccheckbox.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(itembucket0.$$.fragment, local);
      transition_out(itembucket1.$$.fragment, local);
      transition_out(itembucket2.$$.fragment, local);
      transition_out(itembucket3.$$.fragment, local);
      transition_out(if_block0);
      transition_out(itembucket4.$$.fragment, local);
      transition_out(itembucket5.$$.fragment, local);
      transition_out(doccheckbox.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div6);
      }
      destroy_component(itembucket0);
      destroy_component(itembucket1);
      destroy_component(itembucket2);
      destroy_component(itembucket3);
      if (if_block0)
        if_block0.d();
      destroy_component(itembucket4);
      destroy_component(itembucket5);
      destroy_component(doccheckbox);
      if (if_block1)
        if_block1.d();
    }
  };
}
__name(create_fragment$g, "create_fragment$g");
function instance$c($$self, $$props, $$invalidate) {
  let $item;
  const item = getContext("#doc");
  component_subscribe($$self, item, (value) => $$invalidate(0, $item = value));
  return [$item, item];
}
__name(instance$c, "instance$c");
class Links extends SvelteComponent {
  static {
    __name(this, "Links");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$c, create_fragment$g, safe_not_equal, {});
  }
}
function create_default_slot$5(ctx) {
  let tabs_1;
  let updating_activeTab;
  let current;
  function tabs_1_activeTab_binding(value) {
    ctx[2](value);
  }
  __name(tabs_1_activeTab_binding, "tabs_1_activeTab_binding");
  let tabs_1_props = {
    class: "tabs small wide",
    tabs: (
      /*tabs*/
      ctx[1]
    )
  };
  if (
    /*activeTab*/
    ctx[0] !== void 0
  ) {
    tabs_1_props.activeTab = /*activeTab*/
    ctx[0];
  }
  tabs_1 = new Tabs({ props: tabs_1_props });
  binding_callbacks.push(() => bind(tabs_1, "activeTab", tabs_1_activeTab_binding));
  return {
    c() {
      create_component(tabs_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tabs_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tabs_1_changes = {};
      if (!updating_activeTab && dirty & /*activeTab*/
      1) {
        updating_activeTab = true;
        tabs_1_changes.activeTab = /*activeTab*/
        ctx2[0];
        add_flush_callback(() => updating_activeTab = false);
      }
      tabs_1.$set(tabs_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tabs_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tabs_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tabs_1, detaching);
    }
  };
}
__name(create_default_slot$5, "create_default_slot$5");
function create_fragment$f(ctx) {
  let div;
  let portraitframe;
  let current;
  portraitframe = new PortraitFrame({
    props: {
      class: "high frame wide",
      $$slots: { default: [create_default_slot$5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(portraitframe.$$.fragment);
      attr(div, "class", "flex1 portrait-frame svelte-96hhfg");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(portraitframe, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const portraitframe_changes = {};
      if (dirty & /*$$scope, activeTab*/
      9) {
        portraitframe_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portraitframe.$set(portraitframe_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(portraitframe.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(portraitframe.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(portraitframe);
    }
  };
}
__name(create_fragment$f, "create_fragment$f");
function instance$b($$self, $$props, $$invalidate) {
  let { activeTab: activeTab2 = "description" } = $$props;
  const tabs = [
    {
      label: localize(`${SYSTEM_CODE}.ChatText`),
      id: "description",
      component: DescriptionTab
    },
    {
      label: localize(`${SYSTEM_CODE}.Details`),
      id: "details",
      component: Details$4
    },
    {
      label: localize(`${SYSTEM_CODE}.Links`),
      id: "links",
      component: Links
    }
  ];
  function tabs_1_activeTab_binding(value) {
    activeTab2 = value;
    $$invalidate(0, activeTab2);
  }
  __name(tabs_1_activeTab_binding, "tabs_1_activeTab_binding");
  $$self.$$set = ($$props2) => {
    if ("activeTab" in $$props2)
      $$invalidate(0, activeTab2 = $$props2.activeTab);
  };
  return [activeTab2, tabs, tabs_1_activeTab_binding];
}
__name(instance$b, "instance$b");
let Tabs_1$3 = class Tabs_1 extends SvelteComponent {
  static {
    __name(this, "Tabs_1");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$b, create_fragment$f, safe_not_equal, { activeTab: 0 });
  }
};
function create_fragment$e(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "item-header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
__name(create_fragment$e, "create_fragment$e");
let Header$3 = class Header2 extends SvelteComponent {
  static {
    __name(this, "Header");
  }
  constructor(options) {
    super();
    init$1(this, options, null, create_fragment$e, safe_not_equal, {});
  }
};
function create_if_block$2(ctx) {
  let div2;
  let div0;
  let label;
  let div1;
  let docinput;
  let current;
  docinput = new DocInput({
    props: {
      id: "quantity",
      name: "quantity",
      valuePath: "system.quantity"
    }
  });
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      label = element("label");
      label.textContent = `${localize$1("Quantity")}`;
      div1 = element("div");
      create_component(docinput.$$.fragment);
      attr(label, "for", "quantity");
      attr(div0, "class", "flex2");
      attr(div1, "class", "flex2 right");
      attr(div2, "class", "flexrow sheet-row");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, label);
      append(div2, div1);
      mount_component(docinput, div1, null);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(docinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(docinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(docinput);
    }
  };
}
__name(create_if_block$2, "create_if_block$2");
function create_fragment$d(ctx) {
  let div4;
  let div3;
  let h3;
  let div2;
  let div0;
  let label;
  let div1;
  let docselect;
  let current;
  docselect = new DocSelect({
    props: {
      class: "wide right",
      id: "type",
      name: "type",
      type: "number",
      options: (
        /*typeOptions*/
        ctx[2]
      ),
      valuePath: "system.type"
    }
  });
  let if_block = (
    /*parentIsActor*/
    ctx[0] && create_if_block$2()
  );
  return {
    c() {
      div4 = element("div");
      div3 = element("div");
      h3 = element("h3");
      h3.textContent = `${localize$1("General")}`;
      div2 = element("div");
      div0 = element("div");
      label = element("label");
      label.textContent = `${localize$1("Action")} ${localize$1("Type")}`;
      div1 = element("div");
      create_component(docselect.$$.fragment);
      if (if_block)
        if_block.c();
      attr(h3, "class", "left");
      attr(label, "for", "type");
      attr(div0, "class", "flex1");
      attr(div1, "class", "flex4 right wide");
      attr(div2, "class", "flexrow sheet-row justify-vertical wide");
      attr(div3, "class", "flexcol flex3 left high wide");
      attr(div4, "class", "item-sheet details svelte-1kd5sxn");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div3);
      append(div3, h3);
      append(div3, div2);
      append(div2, div0);
      append(div0, label);
      append(div2, div1);
      mount_component(docselect, div1, null);
      if (if_block)
        if_block.m(div3, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*parentIsActor*/
        ctx2[0]
      ) {
        if (if_block) {
          if (dirty & /*parentIsActor*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$2();
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div3, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(docselect.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(docselect.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      destroy_component(docselect);
      if (if_block)
        if_block.d();
    }
  };
}
__name(create_fragment$d, "create_fragment$d");
function instance$a($$self, $$props, $$invalidate) {
  let parentIsActor;
  let $item;
  const item = getContext("#doc");
  component_subscribe($$self, item, (value) => $$invalidate(3, $item = value));
  const typeOptions = getTypeOptions();
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$item*/
    8) {
      $$invalidate(0, parentIsActor = isParentActor($item));
    }
  };
  return [parentIsActor, item, typeOptions, $item];
}
__name(instance$a, "instance$a");
let Details$3 = class Details2 extends SvelteComponent {
  static {
    __name(this, "Details");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$a, create_fragment$d, safe_not_equal, {});
  }
};
function create_default_slot$4(ctx) {
  let tabs_1;
  let updating_activeTab;
  let current;
  function tabs_1_activeTab_binding(value) {
    ctx[5](value);
  }
  __name(tabs_1_activeTab_binding, "tabs_1_activeTab_binding");
  let tabs_1_props = { tabs: (
    /*tabs*/
    ctx[1]
  ) };
  if (
    /*activeTab*/
    ctx[0] !== void 0
  ) {
    tabs_1_props.activeTab = /*activeTab*/
    ctx[0];
  }
  tabs_1 = new Tabs({ props: tabs_1_props });
  binding_callbacks.push(() => bind(tabs_1, "activeTab", tabs_1_activeTab_binding));
  return {
    c() {
      create_component(tabs_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tabs_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tabs_1_changes = {};
      if (dirty & /*tabs*/
      2)
        tabs_1_changes.tabs = /*tabs*/
        ctx2[1];
      if (!updating_activeTab && dirty & /*activeTab*/
      1) {
        updating_activeTab = true;
        tabs_1_changes.activeTab = /*activeTab*/
        ctx2[0];
        add_flush_callback(() => updating_activeTab = false);
      }
      tabs_1.$set(tabs_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tabs_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tabs_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tabs_1, detaching);
    }
  };
}
__name(create_default_slot$4, "create_default_slot$4");
function create_fragment$c(ctx) {
  let div;
  let portraitframe;
  let current;
  portraitframe = new PortraitFrame({
    props: {
      $$slots: { default: [create_default_slot$4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(portraitframe.$$.fragment);
      attr(div, "class", "flex1 portrait-frame svelte-96hhfg");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(portraitframe, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const portraitframe_changes = {};
      if (dirty & /*$$scope, tabs, activeTab*/
      67) {
        portraitframe_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portraitframe.$set(portraitframe_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(portraitframe.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(portraitframe.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(portraitframe);
    }
  };
}
__name(create_fragment$c, "create_fragment$c");
function instance$9($$self, $$props, $$invalidate) {
  let parentIsActor;
  let $item;
  let activeTab2 = "description";
  let tabs = [
    {
      label: localize(`${SYSTEM_CODE}.Description`),
      id: "description",
      component: DescriptionTab
    },
    {
      label: localize(`${SYSTEM_CODE}.Details`),
      id: "details",
      component: Details$3
    },
    {
      label: localize(`${SYSTEM_CODE}.Effects`),
      id: "effects",
      component: EffectsTab
    }
  ];
  const item = getContext("#doc");
  component_subscribe($$self, item, (value) => $$invalidate(4, $item = value));
  onMount(async () => {
    game.system.log.d("EquipmentTabs item", item);
  });
  function tabs_1_activeTab_binding(value) {
    activeTab2 = value;
    $$invalidate(0, activeTab2);
  }
  __name(tabs_1_activeTab_binding, "tabs_1_activeTab_binding");
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$item*/
    16) {
      $$invalidate(3, parentIsActor = isParentActor($item));
    }
    if ($$self.$$.dirty & /*parentIsActor*/
    8) {
      if (parentIsActor) {
        $$invalidate(1, tabs = [
          {
            label: localize(`${SYSTEM_CODE}.Description`),
            id: "description",
            component: DescriptionTab
          }
        ]);
      }
    }
  };
  return [activeTab2, tabs, item, parentIsActor, $item, tabs_1_activeTab_binding];
}
__name(instance$9, "instance$9");
class EquipmentTabs extends SvelteComponent {
  static {
    __name(this, "EquipmentTabs");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$9, create_fragment$c, safe_not_equal, {});
  }
}
function create_fragment$b(ctx) {
  let div3;
  let div2;
  let div1;
  let div0;
  let ol;
  let li0;
  let t0_value = localize$1("Role") + "";
  let t0;
  let t1;
  let t2_value = (
    /*$item*/
    ctx[0]?.system?.role?.capitalize() + ""
  );
  let t2;
  let li1;
  let t3_value = localize$1("Level") + "";
  let t3;
  let t4;
  let t5_value = (
    /*$item*/
    ctx[0]?.system?.level + ""
  );
  let t5;
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      ol = element("ol");
      li0 = element("li");
      t0 = text(t0_value);
      t1 = text(": ");
      t2 = text(t2_value);
      li1 = element("li");
      t3 = text(t3_value);
      t4 = text(": ");
      t5 = text(t5_value);
      attr(ol, "class", "properties-list svelte-1j7mfxl");
      attr(div0, "class", "flexcol flex1 left svelte-1j7mfxl");
      attr(div1, "class", "flexrow svelte-1j7mfxl");
      attr(div2, "class", "flexcol description-tab svelte-1j7mfxl");
      attr(div3, "class", "item-header");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div1);
      append(div1, div0);
      append(div0, ol);
      append(ol, li0);
      append(li0, t0);
      append(li0, t1);
      append(li0, t2);
      append(ol, li1);
      append(li1, t3);
      append(li1, t4);
      append(li1, t5);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$item*/
      1 && t2_value !== (t2_value = /*$item*/
      ctx2[0]?.system?.role?.capitalize() + ""))
        set_data(t2, t2_value);
      if (dirty & /*$item*/
      1 && t5_value !== (t5_value = /*$item*/
      ctx2[0]?.system?.level + ""))
        set_data(t5, t5_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
    }
  };
}
__name(create_fragment$b, "create_fragment$b");
function instance$8($$self, $$props, $$invalidate) {
  let $item;
  const item = getContext("#doc");
  component_subscribe($$self, item, (value) => $$invalidate(0, $item = value));
  return [$item, item];
}
__name(instance$8, "instance$8");
let Header$2 = class Header3 extends SvelteComponent {
  static {
    __name(this, "Header");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$8, create_fragment$b, safe_not_equal, {});
  }
};
function create_fragment$a(ctx) {
  let div9;
  let div8;
  let div6;
  let div2;
  let div0;
  let div1;
  let docinput0;
  let div5;
  let div3;
  let div4;
  let docinput1;
  let div7;
  let itembucket;
  let current;
  docinput0 = new DocInput({
    props: {
      class: "wide",
      type: "text",
      name: "level",
      valuePath: "system.level"
    }
  });
  docinput1 = new DocInput({
    props: {
      class: "wide",
      type: "text",
      name: "role",
      valuePath: "system.role"
    }
  });
  itembucket = new ItemBucket({
    props: {
      title: "Granted Abilities",
      key: "grants"
    }
  });
  return {
    c() {
      div9 = element("div");
      div8 = element("div");
      div6 = element("div");
      div2 = element("div");
      div0 = element("div");
      div0.innerHTML = `<label for="level"></label>`;
      div1 = element("div");
      create_component(docinput0.$$.fragment);
      div5 = element("div");
      div3 = element("div");
      div3.innerHTML = `<label for="role"></label>`;
      div4 = element("div");
      create_component(docinput1.$$.fragment);
      div7 = element("div");
      create_component(itembucket.$$.fragment);
      attr(div0, "class", "flex1 left");
      attr(div1, "class", "flex1");
      attr(div2, "class", "flexrow");
      attr(div3, "class", "flex1 left");
      attr(div4, "class", "flex1");
      attr(div5, "class", "flexrow");
      attr(div6, "class", "flex0 pa-sm");
      attr(div7, "class", "flex3 left high");
      attr(div8, "class", "flexcol");
      attr(div9, "class", "item-sheet details overflow high svelte-9bf1m7");
    },
    m(target, anchor) {
      insert(target, div9, anchor);
      append(div9, div8);
      append(div8, div6);
      append(div6, div2);
      append(div2, div0);
      append(div2, div1);
      mount_component(docinput0, div1, null);
      append(div6, div5);
      append(div5, div3);
      append(div5, div4);
      mount_component(docinput1, div4, null);
      append(div8, div7);
      mount_component(itembucket, div7, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(docinput0.$$.fragment, local);
      transition_in(docinput1.$$.fragment, local);
      transition_in(itembucket.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(docinput0.$$.fragment, local);
      transition_out(docinput1.$$.fragment, local);
      transition_out(itembucket.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div9);
      }
      destroy_component(docinput0);
      destroy_component(docinput1);
      destroy_component(itembucket);
    }
  };
}
__name(create_fragment$a, "create_fragment$a");
function instance$7($$self) {
  getContext("#doc");
  localize(`${SYSTEM_CODE}.Types.Item.Types.job.Level`);
  localize(`${SYSTEM_CODE}.Types.Item.Types.job.Role`);
  return [];
}
__name(instance$7, "instance$7");
let Details$2 = class Details3 extends SvelteComponent {
  static {
    __name(this, "Details");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$7, create_fragment$a, safe_not_equal, {});
  }
};
function create_default_slot$3(ctx) {
  let tabs_1;
  let updating_activeTab;
  let current;
  function tabs_1_activeTab_binding(value) {
    ctx[2](value);
  }
  __name(tabs_1_activeTab_binding, "tabs_1_activeTab_binding");
  let tabs_1_props = {
    class: "tabs small",
    tabs: (
      /*tabs*/
      ctx[1]
    )
  };
  if (
    /*activeTab*/
    ctx[0] !== void 0
  ) {
    tabs_1_props.activeTab = /*activeTab*/
    ctx[0];
  }
  tabs_1 = new Tabs({ props: tabs_1_props });
  binding_callbacks.push(() => bind(tabs_1, "activeTab", tabs_1_activeTab_binding));
  return {
    c() {
      create_component(tabs_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tabs_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tabs_1_changes = {};
      if (!updating_activeTab && dirty & /*activeTab*/
      1) {
        updating_activeTab = true;
        tabs_1_changes.activeTab = /*activeTab*/
        ctx2[0];
        add_flush_callback(() => updating_activeTab = false);
      }
      tabs_1.$set(tabs_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tabs_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tabs_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tabs_1, detaching);
    }
  };
}
__name(create_default_slot$3, "create_default_slot$3");
function create_fragment$9(ctx) {
  let div;
  let portraitframe;
  let current;
  portraitframe = new PortraitFrame({
    props: {
      class: "high frame",
      $$slots: { default: [create_default_slot$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(portraitframe.$$.fragment);
      attr(div, "class", "flex1 portrait-frame svelte-96hhfg");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(portraitframe, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const portraitframe_changes = {};
      if (dirty & /*$$scope, activeTab*/
      9) {
        portraitframe_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portraitframe.$set(portraitframe_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(portraitframe.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(portraitframe.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(portraitframe);
    }
  };
}
__name(create_fragment$9, "create_fragment$9");
function instance$6($$self, $$props, $$invalidate) {
  let { activeTab: activeTab2 = "description" } = $$props;
  const tabs = [
    {
      label: localize(`${SYSTEM_CODE}.Description`),
      id: "description",
      component: DescriptionTab
    },
    {
      label: localize(`${SYSTEM_CODE}.Details`),
      id: "details",
      component: Details$2
    }
  ];
  function tabs_1_activeTab_binding(value) {
    activeTab2 = value;
    $$invalidate(0, activeTab2);
  }
  __name(tabs_1_activeTab_binding, "tabs_1_activeTab_binding");
  $$self.$$set = ($$props2) => {
    if ("activeTab" in $$props2)
      $$invalidate(0, activeTab2 = $$props2.activeTab);
  };
  return [activeTab2, tabs, tabs_1_activeTab_binding];
}
__name(instance$6, "instance$6");
let Tabs_1$2 = class Tabs_12 extends SvelteComponent {
  static {
    __name(this, "Tabs_1");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$6, create_fragment$9, safe_not_equal, { activeTab: 0 });
  }
};
function create_fragment$8(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "item-header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
__name(create_fragment$8, "create_fragment$8");
let Header$1 = class Header4 extends SvelteComponent {
  static {
    __name(this, "Header");
  }
  constructor(options) {
    super();
    init$1(this, options, null, create_fragment$8, safe_not_equal, {});
  }
};
function create_if_block_3(ctx) {
  let div2;
  let div0;
  let docselect0;
  let div1;
  let docselect1;
  let current;
  docselect0 = new DocSelect({
    props: {
      class: "left",
      id: "limitation",
      name: "limitation",
      options: (
        /*limitationOptions*/
        ctx[2]
      ),
      valuePath: "system.limitation"
    }
  });
  docselect1 = new DocSelect({
    props: {
      class: "right",
      id: "limitationUnits",
      name: "limitationUnits",
      options: (
        /*limitationUnitsOptions*/
        ctx[3]
      ),
      valuePath: "system.limitationUnits"
    }
  });
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      create_component(docselect0.$$.fragment);
      div1 = element("div");
      create_component(docselect1.$$.fragment);
      attr(div0, "class", "flex2 left");
      attr(div1, "class", "flex2 right");
      attr(div2, "class", "flexrow sheet-row justify-vertical");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      mount_component(docselect0, div0, null);
      append(div2, div1);
      mount_component(docselect1, div1, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(docselect0.$$.fragment, local);
      transition_in(docselect1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(docselect0.$$.fragment, local);
      transition_out(docselect1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(docselect0);
      destroy_component(docselect1);
    }
  };
}
__name(create_if_block_3, "create_if_block_3");
function create_if_block_2(ctx) {
  let div3;
  let div0;
  let docselect0;
  let div1;
  let docselect1;
  let div2;
  let docinput;
  let current;
  docselect0 = new DocSelect({
    props: {
      class: "left",
      style: "min-width: 4em;",
      id: "modType",
      name: "modType",
      options: (
        /*modOptions*/
        ctx[6]
      ),
      valuePath: "system.modType"
    }
  });
  docselect1 = new DocSelect({
    props: {
      style: "width: 2em;",
      id: "operator",
      name: "operator",
      options: (
        /*operatorOptions*/
        ctx[7]
      ),
      valuePath: "system.operator"
    }
  });
  docinput = new DocInput({
    props: {
      class: "wide right",
      id: "modAmount",
      name: "modAmount",
      valuePath: "system.modAmount"
    }
  });
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      create_component(docselect0.$$.fragment);
      div1 = element("div");
      create_component(docselect1.$$.fragment);
      div2 = element("div");
      create_component(docinput.$$.fragment);
      attr(div0, "class", "flex3 left");
      attr(div1, "class", "flex1");
      attr(div2, "class", "flex3 right");
      attr(div3, "class", "flexrow sheet-row justify-vertical");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      mount_component(docselect0, div0, null);
      append(div3, div1);
      mount_component(docselect1, div1, null);
      append(div3, div2);
      mount_component(docinput, div2, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(docselect0.$$.fragment, local);
      transition_in(docselect1.$$.fragment, local);
      transition_in(docinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(docselect0.$$.fragment, local);
      transition_out(docselect1.$$.fragment, local);
      transition_out(docinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      destroy_component(docselect0);
      destroy_component(docselect1);
      destroy_component(docinput);
    }
  };
}
__name(create_if_block_2, "create_if_block_2");
function create_if_block_1(ctx) {
  let div2;
  let div0;
  let label;
  let div1;
  let docselect;
  let current;
  docselect = new DocSelect({
    props: {
      class: "left",
      style: "min-width: 4em;",
      id: "damageDiceReroll",
      name: "damageDiceReroll",
      options: (
        /*damageDiceRerollOptions*/
        ctx[4]
      ),
      valuePath: "system.damageDiceReroll"
    }
  });
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      label = element("label");
      label.textContent = `${localize$1("Types.Item.Types.Options.DamageDiceReroll.label")}`;
      div1 = element("div");
      create_component(docselect.$$.fragment);
      attr(label, "for", "damageDiceReroll");
      attr(div0, "class", "flex3");
      attr(div1, "class", "flex2 right");
      attr(div2, "class", "flexrow sheet-row justify-vertical");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, label);
      append(div2, div1);
      mount_component(docselect, div1, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(docselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(docselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(docselect);
    }
  };
}
__name(create_if_block_1, "create_if_block_1");
function create_if_block$1(ctx) {
  let div0;
  let taginput;
  let div1;
  let current;
  taginput = new TagInput({});
  return {
    c() {
      div0 = element("div");
      create_component(taginput.$$.fragment);
      div1 = element("div");
      div1.innerHTML = ``;
      attr(div0, "class", "px-sm");
      attr(div1, "class", "pb-lg");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      mount_component(taginput, div0, null);
      insert(target, div1, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(taginput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(taginput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(div1);
      }
      destroy_component(taginput);
    }
  };
}
__name(create_if_block$1, "create_if_block$1");
function create_fragment$7(ctx) {
  let div19;
  let div18;
  let h30;
  let div2;
  let div0;
  let label;
  let div1;
  let docselect;
  let div5;
  let div3;
  let h31;
  let div4;
  let doccheckbox0;
  let if_block0_anchor;
  let durationcomponent;
  let div8;
  let div6;
  let h32;
  let div7;
  let doccheckbox1;
  let div11;
  let div9;
  let h33;
  let div10;
  let doccheckbox2;
  let div14;
  let div12;
  let h34;
  let div13;
  let doccheckbox3;
  let div17;
  let div15;
  let h35;
  let div16;
  let doccheckbox4;
  let current;
  docselect = new DocSelect({
    props: {
      class: "right",
      id: "type",
      name: "type",
      options: (
        /*typeOptions*/
        ctx[5]
      ),
      valuePath: "system.type"
    }
  });
  doccheckbox0 = new DocCheckbox({
    props: {
      name: "hasLimitation",
      valuePath: "system.hasLimitation"
    }
  });
  let if_block0 = (
    /*$item*/
    ctx[0].system.hasLimitation && create_if_block_3(ctx)
  );
  durationcomponent = new Duration2({});
  doccheckbox1 = new DocCheckbox({
    props: {
      name: "hasModifier",
      valuePath: "system.hasModifier"
    }
  });
  let if_block1 = (
    /*$item*/
    ctx[0].system.hasModifier && create_if_block_2(ctx)
  );
  doccheckbox2 = new DocCheckbox({
    props: {
      name: "sacrificesMovement",
      valuePath: "system.sacrificesMovement"
    }
  });
  doccheckbox3 = new DocCheckbox({
    props: {
      name: "hasDamageDiceReroll",
      valuePath: "system.hasDamageDiceReroll"
    }
  });
  let if_block2 = (
    /*$item*/
    ctx[0].system.hasDamageDiceReroll && create_if_block_1(ctx)
  );
  doccheckbox4 = new DocCheckbox({
    props: {
      name: "hasTags",
      valuePath: "system.hasTags"
    }
  });
  let if_block3 = (
    /*$item*/
    ctx[0].system.hasTags && create_if_block$1()
  );
  return {
    c() {
      div19 = element("div");
      div18 = element("div");
      h30 = element("h3");
      h30.textContent = `${localize$1("General")}`;
      div2 = element("div");
      div0 = element("div");
      label = element("label");
      label.textContent = `${localize$1("Type")}`;
      div1 = element("div");
      create_component(docselect.$$.fragment);
      div5 = element("div");
      div3 = element("div");
      h31 = element("h3");
      h31.textContent = `${localize$1("Limitation")}`;
      div4 = element("div");
      create_component(doccheckbox0.$$.fragment);
      if (if_block0)
        if_block0.c();
      if_block0_anchor = empty();
      create_component(durationcomponent.$$.fragment);
      div8 = element("div");
      div6 = element("div");
      h32 = element("h3");
      h32.textContent = `${localize$1("Modifier")}`;
      div7 = element("div");
      create_component(doccheckbox1.$$.fragment);
      if (if_block1)
        if_block1.c();
      div11 = element("div");
      div9 = element("div");
      h33 = element("h3");
      h33.textContent = `${localize$1("Types.Item.Types.Options.SacrificesMovement.label")}`;
      div10 = element("div");
      create_component(doccheckbox2.$$.fragment);
      div14 = element("div");
      div12 = element("div");
      h34 = element("h3");
      h34.textContent = `${localize$1("Types.Item.Types.Options.DamageDiceReroll.label")}`;
      div13 = element("div");
      create_component(doccheckbox3.$$.fragment);
      if (if_block2)
        if_block2.c();
      div17 = element("div");
      div15 = element("div");
      h35 = element("h3");
      h35.textContent = `${localize$1("Tags")}`;
      div16 = element("div");
      create_component(doccheckbox4.$$.fragment);
      if (if_block3)
        if_block3.c();
      attr(h30, "class", "left");
      attr(label, "for", "type");
      attr(div0, "class", "flex3");
      attr(div1, "class", "flex2 right");
      attr(div2, "class", "flexrow sheet-row justify-vertical");
      attr(h31, "class", "left");
      attr(div3, "class", "flex4");
      attr(div4, "class", "flex0 right");
      attr(div5, "class", "flexrow justify-vertical");
      attr(h32, "class", "left");
      attr(div6, "class", "flex4");
      attr(div7, "class", "flex0 right");
      attr(div8, "class", "flexrow justify-vertical");
      attr(h33, "class", "left tooltip");
      attr(h33, "data-tooltip", localize$1("Types.Item.Types.Options.SacrificesMovement.description"));
      attr(div9, "class", "flex4");
      attr(div10, "class", "flex0 right");
      attr(div11, "class", "flexrow justify-vertical");
      attr(h34, "class", "left");
      attr(div12, "class", "flex4");
      attr(div13, "class", "flex0 right");
      attr(div14, "class", "flexrow justify-vertical");
      attr(h35, "class", "left");
      attr(div15, "class", "flex4");
      attr(div16, "class", "flex0 right");
      attr(div17, "class", "flexrow sheet-row justify-vertical");
      attr(div18, "class", "flexcol flex3 left high bigbottom");
      attr(div19, "class", "item-sheet details overflow svelte-7hc7it");
    },
    m(target, anchor) {
      insert(target, div19, anchor);
      append(div19, div18);
      append(div18, h30);
      append(div18, div2);
      append(div2, div0);
      append(div0, label);
      append(div2, div1);
      mount_component(docselect, div1, null);
      append(div18, div5);
      append(div5, div3);
      append(div3, h31);
      append(div5, div4);
      mount_component(doccheckbox0, div4, null);
      if (if_block0)
        if_block0.m(div18, null);
      append(div18, if_block0_anchor);
      mount_component(durationcomponent, div18, null);
      append(div18, div8);
      append(div8, div6);
      append(div6, h32);
      append(div8, div7);
      mount_component(doccheckbox1, div7, null);
      if (if_block1)
        if_block1.m(div18, null);
      append(div18, div11);
      append(div11, div9);
      append(div9, h33);
      append(div11, div10);
      mount_component(doccheckbox2, div10, null);
      append(div18, div14);
      append(div14, div12);
      append(div12, h34);
      append(div14, div13);
      mount_component(doccheckbox3, div13, null);
      if (if_block2)
        if_block2.m(div18, null);
      append(div18, div17);
      append(div17, div15);
      append(div15, h35);
      append(div17, div16);
      mount_component(doccheckbox4, div16, null);
      if (if_block3)
        if_block3.m(div18, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*$item*/
        ctx2[0].system.hasLimitation
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$item*/
          1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div18, if_block0_anchor);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*$item*/
        ctx2[0].system.hasModifier
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$item*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div18, div11);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*$item*/
        ctx2[0].system.hasDamageDiceReroll
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*$item*/
          1) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_1(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div18, div17);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*$item*/
        ctx2[0].system.hasTags
      ) {
        if (if_block3) {
          if (dirty & /*$item*/
          1) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block$1();
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div18, null);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(docselect.$$.fragment, local);
      transition_in(doccheckbox0.$$.fragment, local);
      transition_in(if_block0);
      transition_in(durationcomponent.$$.fragment, local);
      transition_in(doccheckbox1.$$.fragment, local);
      transition_in(if_block1);
      transition_in(doccheckbox2.$$.fragment, local);
      transition_in(doccheckbox3.$$.fragment, local);
      transition_in(if_block2);
      transition_in(doccheckbox4.$$.fragment, local);
      transition_in(if_block3);
      current = true;
    },
    o(local) {
      transition_out(docselect.$$.fragment, local);
      transition_out(doccheckbox0.$$.fragment, local);
      transition_out(if_block0);
      transition_out(durationcomponent.$$.fragment, local);
      transition_out(doccheckbox1.$$.fragment, local);
      transition_out(if_block1);
      transition_out(doccheckbox2.$$.fragment, local);
      transition_out(doccheckbox3.$$.fragment, local);
      transition_out(if_block2);
      transition_out(doccheckbox4.$$.fragment, local);
      transition_out(if_block3);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div19);
      }
      destroy_component(docselect);
      destroy_component(doccheckbox0);
      if (if_block0)
        if_block0.d();
      destroy_component(durationcomponent);
      destroy_component(doccheckbox1);
      if (if_block1)
        if_block1.d();
      destroy_component(doccheckbox2);
      destroy_component(doccheckbox3);
      if (if_block2)
        if_block2.d();
      destroy_component(doccheckbox4);
      if (if_block3)
        if_block3.d();
    }
  };
}
__name(create_fragment$7, "create_fragment$7");
function instance$5($$self, $$props, $$invalidate) {
  let $item;
  const item = getContext("#doc");
  component_subscribe($$self, item, (value) => $$invalidate(0, $item = value));
  const limitationOptions = getLimitationOptions();
  const limitationUnitsOptions = getLimitationUnits();
  const damageDiceRerollOptions = getDamageDiceRerollOptions();
  const typeOptions = [
    {
      value: "Buff",
      label: localize$1("Types.Item.Types.Options.TraitType.Buff")
    },
    {
      value: "Debuff",
      label: localize$1("Types.Item.Types.Options.TraitType.Debuff")
    },
    {
      value: "Trait",
      label: localize$1("Types.Item.Types.Options.TraitType.Trait")
    }
  ];
  const modOptions = [
    {
      value: "All Checks",
      label: localize$1("Types.Item.Types.Options.ModType.Allchecks")
    },
    {
      value: "All Damage",
      label: localize$1("Types.Item.Types.Options.ModType.AllDamage")
    },
    {
      value: "Bonus Dice",
      label: localize$1("Types.Item.Types.Options.ModType.BonusDice")
    },
    {
      value: "Movement",
      label: localize$1("Types.Item.Types.Options.ModType.Movement")
    },
    {
      value: "DOT",
      label: localize$1("Types.Item.Types.Options.ModType.DOT")
    }
  ];
  const operatorOptions = [{ value: "+", label: "+" }, { value: "-", label: "-" }];
  return [
    $item,
    item,
    limitationOptions,
    limitationUnitsOptions,
    damageDiceRerollOptions,
    typeOptions,
    modOptions,
    operatorOptions
  ];
}
__name(instance$5, "instance$5");
let Details$1 = class Details4 extends SvelteComponent {
  static {
    __name(this, "Details");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$5, create_fragment$7, safe_not_equal, {});
  }
};
function create_default_slot$2(ctx) {
  let tabs_1;
  let updating_activeTab;
  let current;
  function tabs_1_activeTab_binding(value) {
    ctx[2](value);
  }
  __name(tabs_1_activeTab_binding, "tabs_1_activeTab_binding");
  let tabs_1_props = {
    class: "tabs small",
    tabs: (
      /*tabs*/
      ctx[1]
    )
  };
  if (
    /*activeTab*/
    ctx[0] !== void 0
  ) {
    tabs_1_props.activeTab = /*activeTab*/
    ctx[0];
  }
  tabs_1 = new Tabs({ props: tabs_1_props });
  binding_callbacks.push(() => bind(tabs_1, "activeTab", tabs_1_activeTab_binding));
  return {
    c() {
      create_component(tabs_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tabs_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tabs_1_changes = {};
      if (!updating_activeTab && dirty & /*activeTab*/
      1) {
        updating_activeTab = true;
        tabs_1_changes.activeTab = /*activeTab*/
        ctx2[0];
        add_flush_callback(() => updating_activeTab = false);
      }
      tabs_1.$set(tabs_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tabs_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tabs_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tabs_1, detaching);
    }
  };
}
__name(create_default_slot$2, "create_default_slot$2");
function create_fragment$6(ctx) {
  let div;
  let portraitframe;
  let current;
  portraitframe = new PortraitFrame({
    props: {
      class: "high frame",
      $$slots: { default: [create_default_slot$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(portraitframe.$$.fragment);
      attr(div, "class", "flex1 portrait-frame svelte-96hhfg");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(portraitframe, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const portraitframe_changes = {};
      if (dirty & /*$$scope, activeTab*/
      9) {
        portraitframe_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portraitframe.$set(portraitframe_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(portraitframe.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(portraitframe.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(portraitframe);
    }
  };
}
__name(create_fragment$6, "create_fragment$6");
function instance$4($$self, $$props, $$invalidate) {
  let { activeTab: activeTab2 = "description" } = $$props;
  const tabs = [
    {
      label: localize(`${SYSTEM_CODE}.Description`),
      id: "description",
      component: DescriptionTab
    },
    {
      label: localize(`${SYSTEM_CODE}.Details`),
      id: "details",
      component: Details$1
    },
    {
      label: localize(`${SYSTEM_CODE}.Effects`),
      id: "effects",
      component: EffectsTab
    }
  ];
  function tabs_1_activeTab_binding(value) {
    activeTab2 = value;
    $$invalidate(0, activeTab2);
  }
  __name(tabs_1_activeTab_binding, "tabs_1_activeTab_binding");
  $$self.$$set = ($$props2) => {
    if ("activeTab" in $$props2)
      $$invalidate(0, activeTab2 = $$props2.activeTab);
  };
  return [activeTab2, tabs, tabs_1_activeTab_binding];
}
__name(instance$4, "instance$4");
let Tabs_1$1 = class Tabs_13 extends SvelteComponent {
  static {
    __name(this, "Tabs_1");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$4, create_fragment$6, safe_not_equal, { activeTab: 0 });
  }
};
function create_fragment$5(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "item-header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
__name(create_fragment$5, "create_fragment$5");
class Header5 extends SvelteComponent {
  static {
    __name(this, "Header");
  }
  constructor(options) {
    super();
    init$1(this, options, null, create_fragment$5, safe_not_equal, {});
  }
}
function create_fragment$4(ctx) {
  let div;
  let durationcomponent;
  let current;
  durationcomponent = new Duration2({});
  return {
    c() {
      div = element("div");
      create_component(durationcomponent.$$.fragment);
      attr(div, "class", "item-sheet details overflow svelte-7hc7it");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(durationcomponent, div, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(durationcomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(durationcomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(durationcomponent);
    }
  };
}
__name(create_fragment$4, "create_fragment$4");
class Details5 extends SvelteComponent {
  static {
    __name(this, "Details");
  }
  constructor(options) {
    super();
    init$1(this, options, null, create_fragment$4, safe_not_equal, {});
  }
}
function create_default_slot$1(ctx) {
  let tabs_1;
  let updating_activeTab;
  let current;
  function tabs_1_activeTab_binding(value) {
    ctx[2](value);
  }
  __name(tabs_1_activeTab_binding, "tabs_1_activeTab_binding");
  let tabs_1_props = {
    class: "tabs small",
    tabs: (
      /*tabs*/
      ctx[1]
    )
  };
  if (
    /*activeTab*/
    ctx[0] !== void 0
  ) {
    tabs_1_props.activeTab = /*activeTab*/
    ctx[0];
  }
  tabs_1 = new Tabs({ props: tabs_1_props });
  binding_callbacks.push(() => bind(tabs_1, "activeTab", tabs_1_activeTab_binding));
  return {
    c() {
      create_component(tabs_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tabs_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tabs_1_changes = {};
      if (!updating_activeTab && dirty & /*activeTab*/
      1) {
        updating_activeTab = true;
        tabs_1_changes.activeTab = /*activeTab*/
        ctx2[0];
        add_flush_callback(() => updating_activeTab = false);
      }
      tabs_1.$set(tabs_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tabs_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tabs_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tabs_1, detaching);
    }
  };
}
__name(create_default_slot$1, "create_default_slot$1");
function create_fragment$3(ctx) {
  let div;
  let portraitframe;
  let current;
  portraitframe = new PortraitFrame({
    props: {
      class: "high frame",
      $$slots: { default: [create_default_slot$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(portraitframe.$$.fragment);
      attr(div, "class", "flex1 portrait-frame svelte-96hhfg");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(portraitframe, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const portraitframe_changes = {};
      if (dirty & /*$$scope, activeTab*/
      9) {
        portraitframe_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portraitframe.$set(portraitframe_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(portraitframe.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(portraitframe.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(portraitframe);
    }
  };
}
__name(create_fragment$3, "create_fragment$3");
function instance$3($$self, $$props, $$invalidate) {
  let { activeTab: activeTab2 = "description" } = $$props;
  const tabs = [
    {
      label: localize(`${SYSTEM_CODE}.Description`),
      id: "description",
      component: DescriptionTab
    },
    {
      label: localize(`${SYSTEM_CODE}.Details`),
      id: "details",
      component: Details5
    },
    {
      label: localize(`${SYSTEM_CODE}.Effects`),
      id: "effects",
      component: EffectsTab
    }
  ];
  function tabs_1_activeTab_binding(value) {
    activeTab2 = value;
    $$invalidate(0, activeTab2);
  }
  __name(tabs_1_activeTab_binding, "tabs_1_activeTab_binding");
  $$self.$$set = ($$props2) => {
    if ("activeTab" in $$props2)
      $$invalidate(0, activeTab2 = $$props2.activeTab);
  };
  return [activeTab2, tabs, tabs_1_activeTab_binding];
}
__name(instance$3, "instance$3");
class Tabs_14 extends SvelteComponent {
  static {
    __name(this, "Tabs_1");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$3, create_fragment$3, safe_not_equal, { activeTab: 0 });
  }
}
function create_default_slot(ctx) {
  let div6;
  let div3;
  let div0;
  let button;
  let img;
  let img_src_value;
  let img_data_tooltip_value;
  let img_alt_value;
  let div2;
  let table;
  let tbody;
  let tr;
  let td;
  let div1;
  let t_value = game.i18n.localize(`TYPES.Item.${/*item*/
  ctx[4].type}`) + "";
  let t;
  let switch_instance0;
  let div5;
  let header;
  let div4;
  let docinput;
  let section;
  let switch_instance1;
  let updating_activeTab;
  let current;
  let mounted;
  let dispose;
  var switch_value = (
    /*headerMap*/
    ctx[5][
      /*item*/
      ctx[4].type
    ]
  );
  function switch_props(ctx2, dirty) {
    return {};
  }
  __name(switch_props, "switch_props");
  if (switch_value) {
    switch_instance0 = construct_svelte_component(switch_value, switch_props());
  }
  docinput = new DocInput({
    props: {
      class: "wide widebutton left",
      id: "name",
      valuePath: "name",
      placeholder: "Item Name",
      maxlength: "40",
      textClasses: "wide bold burgundy"
    }
  });
  function switch_instance1_activeTab_binding(value) {
    ctx[8](value);
  }
  __name(switch_instance1_activeTab_binding, "switch_instance1_activeTab_binding");
  var switch_value_1 = (
    /*tabMap*/
    ctx[6][
      /*item*/
      ctx[4].type
    ]
  );
  function switch_props_1(ctx2, dirty) {
    let switch_instance1_props = {};
    if (
      /*activeTab*/
      ctx2[3] !== void 0
    ) {
      switch_instance1_props.activeTab = /*activeTab*/
      ctx2[3];
    }
    return { props: switch_instance1_props };
  }
  __name(switch_props_1, "switch_props_1");
  if (switch_value_1) {
    switch_instance1 = construct_svelte_component(switch_value_1, switch_props_1(ctx));
    binding_callbacks.push(() => bind(switch_instance1, "activeTab", switch_instance1_activeTab_binding));
  }
  return {
    c() {
      div6 = element("div");
      div3 = element("div");
      div0 = element("div");
      button = element("button");
      img = element("img");
      div2 = element("div");
      table = element("table");
      tbody = element("tbody");
      tr = element("tr");
      td = element("td");
      div1 = element("div");
      t = text(t_value);
      if (switch_instance0)
        create_component(switch_instance0.$$.fragment);
      div5 = element("div");
      header = element("header");
      div4 = element("div");
      create_component(docinput.$$.fragment);
      section = element("section");
      if (switch_instance1)
        create_component(switch_instance1.$$.fragment);
      attr(img, "class", "profile svelte-18qgyfp");
      if (!src_url_equal(img.src, img_src_value = /*$documentStore*/
      ctx[2]?.img))
        attr(img, "src", img_src_value);
      attr(img, "data-tooltip", img_data_tooltip_value = /*$documentStore*/
      ctx[2]?.name);
      attr(img, "alt", img_alt_value = /*$documentStore*/
      ctx[2]?.name);
      attr(button, "class", "stealth profile");
      attr(div0, "class", "flex0");
      set_style(table, "text-align", "center");
      attr(div2, "class", "flexcol");
      attr(div3, "class", "flex1 profile-wrap svelte-18qgyfp");
      attr(div4, "class", "left wide");
      attr(header, "class", "wide");
      attr(section, "class", "mt-sm high");
      attr(div5, "class", "flex4 wide mr-sm high");
      attr(div6, "class", "flexrow gap-15 wide high no-overflow nowrap");
    },
    m(target, anchor) {
      insert(target, div6, anchor);
      append(div6, div3);
      append(div3, div0);
      append(div0, button);
      append(button, img);
      append(div3, div2);
      append(div2, table);
      append(table, tbody);
      append(tbody, tr);
      append(tr, td);
      append(td, div1);
      append(div1, t);
      if (switch_instance0)
        mount_component(switch_instance0, div2, null);
      append(div6, div5);
      append(div5, header);
      append(header, div4);
      mount_component(docinput, div4, null);
      append(div5, section);
      if (switch_instance1)
        mount_component(switch_instance1, section, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*_launchStandardProfileEditor*/
          ctx[7]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*$documentStore*/
      4 && !src_url_equal(img.src, img_src_value = /*$documentStore*/
      ctx2[2]?.img)) {
        attr(img, "src", img_src_value);
      }
      if (!current || dirty & /*$documentStore*/
      4 && img_data_tooltip_value !== (img_data_tooltip_value = /*$documentStore*/
      ctx2[2]?.name)) {
        attr(img, "data-tooltip", img_data_tooltip_value);
      }
      if (!current || dirty & /*$documentStore*/
      4 && img_alt_value !== (img_alt_value = /*$documentStore*/
      ctx2[2]?.name)) {
        attr(img, "alt", img_alt_value);
      }
      if ((!current || dirty & /*item*/
      16) && t_value !== (t_value = game.i18n.localize(`TYPES.Item.${/*item*/
      ctx2[4].type}`) + ""))
        set_data(t, t_value);
      if (dirty & /*item*/
      16 && switch_value !== (switch_value = /*headerMap*/
      ctx2[5][
        /*item*/
        ctx2[4].type
      ])) {
        if (switch_instance0) {
          group_outros();
          const old_component = switch_instance0;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance0 = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance0.$$.fragment);
          transition_in(switch_instance0.$$.fragment, 1);
          mount_component(switch_instance0, div2, null);
        } else {
          switch_instance0 = null;
        }
      }
      if (dirty & /*item*/
      16 && switch_value_1 !== (switch_value_1 = /*tabMap*/
      ctx2[6][
        /*item*/
        ctx2[4].type
      ])) {
        if (switch_instance1) {
          group_outros();
          const old_component = switch_instance1;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_1) {
          switch_instance1 = construct_svelte_component(switch_value_1, switch_props_1(ctx2));
          binding_callbacks.push(() => bind(switch_instance1, "activeTab", switch_instance1_activeTab_binding));
          create_component(switch_instance1.$$.fragment);
          transition_in(switch_instance1.$$.fragment, 1);
          mount_component(switch_instance1, section, null);
        } else {
          switch_instance1 = null;
        }
      } else if (switch_value_1) {
        const switch_instance1_changes = {};
        if (!updating_activeTab && dirty & /*activeTab*/
        8) {
          updating_activeTab = true;
          switch_instance1_changes.activeTab = /*activeTab*/
          ctx2[3];
          add_flush_callback(() => updating_activeTab = false);
        }
        switch_instance1.$set(switch_instance1_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance0)
        transition_in(switch_instance0.$$.fragment, local);
      transition_in(docinput.$$.fragment, local);
      if (switch_instance1)
        transition_in(switch_instance1.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance0)
        transition_out(switch_instance0.$$.fragment, local);
      transition_out(docinput.$$.fragment, local);
      if (switch_instance1)
        transition_out(switch_instance1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div6);
      }
      if (switch_instance0)
        destroy_component(switch_instance0);
      destroy_component(docinput);
      if (switch_instance1)
        destroy_component(switch_instance1);
      mounted = false;
      dispose();
    }
  };
}
__name(create_default_slot, "create_default_slot");
function create_fragment$2(ctx) {
  let applicationshell;
  let updating_elementRoot;
  let current;
  function applicationshell_elementRoot_binding(value) {
    ctx[9](value);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  let applicationshell_props = {
    $$slots: { default: [create_default_slot] },
    $$scope: { ctx }
  };
  if (
    /*elementRoot*/
    ctx[0] !== void 0
  ) {
    applicationshell_props.elementRoot = /*elementRoot*/
    ctx[0];
  }
  applicationshell = new ApplicationShell({ props: applicationshell_props });
  binding_callbacks.push(() => bind(applicationshell, "elementRoot", applicationshell_elementRoot_binding));
  return {
    c() {
      create_component(applicationshell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(applicationshell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const applicationshell_changes = {};
      if (dirty & /*$$scope, item, activeTab, $documentStore*/
      8220) {
        applicationshell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_elementRoot && dirty & /*elementRoot*/
      1) {
        updating_elementRoot = true;
        applicationshell_changes.elementRoot = /*elementRoot*/
        ctx2[0];
        add_flush_callback(() => updating_elementRoot = false);
      }
      applicationshell.$set(applicationshell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applicationshell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applicationshell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applicationshell, detaching);
    }
  };
}
__name(create_fragment$2, "create_fragment$2");
function instance$2($$self, $$props, $$invalidate) {
  let item;
  let $documentStore, $$unsubscribe_documentStore = noop, $$subscribe_documentStore = /* @__PURE__ */ __name(() => ($$unsubscribe_documentStore(), $$unsubscribe_documentStore = subscribe(documentStore, ($$value) => $$invalidate(2, $documentStore = $$value)), documentStore), "$$subscribe_documentStore");
  $$self.$$.on_destroy.push(() => $$unsubscribe_documentStore());
  let { elementRoot } = $$props;
  let { documentStore } = $$props;
  $$subscribe_documentStore();
  const headerMap = {
    action: Header$4,
    equipment: Header$3,
    job: Header$2,
    trait: Header$1,
    effect: Header5
  };
  const tabMap = {
    action: Tabs_1$3,
    equipment: EquipmentTabs,
    job: Tabs_1$2,
    trait: Tabs_1$1,
    effect: Tabs_14
  };
  const application = getContext("#external").application;
  let activeTab2 = "description";
  setContext("#doc", documentStore);
  let _filePickerInstance = {};
  function _launchStandardProfileEditor(event) {
    const current = $documentStore.img;
    if (_filePickerInstance instanceof FilePicker && !_filePickerInstance?.rendered) {
      _filePickerInstance.render(true);
      return;
    }
    _filePickerInstance = new FilePicker({
      type: "image",
      current,
      callback: (path) => {
        $documentStore.update({ img: path });
      },
      top: application.position.top + 40,
      left: application.position.left + 10
    });
    return _filePickerInstance.browse();
  }
  __name(_launchStandardProfileEditor, "_launchStandardProfileEditor");
  onMount(() => {
    game.system.log.d("ItemSheetShell mounted", $documentStore);
  });
  function switch_instance1_activeTab_binding(value) {
    activeTab2 = value;
    $$invalidate(3, activeTab2);
  }
  __name(switch_instance1_activeTab_binding, "switch_instance1_activeTab_binding");
  function applicationshell_elementRoot_binding(value) {
    elementRoot = value;
    $$invalidate(0, elementRoot);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  $$self.$$set = ($$props2) => {
    if ("elementRoot" in $$props2)
      $$invalidate(0, elementRoot = $$props2.elementRoot);
    if ("documentStore" in $$props2)
      $$subscribe_documentStore($$invalidate(1, documentStore = $$props2.documentStore));
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$documentStore*/
    4) {
      $$invalidate(4, item = $documentStore);
    }
  };
  return [
    elementRoot,
    documentStore,
    $documentStore,
    activeTab2,
    item,
    headerMap,
    tabMap,
    _launchStandardProfileEditor,
    switch_instance1_activeTab_binding,
    applicationshell_elementRoot_binding
  ];
}
__name(instance$2, "instance$2");
class ItemSheetShell extends SvelteComponent {
  static {
    __name(this, "ItemSheetShell");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$2, create_fragment$2, safe_not_equal, { elementRoot: 0, documentStore: 1 });
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(elementRoot) {
    this.$$set({ elementRoot });
    flush();
  }
  get documentStore() {
    return this.$$.ctx[1];
  }
  set documentStore(documentStore) {
    this.$$set({ documentStore });
    flush();
  }
}
class FFXIVItemSheet extends SvelteDocumentSheet {
  static {
    __name(this, "FFXIVItemSheet");
  }
  /**
   * Default Application options
   * @return {object} The default options for this application
   */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      id: `${SYSTEM_ID}--item-sheet-${generateRandomElementId()}`,
      classes: [SYSTEM_CODE],
      title: game.i18n.localize(`${SYSTEM_CODE}.Types.Item.Label`),
      width: 550,
      height: 500,
      minHeight: 180,
      minWidth: 400,
      svelte: {
        class: ItemSheetShell,
        target: document.body
      }
    });
  }
}
class FFCombatTracker extends CombatTracker {
  static {
    __name(this, "FFCombatTracker");
  }
  #combat;
  #combatants;
  /**
   * Initialize the combat tracker
   * @param {object} options - Configuration options
   */
  constructor(options) {
    super(options);
    this.#combat = new TJSDocument();
    this.#combatants = this.#combat.embedded.create(Combatant, "combatants");
    this.#combat.subscribe(() => void 0);
    this.#combatants.subscribe((values) => {
    });
  }
  /** @inheritdoc */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      id: "combat",
      template: `systems/${SYSTEM_ID}/src/extensions/templates/combat-tracker.html`,
      title: "COMBAT.SidebarTitle",
      scrollY: [".directory-list"]
    });
  }
  /**
   * Get additional data for the combat tracker
   * @return {Promise<object>} The prepared data
   */
  async getData() {
    const data = await super.getData();
    for (const turn of data.turns) {
      const currentCombatant = game.combat.combatants.get(turn.id);
      const actor = currentCombatant.actor;
      turn.actorId = actor.id;
      if (turn.active) {
        turn.hasActions = true;
        turn.actions = "";
        if (actor.system.actionState?.available) {
          for (const action of actor.system.actionState.available.sort()) {
            if (!getTypeOptions().some((e) => e.value === action)) {
              turn.actions += `<div data-tooltip="${game.i18n.localize(`FFXIV.Types.Item.Types.Options.Type.${action}`)}" class="action-slot-badge custom-action">${action[0]?.capitalize()}</div>`;
            } else {
              turn.actions += `<div data-tooltip="${game.i18n.localize(`FFXIV.Types.Item.Types.Options.Type.${action}`)}" class="action-slot-badge ${action}">${action[0]?.capitalize()}</div>`;
            }
          }
        }
        if (actor.system.actionState?.used) {
          for (const action of actor.system.actionState.used.sort()) {
            turn.actions += `<div class="action-slot-badge used">${action.type[0].capitalize()}</div>`;
          }
        }
      }
    }
    return data;
  }
  /**
   * Handle mouse down events on combatants
   * @param {Event} event - The triggering mouse event
   * @return {Promise<void>} Returns a promise that resolves when the mouse down event is handled
   */
  async _onCombatantMouseDown(event) {
    event.preventDefault();
    const li = event.currentTarget;
    const combatant = this.viewed.combatants.get(li.dataset.combatantId);
    const token = combatant.token;
    if (!combatant.actor?.testUserPermission(game.user, "OBSERVER"))
      return;
    const now2 = Date.now();
    const dt = now2 - this._clickTime;
    this._clickTime = now2;
    if (dt <= 250) {
      if (event.target.type === void 0) {
        return combatant.actor?.sheet.render(true);
      }
    }
    if (token?.object) {
      token.object?.control({ releaseOthers: true });
      return canvas.animatePan(token.object.center);
    }
  }
  /**
   * Get the class hierarchy names
   * @return {Array<string>} Array of class names in the inheritance chain
   */
  getClassNames() {
    const classNames = [];
    let currentClass = this.constructor;
    while (currentClass) {
      classNames.push(currentClass.name);
      currentClass = Object.getPrototypeOf(currentClass);
    }
    return classNames;
  }
}
const systemconfig = {
  "CR": {
    "easy": 5,
    "average": 10,
    "hard": 15,
    "very": 20,
    "extreme": 25,
    "impossible": 30
  },
  "size": {
    "small": 1,
    "medium": 1,
    "large": 2,
    "huge": 3,
    "colossal": 4
  },
  attributes: {
    primary: [
      "str",
      "dex",
      "vit",
      "int",
      "mnd"
    ],
    secondary: [
      "defence",
      "magicDefence",
      "vigilance",
      "speed"
    ]
  }
};
function init() {
  Hooks.once("init", async (a, b, c) => {
    game.FFXIV = game.system;
    game.system.log = log$1;
    game.system.log.level = log$1.VERBOSE;
    game.system.log.i(`Starting System ${SYSTEM_ID}`);
    if (game.version > 13) {
      window.MIN_WINDOW_WIDTH = 200;
      window.MIN_WINDOW_HEIGHT = 50;
    }
    registerSettings();
    setupModels();
    game.system.config = systemconfig;
    game.system.log.d(game.system.id);
    game.system.log.d(game.system.config);
    CONFIG.ui.combat = FFCombatTracker;
    Actors.registerSheet("foundryvtt-final-fantasy", FFXIVActorSheet$1, {
      makeDefault: true,
      types: ["PC"]
    });
    Actors.registerSheet("foundryvtt-final-fantasy", FFXIVActorSheet2, {
      makeDefault: true,
      types: ["NPC"]
    });
    Items.registerSheet("foundryvtt-final-fantasy", FFXIVItemSheet, {
      makeDefault: true
    });
    DocumentSheetConfig.registerSheet(ActiveEffect, "foundryvtt-final-fantasy", FFActiveEffectSheet, {
      makeDefault: true
    });
    Handlebars.registerHelper("getSetting", function(moduleName, settingKey) {
      return game.settings.get(moduleName, settingKey);
    });
    Hooks.call("FFXIV.initIsComplete");
    hooks.renderCombatTracker();
  });
}
__name(init, "init");
const hooks = {
  renderChatMessage,
  renderCombatTracker,
  updateCombatant,
  canvasReady: canvasReady$1,
  ready: canvasReady,
  init
};
console.log("[FFXIV] | [HOOKS] Setting up hooks");
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[15] = list[i];
  child_ctx[17] = i;
  return child_ctx;
}
__name(get_each_context, "get_each_context");
function create_if_block(ctx) {
  let label_1;
  let t;
  return {
    c() {
      label_1 = element("label");
      t = text(
        /*label*/
        ctx[2]
      );
      attr(label_1, "for", "star-rating-group");
    },
    m(target, anchor) {
      insert(target, label_1, anchor);
      append(label_1, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*label*/
      4)
        set_data(
          t,
          /*label*/
          ctx2[2]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(label_1);
      }
    }
  };
}
__name(create_if_block, "create_if_block");
function create_each_block(ctx) {
  let i_1;
  let i_1_class_value;
  let i_1_aria_label_value;
  let mounted;
  let dispose;
  function mouseover_handler() {
    return (
      /*mouseover_handler*/
      ctx[10](
        /*i*/
        ctx[17]
      )
    );
  }
  __name(mouseover_handler, "mouseover_handler");
  function focus_handler() {
    return (
      /*focus_handler*/
      ctx[11](
        /*i*/
        ctx[17]
      )
    );
  }
  __name(focus_handler, "focus_handler");
  function click_handler2() {
    return (
      /*click_handler*/
      ctx[12](
        /*i*/
        ctx[17]
      )
    );
  }
  __name(click_handler2, "click_handler");
  function keydown_handler(...args) {
    return (
      /*keydown_handler*/
      ctx[13](
        /*i*/
        ctx[17],
        ...args
      )
    );
  }
  __name(keydown_handler, "keydown_handler");
  return {
    c() {
      i_1 = element("i");
      attr(i_1, "class", i_1_class_value = /*icon*/
      ctx[1] + " " + /*star*/
      (ctx[15].active ? "active" : "") + " svelte-qjrcij");
      attr(i_1, "role", "button");
      attr(i_1, "tabindex", "0");
      set_style(
        i_1,
        "--active-color",
        /*activeColor*/
        ctx[3]
      );
      attr(i_1, "aria-label", i_1_aria_label_value = /*i*/
      ctx[17] + 1 + " of " + /*maxStars*/
      ctx[0] + " stars");
    },
    m(target, anchor) {
      insert(target, i_1, anchor);
      if (!mounted) {
        dispose = [
          listen(i_1, "mouseover", mouseover_handler),
          listen(i_1, "focus", focus_handler),
          listen(i_1, "click", click_handler2),
          listen(i_1, "keydown", keydown_handler)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*icon, stars*/
      18 && i_1_class_value !== (i_1_class_value = /*icon*/
      ctx[1] + " " + /*star*/
      (ctx[15].active ? "active" : "") + " svelte-qjrcij")) {
        attr(i_1, "class", i_1_class_value);
      }
      if (dirty & /*activeColor*/
      8) {
        set_style(
          i_1,
          "--active-color",
          /*activeColor*/
          ctx[3]
        );
      }
      if (dirty & /*maxStars*/
      1 && i_1_aria_label_value !== (i_1_aria_label_value = /*i*/
      ctx[17] + 1 + " of " + /*maxStars*/
      ctx[0] + " stars")) {
        attr(i_1, "aria-label", i_1_aria_label_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(i_1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_each_block, "create_each_block");
function create_fragment$1(ctx) {
  let div1;
  let t;
  let div0;
  let div1_aria_label_value;
  let mounted;
  let dispose;
  let if_block = (
    /*label*/
    ctx[2] && create_if_block(ctx)
  );
  let each_value = ensure_array_like(
    /*stars*/
    ctx[4]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  return {
    c() {
      div1 = element("div");
      if (if_block)
        if_block.c();
      t = space();
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "stars svelte-qjrcij");
      attr(div0, "id", "star-rating-group");
      attr(div1, "class", "star-rating svelte-qjrcij");
      attr(div1, "role", "group");
      attr(div1, "aria-label", div1_aria_label_value = /*label*/
      ctx[2] || "Rating");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      if (if_block)
        if_block.m(div1, null);
      append(div1, t);
      append(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      if (!mounted) {
        dispose = listen(
          div1,
          "mouseleave",
          /*handleMouseLeave*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*label*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(div1, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*icon, stars, activeColor, maxStars, handleMouseOver, handleClick*/
      187) {
        each_value = ensure_array_like(
          /*stars*/
          ctx2[4]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div0, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*label*/
      4 && div1_aria_label_value !== (div1_aria_label_value = /*label*/
      ctx2[2] || "Rating")) {
        attr(div1, "aria-label", div1_aria_label_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (if_block)
        if_block.d();
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
__name(create_fragment$1, "create_fragment$1");
function instance$1($$self, $$props, $$invalidate) {
  let stars;
  let { maxStars = 5 } = $$props;
  let { icon = "fas fa-star" } = $$props;
  let { value = 0 } = $$props;
  let { label = "" } = $$props;
  let { activeColor = "#ffd700" } = $$props;
  let hoverValue = 0;
  const dispatch2 = createEventDispatcher();
  function handleMouseOver(index) {
    $$invalidate(9, hoverValue = index + 1);
  }
  __name(handleMouseOver, "handleMouseOver");
  function handleMouseLeave() {
    $$invalidate(9, hoverValue = 0);
  }
  __name(handleMouseLeave, "handleMouseLeave");
  function handleClick(index) {
    $$invalidate(8, value = index + 1);
    dispatch2("change", value);
  }
  __name(handleClick, "handleClick");
  const mouseover_handler = /* @__PURE__ */ __name((i) => handleMouseOver(i), "mouseover_handler");
  const focus_handler = /* @__PURE__ */ __name((i) => handleMouseOver(i), "focus_handler");
  const click_handler2 = /* @__PURE__ */ __name((i) => handleClick(i), "click_handler");
  const keydown_handler = /* @__PURE__ */ __name((i, e) => e.key === "Enter" && handleClick(i), "keydown_handler");
  $$self.$$set = ($$props2) => {
    if ("maxStars" in $$props2)
      $$invalidate(0, maxStars = $$props2.maxStars);
    if ("icon" in $$props2)
      $$invalidate(1, icon = $$props2.icon);
    if ("value" in $$props2)
      $$invalidate(8, value = $$props2.value);
    if ("label" in $$props2)
      $$invalidate(2, label = $$props2.label);
    if ("activeColor" in $$props2)
      $$invalidate(3, activeColor = $$props2.activeColor);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*maxStars, hoverValue, value*/
    769) {
      $$invalidate(4, stars = Array(maxStars).fill(0).map((_, i) => ({
        active: hoverValue ? i < hoverValue : i < value
      })));
    }
  };
  return [
    maxStars,
    icon,
    label,
    activeColor,
    stars,
    handleMouseOver,
    handleMouseLeave,
    handleClick,
    value,
    hoverValue,
    mouseover_handler,
    focus_handler,
    click_handler2,
    keydown_handler
  ];
}
__name(instance$1, "instance$1");
class StarRating extends SvelteComponent {
  static {
    __name(this, "StarRating");
  }
  constructor(options) {
    super();
    init$1(this, options, instance$1, create_fragment$1, safe_not_equal, {
      maxStars: 0,
      icon: 1,
      value: 8,
      label: 2,
      activeColor: 3
    });
  }
}
function create_fragment(ctx) {
  let form;
  let div4;
  let div1;
  let div0;
  let switch_instance0;
  let div3;
  let div2;
  let switch_instance1;
  let current;
  var switch_value = StarRating;
  function switch_props(ctx2, dirty) {
    return {
      props: {
        label: localize$1("Modifiers.Penalty"),
        value: (
          /*penalty*/
          ctx2[0]
        ),
        maxStars: 8,
        icon: "fas fa-burst",
        activeColor: "var(--color-negative)"
      }
    };
  }
  __name(switch_props, "switch_props");
  if (switch_value) {
    switch_instance0 = construct_svelte_component(switch_value, switch_props(ctx));
    switch_instance0.$on(
      "change",
      /*change_handler*/
      ctx[5]
    );
  }
  var switch_value_1 = StarRating;
  function switch_props_1(ctx2, dirty) {
    return {
      props: {
        label: localize$1("Modifiers.Advantage"),
        value: (
          /*bonusDice*/
          ctx2[1]
        ),
        maxStars: 8,
        icon: "fas fa-dice-d20",
        activeColor: "var(--ff-border-color)"
      }
    };
  }
  __name(switch_props_1, "switch_props_1");
  if (switch_value_1) {
    switch_instance1 = construct_svelte_component(switch_value_1, switch_props_1(ctx));
    switch_instance1.$on(
      "change",
      /*change_handler_1*/
      ctx[6]
    );
  }
  return {
    c() {
      form = element("form");
      div4 = element("div");
      div1 = element("div");
      div0 = element("div");
      if (switch_instance0)
        create_component(switch_instance0.$$.fragment);
      div3 = element("div");
      div2 = element("div");
      if (switch_instance1)
        create_component(switch_instance1.$$.fragment);
      attr(div0, "class", "flexcol");
      attr(div1, "class", "flex1");
      attr(div2, "class", "flexcol");
      attr(div3, "class", "flex1");
      attr(div4, "class", "flexrow gap-15");
      attr(form, "class", "modifier-dialog svelte-paczb8");
    },
    m(target, anchor) {
      insert(target, form, anchor);
      append(form, div4);
      append(div4, div1);
      append(div1, div0);
      if (switch_instance0)
        mount_component(switch_instance0, div0, null);
      append(div4, div3);
      append(div3, div2);
      if (switch_instance1)
        mount_component(switch_instance1, div2, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (switch_value !== (switch_value = StarRating)) {
        if (switch_instance0) {
          group_outros();
          const old_component = switch_instance0;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance0 = construct_svelte_component(switch_value, switch_props(ctx2));
          switch_instance0.$on(
            "change",
            /*change_handler*/
            ctx2[5]
          );
          create_component(switch_instance0.$$.fragment);
          transition_in(switch_instance0.$$.fragment, 1);
          mount_component(switch_instance0, div0, null);
        } else {
          switch_instance0 = null;
        }
      } else if (switch_value) {
        const switch_instance0_changes = {};
        if (dirty & /*penalty*/
        1)
          switch_instance0_changes.value = /*penalty*/
          ctx2[0];
        switch_instance0.$set(switch_instance0_changes);
      }
      if (switch_value_1 !== (switch_value_1 = StarRating)) {
        if (switch_instance1) {
          group_outros();
          const old_component = switch_instance1;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_1) {
          switch_instance1 = construct_svelte_component(switch_value_1, switch_props_1(ctx2));
          switch_instance1.$on(
            "change",
            /*change_handler_1*/
            ctx2[6]
          );
          create_component(switch_instance1.$$.fragment);
          transition_in(switch_instance1.$$.fragment, 1);
          mount_component(switch_instance1, div2, null);
        } else {
          switch_instance1 = null;
        }
      } else if (switch_value_1) {
        const switch_instance1_changes = {};
        if (dirty & /*bonusDice*/
        2)
          switch_instance1_changes.value = /*bonusDice*/
          ctx2[1];
        switch_instance1.$set(switch_instance1_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance0)
        transition_in(switch_instance0.$$.fragment, local);
      if (switch_instance1)
        transition_in(switch_instance1.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance0)
        transition_out(switch_instance0.$$.fragment, local);
      if (switch_instance1)
        transition_out(switch_instance1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(form);
      }
      if (switch_instance0)
        destroy_component(switch_instance0);
      if (switch_instance1)
        destroy_component(switch_instance1);
    }
  };
}
__name(create_fragment, "create_fragment");
function instance($$self, $$props, $$invalidate) {
  let { penalty = 0 } = $$props;
  let { bonusDice = 0 } = $$props;
  let { mutuallyExclusive = false } = $$props;
  function handlePenaltyChange(value) {
    $$invalidate(0, penalty = value);
    if (mutuallyExclusive && value > 0)
      $$invalidate(1, bonusDice = 0);
  }
  __name(handlePenaltyChange, "handlePenaltyChange");
  function handleBonusChange(value) {
    $$invalidate(1, bonusDice = value);
    if (mutuallyExclusive && value > 0)
      $$invalidate(0, penalty = 0);
  }
  __name(handleBonusChange, "handleBonusChange");
  const change_handler = /* @__PURE__ */ __name((e) => handlePenaltyChange(e.detail), "change_handler");
  const change_handler_1 = /* @__PURE__ */ __name((e) => handleBonusChange(e.detail), "change_handler_1");
  $$self.$$set = ($$props2) => {
    if ("penalty" in $$props2)
      $$invalidate(0, penalty = $$props2.penalty);
    if ("bonusDice" in $$props2)
      $$invalidate(1, bonusDice = $$props2.bonusDice);
    if ("mutuallyExclusive" in $$props2)
      $$invalidate(4, mutuallyExclusive = $$props2.mutuallyExclusive);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*penalty, bonusDice*/
    3) {
      if (window._modifierDialogComponent) {
        window._modifierDialogComponent._state = { penalty, bonusDice };
      }
    }
  };
  return [
    penalty,
    bonusDice,
    handlePenaltyChange,
    handleBonusChange,
    mutuallyExclusive,
    change_handler,
    change_handler_1
  ];
}
__name(instance, "instance");
class ModifierDialog extends SvelteComponent {
  static {
    __name(this, "ModifierDialog");
  }
  constructor(options) {
    super();
    init$1(this, options, instance, create_fragment, safe_not_equal, {
      penalty: 0,
      bonusDice: 1,
      mutuallyExclusive: 4
    });
  }
}
class RollGuards {
  static {
    __name(this, "RollGuards");
  }
  /** @type {Actor} The actor associated with these roll guards */
  actor;
  /** 
   * Shuttle object used to pass data from guards to roll calculator
   * @type {Object} 
   */
  shuttle = {
    hasModifiers: {
      extraModifiers: null
    }
  };
  /**
   * Create a new RollGuards instance
   * @param {Actor} actor - The actor to check guards for
   */
  constructor(actor) {
    this.actor = actor;
  }
  /**
   * Dialog to allow extra modifiers to be added to the roll
   * @param {Item} item - The item being rolled
   * @return {Promise<Object>} The modifier data from the dialog
   * @private
   */
  async _showModifierDialog(item) {
    return new Promise((resolve) => {
      new Dialog({
        title: "Extra Modifiers",
        content: `<div id="modifier-dialog-container"></div>`,
        buttons: {
          roll: {
            label: "Roll",
            callback: (html) => {
              resolve({
                penalty: window._modifierDialogComponent?._state?.penalty || 0,
                bonusDice: window._modifierDialogComponent?._state?.bonusDice || 0,
                confirmed: true
              });
            }
          },
          cancel: {
            label: "Cancel",
            callback: () => resolve({ confirmed: false })
          }
        },
        render: (html) => {
          const container = html.find("#modifier-dialog-container")[0];
          window._modifierDialogComponent = new ModifierDialog({
            target: container,
            props: {
              mutuallyExclusive: false
            }
          });
        },
        close: () => {
          window._modifierDialogComponent?.$destroy();
          delete window._modifierDialogComponent;
          resolve({ confirmed: false });
        }
      }).render(true);
    });
  }
  /**
   * Check and handle any modifiers for the roll
   * @param {Item} item - The item being used
   * @return {Promise<boolean>} Whether modifiers were successfully handled
   */
  async hasModifiers(item) {
    if (!item.system.hasCR) {
      return true;
    }
    this.shuttle.hasModifiers.extraModifiers = await this._showModifierDialog(item);
    if (!this.shuttle.hasModifiers.extraModifiers?.confirmed) {
      for (const effect of this.actor.effects) {
        if (effect.getFlag(SYSTEM_ID, "pendingDeletion")) {
          await effect.unsetFlag(SYSTEM_ID, "pendingDeletion");
        }
      }
      return false;
    }
    for (const effect of this.actor.effects) {
      if (effect.getFlag(SYSTEM_ID, "pendingDeletion")) {
        await effect.delete();
      }
    }
    Hooks.call("FFXIV.processTargetRollAdditionalModifiers", { item, extraModifiers: this.shuttle.hasModifiers.extraModifiers, actor: this.actor });
    return true;
  }
}
class RollCalc {
  static {
    __name(this, "RollCalc");
  }
  /**
   * Creates a new RollCalc instance
   * @param {object} params - The parameters for the roll calculation
   */
  constructor(params) {
    this.params = params;
    this.store = writable({});
    this.subscribe = this.store.subscribe;
    this.set = this.store.set;
    this.update = this.store.update;
    this.RG = new CONFIG.FFXIV.RollGuards(this.params.actor);
  }
  /**
   * Send the roll to chat
   * @return {Promise<void>} Returns a promise that resolves when the message is sent
   */
  async send() {
    if (this.params.rollType) {
      let message = await this[this.params.rollType](this.params);
      if (message === false)
        return;
      message.sound = "sounds/dice.wav";
      message.rollType = this.params.rollType;
      message.applied = false;
      message = Object.assign({}, this.message, message);
      await this.createChatMessage(message);
    }
  }
  /**
   * Perform a dice roll
   * @param {number} die - The die size
   * @param {number} noOfDice - Number of dice to roll
   * @param {number} modifier - Roll modifier
   * @param {string} keep - Keep modifier
   * @return {Promise<object>} Returns a promise that resolves with the roll result
   */
  async roll(die = 4, noOfDice = 1, modifier = 0, keep = "") {
    const rollString = `max(${noOfDice}d${die}${keep}${modifier === 0 ? "" : modifier > 0 ? "+" + modifier : modifier},1)`;
    const roll = new Roll(rollString);
    if (game.version < 12) {
      await roll.roll({ async: true });
    } else {
      await roll.roll();
    }
    if (game.modules.get("dice-so-nice")?.active) {
      await game.dice3d.showForRoll(roll);
    }
    return { roll, die, noOfDice, error: false };
  }
  /**
   * Play a sound for the message
   * @param {string} soundPath - Path to the sound file
   * @return {void} Nothing
   */
  playMessageSound(soundPath) {
    const customSound = game.settings.get(SYSTEM_ID, "chatMessageSound").trim();
    if (!soundPath && customSound !== "") {
      soundPath = customSound;
    }
    if (soundPath) {
      foundry.audio.AudioHelper.play({ src: soundPath, volume: 1, autoplay: true, loop: false });
    }
  }
  /**
   * Create a chat message for the roll
   * @param {object} props - The message properties
   * @return {Promise<void>} Returns a promise that resolves when the message is created
   */
  async createChatMessage(props) {
    const data = { ...props };
    const item = props.Item ? props.Item : fromUuidSync(props.itemUuid);
    const actor = fromUuidSync(props.actorUuid);
    if (!item) {
      ui.notifications.error("Item cannot be used from a compendium Actor.");
      return;
    }
    if (!actor) {
      ui.notifications.error("Actor not found");
      return;
    }
    await ChatMessage.create({
      user: game.user.id,
      flags: { [SYSTEM_ID]: { data } },
      speaker: game.settings.get(SYSTEM_ID, "chatMessageSenderIsActorOwner") ? ChatMessage.getSpeaker({ actor }) : null
    });
    this.playMessageSound();
  }
}
class AttributeHandler {
  static {
    __name(this, "AttributeHandler");
  }
  /**
   * @param {Actor} actor - The actor this handler is for
   */
  constructor(actor) {
    this.actor = actor;
  }
  /**
   * Handle an action ability
   * @param {Object} [options={}] -  options
   * @return {Promise<{success: boolean, message: ChatMessage|null}>} Returns result of action handling
   */
  async handle(options = {}) {
    const { key, code } = options;
    const attributeValue = this.actor.system.attributes[key][code].val;
    const rollFormula = `1d20 + ${attributeValue}`;
    const attributeName = game.i18n.localize(`FFXIV.Types.Actor.Types.PC.Attributes.${key}.${code}.Abbreviation`);
    const roll = await new Roll(rollFormula).evaluate({ async: true });
    const isCritical = roll.total === 20;
    const messageData = {
      speaker: game.settings.get(SYSTEM_ID, "chatMessageSenderIsActorOwner") ? ChatMessage.getSpeaker({ actor: this.actor }) : null,
      flavor: `${attributeName} ${game.i18n.localize("FFXIV.Check")}`,
      type: CONST.CHAT_MESSAGE_TYPES.ROLL,
      roll,
      flags: {
        [SYSTEM_ID]: {
          data: {
            chatTemplate: "AttributeRollChat",
            actor: {
              _id: this.actor._id,
              name: this.actor.name,
              img: this.actor.img
            },
            flavor: `${attributeName} ${game.i18n.localize("FFXIV.Check")}`,
            key,
            code,
            modifier: attributeValue,
            isCritical
          },
          css: `attribute-roll ${isCritical ? "crit" : ""}`
        }
      }
    };
    await roll.toMessage(messageData);
  }
}
class GuardManager {
  static {
    __name(this, "GuardManager");
  }
  /**
   * @param {Actor} actor - The actor this handler is for
   * @param {RollGuards} rollGuards - The RollGuards instance to use for checks
   */
  constructor(actor) {
    this.actor = actor;
    this.RG = new RollGuards(actor);
  }
  /**
   * Handle guards for an item
   * @param {Item} item - The item to check guards for
   * @param {Array<string>} guardMethodNames - Array of guard method names to check
   * @return {Promise<boolean>} Returns true if all guards pass, false otherwise
   */
  async handleGuards(item, guardMethodNames) {
    for (const methodName of guardMethodNames) {
      const guardMethod = this.RG[methodName];
      if (!guardMethod) {
        game.system.log.w(`[GUARD] Guard method ${methodName} not found`);
        continue;
      }
      try {
        const result = await guardMethod.call(this.RG, item);
        if (!result) {
          game.system.log.d(`[GUARD] ${methodName} check failed for ${item.name}`);
          return false;
        }
      } catch (error) {
        game.system.log.e(`[GUARD] Error in ${methodName} check:`, error);
        return false;
      }
    }
    return true;
  }
}
class RollCalcActor extends RollCalc {
  static {
    __name(this, "RollCalcActor");
  }
  constructor(params) {
    super(params);
    this.params = params;
    this.AttributeHandler = new AttributeHandler(params.actor);
    this.EffectManager = new EffectManager(params.actor);
    this.GuardManager = new GuardManager(params.actor);
    this.DefaultChat = new DefaultChatHandler(params.actor);
  }
  /**
   * @param {Item} item - The item to create a chat message for
   */
  defaultChat(item) {
    this.DefaultChat.handle(item);
  }
  /**
   * @param {Item} item - The equipment item
   */
  equipment(item) {
    this.params.item = item;
    ChatMessage.create({
      user: game.user.id,
      speaker: game.settings.get(SYSTEM_ID, "chatMessageSenderIsActorOwner") ? ChatMessage.getSpeaker({ actor: this.params.actor }) : null,
      flags: { [SYSTEM_ID]: { data: { ...this.params, chatTemplate: "EquipmentChat" } } }
    });
  }
  /**
   * @param {string} key - The attribute key
   * @param {string} code - The attribute code
   */
  attribute(key, code) {
    this.AttributeHandler.handle({ key, code });
  }
  /**
   * @param {string} type - The type of ability
   * @param {Item} item - The ability item
   */
  ability(type, item) {
    console.log("[FFXIV] | [ABILITY CHAIN] Starting ability chain", {
      // Add relevant details
    });
    this._routeAbility(item);
  }
  /**
   * @param {Item} item - The trait item
   */
  abilityTrait(item) {
    this.defaultChat(item);
  }
  /**
   * @param {Item} item - The action item
   * @param {Object} [options={}] - Additional options
   */
  async abilityAction(item, options = {}) {
    console.log("[FFXIV] | [ROLL CALC] abilityAction call stack:", {
      stack: new Error().stack,
      itemName: item?.name,
      options
    });
    try {
      if (!await this.GuardManager.handleGuards(item, [
        "hasModifiers"
      ])) {
        return;
      }
      await this.EffectManager.handleEffects();
      this.defaultChat(item);
    } catch (error) {
      game.system.log.e("Error in ability action", error);
      ui.notifications.error(game.i18n.format("FFXIV.Errors.AbilityActionFailed", { target: this.params.actor.name }));
    }
  }
  /**
   * Route ability to appropriate handler
   * @param {Item} item - The item to route
   * @return {Promise<void>} Returns a promise that resolves when the ability has been routed and handled
   */
  _routeAbility(item) {
    if (item.type === "action") {
      this.abilityAction(item);
    } else if (item.type === "trait") {
      this.abilityTrait(item);
    }
  }
}
CONFIG.FFXIV = {
  RollGuards,
  RollCalcActor,
  RollCalc,
  EffectManager
};
CONFIG.Actor.documentClass = FFXIVActor;
CONFIG.Item.documentClass = FFXIVItem;
CONFIG.Combat.documentClass = FFCombat;
CONFIG.Combatant.documentClass = FFCombatants;
CONFIG.Token.objectClass = FFToken;
CONFIG.ActiveEffect.documentClass = FFActiveEffect;
CONFIG.ActiveEffect.dataModels.base = FFEffectModel;
CONFIG.time.roundTime = 6;
CONFIG.Combat.initiative = {
  formula: "1d20 + (@attributes.primary.dex.val)"
};
hooks.init();
hooks.ready();
hooks.canvasReady();
hooks.renderCombatTracker();
hooks.renderChatMessage();
hooks.updateCombatant();
//# sourceMappingURL=index.js.map
